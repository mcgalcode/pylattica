{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pylattica - A Framework for Lattice and Cellular Automata Simulation","text":"<p>pylattica is a Python library for prototyping and constructing cellular automaton and lattice models. The core features of these models are:</p> <ul> <li>There is a simulation state that evolves over time by repeatedly applying some unchanging rule</li> <li>The state of the simulation has a topology defined by a network of sites (i.e. each site has an unchanging set of neighbor sites)</li> <li>Each site has a state value associated with it that could change at each simulation step</li> <li>The future state of a site is determined by the state of its neighbor sites</li> </ul> <p>These rules capture many common models in chemistry and materials science. For instance, in the Ising Model, spins are updated with probabilities related to the neighboring spins. In a Lattice Gas Automaton, the velocities of particles are determined collisions with neighboring particles. In lattice Monte Carlo simulations of surface catalysis, adsorption, desorption, and surface diffusion are dependent on the occupancy of neighboring sites.</p> <p>pylattica aims to provide a general framework for prototyping these types of lattice simulations. It prioritizes providing a straightforward method for experimenting with different interaction rules and interaction neighborhoods. It provides some simple utilities for analyzing simulation states, and in the case of square grid systems, it provides visualization tools for the system state itself. Additionally, since this tool is focused on materials science, there is functionality for mapping system states to CIF files (for use in crystal lattice simulations).</p>"},{"location":"#installation","title":"Installation","text":"<p><code>pylattica</code> can be installed from the PyPi source by running:</p> <pre><code>pip install pylattica\n</code></pre> <p>It can also be installed by cloning this repository, then running the following in the root of the repository:</p> <pre><code>pip install .\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>Detailed documentation for this library can be found here.</p>"},{"location":"#jupyter-notebook-examples","title":"Jupyter Notebook Examples","text":"<p>Example notebooks are included in docs/guides.</p>"},{"location":"#note-about-windows","title":"Note about Windows","text":"<p><code>pylattica</code> makes use of Python's fork functionality in the multiprocessing library. This functionality is not available on windows, so certain features (the <code>parallel</code> keyword for the <code>SynchronousRunner</code>) will not be available on Windows platforms.</p>"},{"location":"#development","title":"Development","text":""},{"location":"#installation-for-development","title":"Installation for development","text":"<p>To install pylattica for development purposes, use the standard editable installation command:</p> <pre><code>pip install -e .\n</code></pre> <p>from the root of the repository.</p>"},{"location":"#running-tests","title":"Running tests","text":"<p>After you have installed the repository, ensure that <code>pytest</code> is installed, then run:</p> <pre><code>pytest\n</code></pre> <p>from the root of the repository.</p>"},{"location":"#building-documentation","title":"Building Documentation","text":"<p>The docs for this project are built using mkdocs. To build the documentation</p> <pre><code>pip install '.[docs]'\nmkdocs build\n</code></pre> <p>To run the documentation server locally:</p> <pre><code>mkdocs serve\n</code></pre>"},{"location":"#linting","title":"Linting","text":"<p>This project uses the <code>black</code> package for style and formatting, and <code>prospector</code> for type checking and other lint warnings. These packages are not listed as dependencies of this project, so you can install them manually. This is partially because this project doesn't rely on specific versions of them, and we expect developers to have their own installations already. You can run them as follows:</p> <p>To assess the changes that will happen if you run the <code>black</code> linter, run the following:</p> <pre><code>black --check src\n</code></pre> <p>To automatically make the changes, remove the <code>--check</code> flag:</p> <pre><code>black src\n</code></pre> <p>To run all other linters with prospector, use this:</p> <pre><code>prospector\n</code></pre> <p>In the top of this repository.</p>"},{"location":"examples/life_like_demos/","title":"Life-like Cellular Automata","text":"In\u00a0[16]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n</pre> %load_ext autoreload %autoreload 2 <pre>The autoreload extension is already loaded. To reload it, use:\n  %reload_ext autoreload\n</pre> In\u00a0[17]: Copied! <pre>from pylattica.core import BasicController, SynchronousRunner, SimulationState\nfrom pylattica.structures.square_grid import MooreNbHoodBuilder, VonNeumannNbHood2DBuilder\nfrom pylattica.discrete.state_constants import DISCRETE_OCCUPANCY\nfrom pylattica.models.game_of_life import Maze, Anneal, Diamoeba, Seeds, Life, GameOfLifeController\n</pre> from pylattica.core import BasicController, SynchronousRunner, SimulationState from pylattica.structures.square_grid import MooreNbHoodBuilder, VonNeumannNbHood2DBuilder from pylattica.discrete.state_constants import DISCRETE_OCCUPANCY from pylattica.models.game_of_life import Maze, Anneal, Diamoeba, Seeds, Life, GameOfLifeController In\u00a0[18]: Copied! <pre>from pylattica.discrete import PhaseSet\nfrom pylattica.structures.square_grid.grid_setup import DiscreteGridSetup\nfrom pylattica.visualization import SquareGridArtist2D, ResultArtist, DiscreteCellArtist\n\nphases = PhaseSet([\"dead\", \"alive\"])\nsetup = DiscreteGridSetup(phases)\ncell_artist = DiscreteCellArtist.from_phase_list(phases.phases)\n</pre> from pylattica.discrete import PhaseSet from pylattica.structures.square_grid.grid_setup import DiscreteGridSetup from pylattica.visualization import SquareGridArtist2D, ResultArtist, DiscreteCellArtist  phases = PhaseSet([\"dead\", \"alive\"]) setup = DiscreteGridSetup(phases) cell_artist = DiscreteCellArtist.from_phase_list(phases.phases) In\u00a0[19]: Copied! <pre>starting_state = setup.setup_noise(100, [\"dead\", \"alive\"])\nartist = SquareGridArtist2D(starting_state.structure, cell_artist)\ncontroller = GameOfLifeController(starting_state.structure, Life)\nrunner = SynchronousRunner(parallel=True)\nresult = runner.run(starting_state.state, controller, 60, verbose=False)\nartist.jupyter_show(result.last_step, cell_size=5)\n</pre> starting_state = setup.setup_noise(100, [\"dead\", \"alive\"]) artist = SquareGridArtist2D(starting_state.structure, cell_artist) controller = GameOfLifeController(starting_state.structure, Life) runner = SynchronousRunner(parallel=True) result = runner.run(starting_state.state, controller, 60, verbose=False) artist.jupyter_show(result.last_step, cell_size=5) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10000/10000 [00:00&lt;00:00, 14403.08it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 60/60 [00:00&lt;00:00, 60.08it/s]\n</pre> In\u00a0[29]: Copied! <pre>ResultArtist(artist, result).to_gif(\"Life.gif\", wait=0.2, cell_size=6)\n</pre> ResultArtist(artist, result).to_gif(\"Life.gif\", wait=0.2, cell_size=6) In\u00a0[28]: Copied! <pre>starting_state = setup.setup_noise(100, [\"dead\", \"alive\"])\nartist = SquareGridArtist2D(starting_state.structure, cell_artist)\ncontroller = GameOfLifeController(starting_state.structure, Seeds)\nrunner = SynchronousRunner(parallel=True)\nresult = runner.run(starting_state.state, controller, 60, verbose=False)\nartist.jupyter_show(result.last_step, cell_size=5)\nResultArtist(artist, result).to_gif(\"Seeds.gif\", wait=0.2, cell_size=6)\n</pre> starting_state = setup.setup_noise(100, [\"dead\", \"alive\"]) artist = SquareGridArtist2D(starting_state.structure, cell_artist) controller = GameOfLifeController(starting_state.structure, Seeds) runner = SynchronousRunner(parallel=True) result = runner.run(starting_state.state, controller, 60, verbose=False) artist.jupyter_show(result.last_step, cell_size=5) ResultArtist(artist, result).to_gif(\"Seeds.gif\", wait=0.2, cell_size=6) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10000/10000 [00:00&lt;00:00, 14556.74it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 60/60 [00:01&lt;00:00, 59.55it/s]\n</pre> In\u00a0[27]: Copied! <pre>starting_state = setup.setup_noise(100, [\"dead\", \"alive\"])\nartist = SquareGridArtist2D(starting_state.structure, cell_artist)\ncontroller = GameOfLifeController(starting_state.structure, Diamoeba)\nrunner = SynchronousRunner(parallel=True)\nresult = runner.run(starting_state.state, controller, 60, verbose=False)\nartist.jupyter_show(result.last_step, cell_size=5)\nResultArtist(artist, result).to_gif(\"Diamoeba.gif\", wait=0.2, cell_size=6)\n</pre> starting_state = setup.setup_noise(100, [\"dead\", \"alive\"]) artist = SquareGridArtist2D(starting_state.structure, cell_artist) controller = GameOfLifeController(starting_state.structure, Diamoeba) runner = SynchronousRunner(parallel=True) result = runner.run(starting_state.state, controller, 60, verbose=False) artist.jupyter_show(result.last_step, cell_size=5) ResultArtist(artist, result).to_gif(\"Diamoeba.gif\", wait=0.2, cell_size=6) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10000/10000 [00:00&lt;00:00, 14601.01it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 60/60 [00:01&lt;00:00, 58.76it/s]\n</pre> In\u00a0[26]: Copied! <pre>starting_state = setup.setup_noise(100, [\"dead\", \"alive\"])\nartist = SquareGridArtist2D(starting_state.structure, cell_artist)\ncontroller = GameOfLifeController(starting_state.structure, Anneal)\nrunner = SynchronousRunner(parallel=True)\nresult = runner.run(starting_state.state, controller, 60, verbose=False)\nartist.jupyter_show(result.last_step, cell_size=5)\nResultArtist(artist, result).to_gif(\"Anneal.gif\", wait=0.2, cell_size=6)\n</pre> starting_state = setup.setup_noise(100, [\"dead\", \"alive\"]) artist = SquareGridArtist2D(starting_state.structure, cell_artist) controller = GameOfLifeController(starting_state.structure, Anneal) runner = SynchronousRunner(parallel=True) result = runner.run(starting_state.state, controller, 60, verbose=False) artist.jupyter_show(result.last_step, cell_size=5) ResultArtist(artist, result).to_gif(\"Anneal.gif\", wait=0.2, cell_size=6) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10000/10000 [00:00&lt;00:00, 14040.92it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 60/60 [00:01&lt;00:00, 57.99it/s]\n</pre> In\u00a0[31]: Copied! <pre>starting_state = setup.setup_particle(100, 30, \"dead\", \"alive\")\nartist = SquareGridArtist2D(starting_state.structure, cell_artist)\ncontroller = GameOfLifeController(starting_state.structure, Maze)\nrunner = SynchronousRunner(parallel=True)\nresult = runner.run(starting_state.state, controller, 60, verbose=False)\nartist.jupyter_show(result.last_step, cell_size=5)\nResultArtist(artist, result).to_gif(\"Maze.gif\", wait=0.2, cell_size=6)\n</pre> starting_state = setup.setup_particle(100, 30, \"dead\", \"alive\") artist = SquareGridArtist2D(starting_state.structure, cell_artist) controller = GameOfLifeController(starting_state.structure, Maze) runner = SynchronousRunner(parallel=True) result = runner.run(starting_state.state, controller, 60, verbose=False) artist.jupyter_show(result.last_step, cell_size=5) ResultArtist(artist, result).to_gif(\"Maze.gif\", wait=0.2, cell_size=6) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10000/10000 [00:00&lt;00:00, 13928.12it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 60/60 [00:01&lt;00:00, 57.46it/s]\n</pre> In\u00a0[32]: Copied! <pre>starting_state = setup.setup_particle(100, 30, \"dead\", \"alive\")\nartist = SquareGridArtist2D(starting_state.structure, cell_artist)\ncontroller = GameOfLifeController(starting_state.structure, variant=\"B3678/S34678\")\nrunner = SynchronousRunner(parallel=True)\nresult = runner.run(starting_state.state, controller, 60, verbose=False)\nartist.jupyter_show(result.last_step, cell_size=5)\nResultArtist(artist, result).to_gif(\"daynnite.gif\", wait=0.2, cell_size=6)\n</pre> starting_state = setup.setup_particle(100, 30, \"dead\", \"alive\") artist = SquareGridArtist2D(starting_state.structure, cell_artist) controller = GameOfLifeController(starting_state.structure, variant=\"B3678/S34678\") runner = SynchronousRunner(parallel=True) result = runner.run(starting_state.state, controller, 60, verbose=False) artist.jupyter_show(result.last_step, cell_size=5) ResultArtist(artist, result).to_gif(\"daynnite.gif\", wait=0.2, cell_size=6) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10000/10000 [00:00&lt;00:00, 14349.37it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 60/60 [00:01&lt;00:00, 56.26it/s]\n</pre> In\u00a0[57]: Copied! <pre>starting_state = setup.setup_particle(100, 30, \"dead\", \"alive\")\ncontroller = GameOfLifeController(variant=\"B3/S238\")\nrunner = Runner(parallel=True)\nresult = runner.run(starting_state.state, controller, 150, structure=starting_state.structure, verbose=False)\nartist.jupyter_show(result.last_step, cell_size=5)\nDiscreteSquareGridResultArtist(artist, result).to_gif(\"8life.gif\", wait=0.2, cell_size=6)\n</pre> starting_state = setup.setup_particle(100, 30, \"dead\", \"alive\") controller = GameOfLifeController(variant=\"B3/S238\") runner = Runner(parallel=True) result = runner.run(starting_state.state, controller, 150, structure=starting_state.structure, verbose=False) artist.jupyter_show(result.last_step, cell_size=5) DiscreteSquareGridResultArtist(artist, result).to_gif(\"8life.gif\", wait=0.2, cell_size=6) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10000/10000 [00:00&lt;00:00, 71312.42it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 150/150 [00:07&lt;00:00, 20.32it/s]\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/life_like_demos/#life-like-cellular-automata","title":"Life-like Cellular Automata\u00b6","text":"<p>There are many variations on Conway's Game of Life which Life-like Automata. There are implementations of these in pylattica for your enjoyment.</p>"},{"location":"examples/life_like_demos/#life","title":"Life\u00b6","text":""},{"location":"examples/life_like_demos/#seeds","title":"Seeds\u00b6","text":""},{"location":"examples/life_like_demos/#diamoeba","title":"Diamoeba\u00b6","text":""},{"location":"examples/life_like_demos/#anneal","title":"Anneal\u00b6","text":""},{"location":"examples/life_like_demos/#maze","title":"Maze\u00b6","text":""},{"location":"examples/life_like_demos/#other-lifes","title":"Other Lifes\u00b6","text":"<p>You can specify any other life variant using the <code>Bxxx/Sxxx</code> syntax.</p>"},{"location":"guides/","title":"Getting Started with Pylattica","text":"<p><code>pylattica</code> is an extremely flexible library. It doesn't make many prescriptions regarding the use of the pieces that it implements. It's main goal is to provide implementations of common lattice simulation constructs which you can piece together in whatever ways aid your development use case. As a result, a generic \"how to\" guide is a difficult proposition.</p> <p>I believe that the best way to learn how to use <code>pylattica</code> is by way of example, so I recommend looking at the Implementing Conway's Game of Life example.</p> <p>It's likely that this demonstration does not illustrate everything you need for your own simulation. To see how each of the core pieces of pylattica work, take a look at the following topic-specific guides:</p> <ul> <li>Constructing Lattices</li> <li>Periodic Structures</li> <li>Building Neighborhoods</li> <li>Representing Simulation State</li> <li>Controllers and Update Rules</li> <li>Runners</li> <li>Working With Square Grids</li> </ul> <p>NOTE: These guides can be found in docs/guides in the source repository.</p> <p>Finally, if all else fails, the Reference provides individual method-level detail for the use of this library.</p>"},{"location":"guides/constructing_lattices/","title":"Constructing Custom Lattices","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n</pre> %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>from pylattica.core import Lattice\n</pre> from pylattica.core import Lattice In\u00a0[3]: Copied! <pre>square_grid_2d = Lattice([\n    [1, 0],\n    [0, 1]\n])\n</pre> square_grid_2d = Lattice([     [1, 0],     [0, 1] ]) <p>To construct an Oblique lattice, we use the same procedure, but with a different pair of vectors. Note that in this case, the first vector is not a unit vector.</p> In\u00a0[4]: Copied! <pre>oblique = Lattice([\n    [1, 1],\n    [1, 0]\n])\n</pre> oblique = Lattice([     [1, 1],     [1, 0] ])  In\u00a0[5]: Copied! <pre>cart_coord = (0.5, 0.25)\n</pre> cart_coord = (0.5, 0.25) <p>Converting to fractional coordinates means that we are performing a change of basis operation from the intuitive orthogonal Cartesian basis to the basis defined by the lattice vectors.</p> <p>We can see that this point can be decomposed as 0.25 times our first lattice vector, and 0.25 times our second lattice vector. Recall that the lattice vectors are defined a few cells above.</p> In\u00a0[6]: Copied! <pre>frac_coord = oblique.get_fractional_coords(cart_coord)\nprint(\"Fractional coordinate is: \", frac_coord)\n</pre> frac_coord = oblique.get_fractional_coords(cart_coord) print(\"Fractional coordinate is: \", frac_coord) <pre>Fractional coordinate is:  [0.25 0.25]\n</pre> <p>We can also convert back from the fractional representation of our coordinate to the Cartesian form of our coordinate. This is also a change of basis operation.</p> In\u00a0[7]: Copied! <pre>resolved_cart_coord = oblique.get_cartesian_coords(frac_coord)\nprint(\"Cartesian coordinate, again: \", resolved_cart_coord)\n</pre> resolved_cart_coord = oblique.get_cartesian_coords(frac_coord) print(\"Cartesian coordinate, again: \", resolved_cart_coord) <pre>Cartesian coordinate, again:  [0.5  0.25]\n</pre> <p>Note that this is the same value as our original point.</p> In\u00a0[8]: Copied! <pre>cart_coord = (1.5, 0.5)\n</pre> cart_coord = (1.5, 0.5) <p>This point is outside the unit cell (because the lattice vectors are (1, 0) and (0, 1), bounding a square of side length 1). Since period boundary conditions apply in all directions by default, we can expect our Lattice to convert this to the point in the middle of the cell (0.5, 0.5):</p> In\u00a0[9]: Copied! <pre>periodized_pt = square_grid_2d.get_periodized_cartesian_coords(cart_coord)\nprint(\"Periodized point: \", periodized_pt)\n</pre> periodized_pt = square_grid_2d.get_periodized_cartesian_coords(cart_coord) print(\"Periodized point: \", periodized_pt) <pre>Periodized point:  [0.5 0.5]\n</pre> <p>Negative coordinates are also allowed. Here's a point that's totally outside the unit cell, in the negative direction:</p> In\u00a0[10]: Copied! <pre>cart_coord = (-1.3, -0.2)\nperiodized_pt = square_grid_2d.get_periodized_cartesian_coords(cart_coord)\nprint(\"Periodized point: \", periodized_pt)\n</pre> cart_coord = (-1.3, -0.2) periodized_pt = square_grid_2d.get_periodized_cartesian_coords(cart_coord) print(\"Periodized point: \", periodized_pt) <pre>Periodized point:  [0.7 0.8]\n</pre> <p>Note that this point has come back in from the top right corner of the cell.</p> In\u00a0[11]: Copied! <pre>lattice_vecs = [\n    [1, 0],\n    [0, 1]\n]\n\naperiodic_lat = Lattice(lattice_vecs, periodic=False)\n</pre> lattice_vecs = [     [1, 0],     [0, 1] ]  aperiodic_lat = Lattice(lattice_vecs, periodic=False) <p>Now, when we periodize a point as before, the coordinates remain unchanged.</p> In\u00a0[12]: Copied! <pre>cart_coords = (1.5, 1.2)\nperiodized_pt = aperiodic_lat.get_periodized_cartesian_coords(cart_coords)\nprint(\"Periodized point (same as cart_coords): \", periodized_pt)\n</pre> cart_coords = (1.5, 1.2) periodized_pt = aperiodic_lat.get_periodized_cartesian_coords(cart_coords) print(\"Periodized point (same as cart_coords): \", periodized_pt) <pre>Periodized point (same as cart_coords):  [1.5 1.2]\n</pre> <p>We can also specify that our lattice is periodic in only some of it's dimensions, like so:</p> In\u00a0[13]: Copied! <pre>partially_periodic = Lattice(lattice_vecs, periodic=(True, False))\n</pre> partially_periodic = Lattice(lattice_vecs, periodic=(True, False)) <p>This lattice has periodic boundary conditions in the direction of the first lattice vector, but not in the direction of the other.</p> <p>See here:</p> In\u00a0[15]: Copied! <pre>cart_coords = (1.5, 1.5)\nperiodized_pt = partially_periodic.get_periodized_cartesian_coords(cart_coords)\nprint(\"Periodized point: \", periodized_pt)\n</pre> cart_coords = (1.5, 1.5) periodized_pt = partially_periodic.get_periodized_cartesian_coords(cart_coords) print(\"Periodized point: \", periodized_pt) <pre>Periodized point:  [0.5 1.5]\n</pre> In\u00a0[26]: Copied! <pre>lattice_vecs = [\n    [1, 0],\n    [0, 1]\n]\n\nperiodic_lattice = Lattice(lattice_vecs)\nnonperiodic_lattice = Lattice(lattice_vecs, periodic=False)\n\npt1 = (0.1, 0.5)\npt2 = (0.9, 0.5)\n\nprint(\"Distance under periodic boundary conditions: \", periodic_lattice.cartesian_periodic_distance(pt1, pt2))\nprint(\"Distance under nonperiodic boundary conditions: \", nonperiodic_lattice.cartesian_periodic_distance(pt1, pt2))\n</pre> lattice_vecs = [     [1, 0],     [0, 1] ]  periodic_lattice = Lattice(lattice_vecs) nonperiodic_lattice = Lattice(lattice_vecs, periodic=False)  pt1 = (0.1, 0.5) pt2 = (0.9, 0.5)  print(\"Distance under periodic boundary conditions: \", periodic_lattice.cartesian_periodic_distance(pt1, pt2)) print(\"Distance under nonperiodic boundary conditions: \", nonperiodic_lattice.cartesian_periodic_distance(pt1, pt2)) <pre>Distance under periodic boundary conditions:  0.2\nDistance under nonperiodic boundary conditions:  0.8\n</pre> In\u00a0[18]: Copied! <pre>unscaled_lattice = Lattice(lattice_vecs)\nprint(\"Lattice vector lengths: \", unscaled_lattice.vec_lengths)\n</pre> unscaled_lattice = Lattice(lattice_vecs) print(\"Lattice vector lengths: \", unscaled_lattice.vec_lengths) <pre>Lattice vector lengths:  [1.0, 1.0]\n</pre> In\u00a0[20]: Copied! <pre>scaled_lattice = unscaled_lattice.get_scaled_lattice((2,2))\nprint(\"Scaled lattice vector lengths: \", scaled_lattice.vec_lengths)\n</pre> scaled_lattice = unscaled_lattice.get_scaled_lattice((2,2)) print(\"Scaled lattice vector lengths: \", scaled_lattice.vec_lengths) <pre>Scaled lattice vector lengths:  [2.0, 2.0]\n</pre> <p>Note that the periodization is different, and reflects the larger size of the scaled lattice:</p> In\u00a0[22]: Copied! <pre>point = (1.5, 1.5)\nprint(\"Point in unscaled lattice: \", unscaled_lattice.get_periodized_cartesian_coords(point))\nprint(\"Point in scaled lattice: \", scaled_lattice.get_periodized_cartesian_coords(point))\n</pre> point = (1.5, 1.5) print(\"Point in unscaled lattice: \", unscaled_lattice.get_periodized_cartesian_coords(point)) print(\"Point in scaled lattice: \", scaled_lattice.get_periodized_cartesian_coords(point)) <pre>Point in unscaled lattice:  [0.5 0.5]\nPoint in scaled lattice:  [1.5 1.5]\n</pre>"},{"location":"guides/constructing_lattices/#constructing-custom-lattices","title":"Constructing Custom Lattices\u00b6","text":"<p><code>pylattica</code> is used to simulate systems and models which represent some kind of lattice - i.e. a tiling of some basic shape that yields many identical sites (such as an atomic crystal structure, the square grids used in classical cellular automata, or the hexagonal grids used in lattice-gas automata). This guide illustrates how lattices of any shape and periodicity can be constructed using <code>pylattica</code>.</p>"},{"location":"guides/constructing_lattices/#defining-a-lattice","title":"Defining a lattice\u00b6","text":"<p>A lattice is defined by its lattice vectors. Its dimensionality is given by the number of vectors (which should equal their length) used to define it. Below, two lattice vectors are used to define a two-dimensional square lattice. They are the unit vectors in the two primary cartesian directions. These vectors do not have to have any particular length.</p>"},{"location":"guides/constructing_lattices/#fractional-and-cartesian-coordinates","title":"Fractional and Cartesian Coordinates\u00b6","text":"<p>Lattices provide methods for switching between cartesian and fractional coordinates, as shown below. We illustrate by using our oblique lattice.</p>"},{"location":"guides/constructing_lattices/#periodicity","title":"Periodicity\u00b6","text":"<p>In pylattica, Lattices are by default periodic in all directions, but periodicity can be specified in any subset of directions. Periodicity just means that the methods for returning periodic points will always return the point inside the unit cell, according to the periodic boundary conditions. Lets illustrate with our square 2D grid, which is periodic in all directions.</p>"},{"location":"guides/constructing_lattices/#partial-periodicity","title":"Partial Periodicity\u00b6","text":"<p>You can specify that a lattice is not periodic when instantiating the lattice:</p>"},{"location":"guides/constructing_lattices/#distances-under-periodic-boundary-conditions","title":"Distances under periodic boundary conditions\u00b6","text":"<p>Under periodic boundary conditions, distances are given as the smallest possible distance between two points, given the periodic boundary conditions. In other words, the shortest line connecting the two points may cross one of the boundaries, as opposed to spanning the interior of the lattice unit cell.</p> <p>A demonstration below shows this.</p>"},{"location":"guides/constructing_lattices/#scaling-a-lattice","title":"Scaling a Lattice\u00b6","text":"<p>Each <code>Lattice</code> object is used to determine positions inside a <code>PeriodicStructure</code>. This means that the <code>Lattice</code> should be as large as the simulation structure. When a <code>PeriodicStructure</code> is created, the lattice is scaled to the desired size. Although this is very rarely done manually, it can be done like so:</p>"},{"location":"guides/controllers_and_update_rules/","title":"Controllers and Update Rules","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n</pre> %load_ext autoreload %autoreload 2 In\u00a0[3]: Copied! <pre>from pylattica.core import BasicController, SimulationState\n\nclass ToyController(BasicController):\n    \n    def get_state_update(self, site_id: int, prev_state: SimulationState):\n        # retrieve the previous state for the site that needs to be updated\n        previous_site_state = prev_state.get_site_state(site_id)\n        old_value = previous_state.get(\"value\")\n        \n        # compute the new value\n        new_value = old_value + 1\n        \n        # return a dictionary of updates that should be applied to the state at that site\n        return {\n            \"value\": new_value\n        }\n</pre> from pylattica.core import BasicController, SimulationState  class ToyController(BasicController):          def get_state_update(self, site_id: int, prev_state: SimulationState):         # retrieve the previous state for the site that needs to be updated         previous_site_state = prev_state.get_site_state(site_id)         old_value = previous_state.get(\"value\")                  # compute the new value         new_value = old_value + 1                  # return a dictionary of updates that should be applied to the state at that site         return {             \"value\": new_value         } <p>The key observation to make here is that the update rule is implemented in a method called <code>get_state_update</code> that takes two arguments - the ID of the state whose updates should be computed and returned, and the previous state of the simulation.</p> <p>There are two salient features of this system:</p> <ol> <li><code>pylattica</code> makes no assumptions about how you will use the previous <code>SimulationState</code> to compute the updates. For example, you could ignore it or you could use it in conjunction with a <code>Neighborhood</code>.</li> <li>The return value of this function is a dictionary that represents the updates that should be applied to the state. If each site had a state dictionary with multiple keys (i.e. something in addition to <code>\"value\"</code>,), those keys would remain unchanged by this update rule.</li> </ol> In\u00a0[5]: Copied! <pre>from pylattica.core import BasicController, SimulationState\n\nclass MultiSiteUpdate(BasicController):\n    \n    def get_state_update(self, site_id: int, prev_state: SimulationState):\n        # rename the first site for readability\n        site_1_id = site_id\n        \n        # determine the other site that will be updated in conjunction with the one identified by site_id\n        site_2_id = site_id + 1\n        \n        # retrieve the two states\n        site_1_prev_state = prev_state.get_site_state(site_1_id)\n        site_1_old_val = site_1_prev_state.get(\"value\")\n        \n        site_2_prev_state = prev_state.get_site_state(site_2_id)\n        site_2_old_val = site_2_prev_state.get(\"value\")\n        \n        # compute the new value\n        new_site_1_val = site_1_old_val + 1\n        new_site_2_val = site_2_old_val - 1\n        \n        # return a dictionary of updates that should be applied to the state at that site\n        return {\n            site_1_id: {\n                \"value\": new_site_1_val\n            },\n            site_2_id: {\n                \"value\": new_site_2_val\n            }\n        }\n</pre> from pylattica.core import BasicController, SimulationState  class MultiSiteUpdate(BasicController):          def get_state_update(self, site_id: int, prev_state: SimulationState):         # rename the first site for readability         site_1_id = site_id                  # determine the other site that will be updated in conjunction with the one identified by site_id         site_2_id = site_id + 1                  # retrieve the two states         site_1_prev_state = prev_state.get_site_state(site_1_id)         site_1_old_val = site_1_prev_state.get(\"value\")                  site_2_prev_state = prev_state.get_site_state(site_2_id)         site_2_old_val = site_2_prev_state.get(\"value\")                  # compute the new value         new_site_1_val = site_1_old_val + 1         new_site_2_val = site_2_old_val - 1                  # return a dictionary of updates that should be applied to the state at that site         return {             site_1_id: {                 \"value\": new_site_1_val             },             site_2_id: {                 \"value\": new_site_2_val             }         } <p>Let's highlight the form of the return value for this controller:</p> <pre><code>{\n    site_1_id: {\n        \"value\": new_site_1_val\n    },\n    site_2_id: {\n        \"value\": new_site_2_val\n    }\n}\n</code></pre> <p>In this case, the updates dictionary being returned has a top level of keys specifying the IDs of sites to which the updates should be applied. This format lets us express that this single invocation of the update rule should yield changes to both site 1 and site 2 (given by <code>new_site_1_val</code> and <code>new_site_2_val</code>).</p> In\u00a0[7]: Copied! <pre>from pylattica.core import BasicController, SimulationState\nfrom pylattica.core.simulation_state import SITES, GENERAL\n\nclass GeneralStateController(BasicController):\n    \n    def get_state_update(self, site_id: int, prev_state: SimulationState):\n        # retrieve the previous state for the site that needs to be updated\n        previous_site_state = prev_state.get_site_state(site_id)\n        old_value = previous_state.get(\"value\")\n        \n        previous_general_value = prev_state.get_general_state().get(\"general_value\")\n        \n        # compute the new value\n        new_value = old_value + 1\n        \n        new_general_value = previous_general_value + 1\n        \n        # return a dictionary of updates that should be applied to the state at that site\n        return {\n            SITES: {\n                site_id: {\n                    \"value\": new_value\n                }\n            },\n            GENERAL: {\n                \"general_value\": new_general_value\n            }\n        }\n</pre> from pylattica.core import BasicController, SimulationState from pylattica.core.simulation_state import SITES, GENERAL  class GeneralStateController(BasicController):          def get_state_update(self, site_id: int, prev_state: SimulationState):         # retrieve the previous state for the site that needs to be updated         previous_site_state = prev_state.get_site_state(site_id)         old_value = previous_state.get(\"value\")                  previous_general_value = prev_state.get_general_state().get(\"general_value\")                  # compute the new value         new_value = old_value + 1                  new_general_value = previous_general_value + 1                  # return a dictionary of updates that should be applied to the state at that site         return {             SITES: {                 site_id: {                     \"value\": new_value                 }             },             GENERAL: {                 \"general_value\": new_general_value             }         } <p>We had to import the <code>SITES</code> and <code>GENERAL</code> constants from <code>pylattica</code> in order to specify the form of this dictionary.</p> <p>Note that the dictionary under the <code>SITES</code> key is a mapping of site IDs to state updates. If we wanted to update multiple sites in addition to the general state, we could use a return value of something like this:</p> <pre><code>{\n    SITES: {\n        site_id_1: {\n            \"value\": new_value\n        },\n        site_id_2: {\n            \"value\": new_value_2\n        }\n    },\n    GENERAL: {\n        \"general_value\": new_general_value\n    }\n}\n</code></pre>"},{"location":"guides/controllers_and_update_rules/#controllers-and-update-rules","title":"Controllers and Update Rules\u00b6","text":"<p>In <code>pylattica</code>, the rule for evolving a simulation is defined in a subclass of <code>BasicController</code> which is implemented by the user. This is an extremely lightweight class which is given to the <code>Runner</code> in order to evolve a simulation (see the Runners guide for more details on running a simulation).</p> <p>In this guide, we will illustrate the following:</p> <ul> <li>Implementing a simple update rule</li> <li>Returning updates for multiple sites</li> <li>Returning updates for the general simulation state</li> </ul>"},{"location":"guides/controllers_and_update_rules/#a-simple-example","title":"A simple example\u00b6","text":"<p>In our toy simulation, the state stored at each state will be a single integer. We will represent this state like this:</p> <pre><code>{ \"value\": 1 }\n</code></pre> <p>Where <code>\"value\"</code> is an arbitrarily chosen key for our state value, and <code>1</code> is the current integer value.</p> <p>Additionally, in this toy simulation, the value of the state at each site is incremented by 1 during each simulation step. Here's how we would use a <code>BasicController</code> subclass to implement this.</p>"},{"location":"guides/controllers_and_update_rules/#updating-multiple-site-states-at-once","title":"Updating Multiple Site States at Once\u00b6","text":"<p>Sometimes a simulation update rule will need to update the values of multiple site states during each application of the update rule (note that this will require use of the <code>AsynchronousRunner</code> - as described in the Runners guide).</p> <p>For example, you might need to implement an update rule that updates multiple sites at once to achieve conservation of some quantity in your simulation state.</p> <p>To do this, you can return a more complex form of the update dictionary, shown below.</p>"},{"location":"guides/controllers_and_update_rules/#updating-multiple-sites-and-the-general-state","title":"Updating Multiple Sites and the General State\u00b6","text":"<p>In addition to per-site state values, <code>pylattica</code> also supports accounting for an additional state dictionary that applies to the entire simulation. This is called the general state.</p> <p>NOTE: If you use the general state, you should also use the <code>AsynchronousRunner</code> to avoid applying conflicting updates to the general state at the same time.</p> <p>For example, below we implement a toy controller that increments both the site specific state, and a similar value in the general state called <code>\"general_value\"</code>.</p>"},{"location":"guides/game_of_life/","title":"Conway's Game of Life in pylattica","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n</pre> %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>from pylattica.core import SynchronousRunner, Lattice, PeriodicStructure, SimulationState\n</pre> from pylattica.core import SynchronousRunner, Lattice, PeriodicStructure, SimulationState <p>Let's start this implementation by writing out the update rule above in code. We'll do this by implementing a function that takes the old state of a cell and the states of the neighboring cells, and returns the new state. We're not using anything from <code>pylattica</code> at all right now, just translating the rules of the Game into codee.</p> In\u00a0[3]: Copied! <pre>def update_state(old_state, neighboring_states):\n    alive_neighbor_count = 0\n    dead_neighbor_count = 0\n    \n    for state in neighboring_states:\n        if state == \"alive\":\n            alive_neighbor_count += 1\n        else:\n            # since all cells are either alive or dead, nothing else\n            dead_neighbor_count += 1\n    \n    # Now, we can implement the rules in python logic:\n    if old_state == \"alive\":\n        if alive_neighbor_count &lt; 2:\n            return \"dead\"\n        elif alive_neighbor_count == 2 or alive_neighbor_count == 3:\n            return \"alive\"\n        elif alive_neighbor_count &gt; 3:\n            return \"dead\"\n    elif old_state == \"dead\":\n        if alive_neighbor_count == 3:\n            return \"alive\"\n    \n    return old_state\n</pre> def update_state(old_state, neighboring_states):     alive_neighbor_count = 0     dead_neighbor_count = 0          for state in neighboring_states:         if state == \"alive\":             alive_neighbor_count += 1         else:             # since all cells are either alive or dead, nothing else             dead_neighbor_count += 1          # Now, we can implement the rules in python logic:     if old_state == \"alive\":         if alive_neighbor_count &lt; 2:             return \"dead\"         elif alive_neighbor_count == 2 or alive_neighbor_count == 3:             return \"alive\"         elif alive_neighbor_count &gt; 3:             return \"dead\"     elif old_state == \"dead\":         if alive_neighbor_count == 3:             return \"alive\"          return old_state      <p>This is a bit verbose, but we've written it that way just to emphasize the direct mapping of logical statements here to the rules from the Wikipedia article. Let's try out some hypothetical situations:</p> In\u00a0[4]: Copied! <pre>print(\"alive cell, 2 dead, 2 alive neighbors:\")\nprint(\"result:\", update_state(\"alive\", [\"alive\", \"dead\", \"alive\", \"dead\"]))\nprint(\"\")\nprint(\"alive cell, 1 dead, 4 alive neighbors:\")\nprint(\"result:\", update_state(\"alive\", [\"alive\", \"alive\", \"alive\", \"alive\"]))\nprint(\"\")\nprint(\"dead cell, 1 dead, 3 alive neighbors:\")\nprint(\"result:\", update_state(\"dead\", [\"alive\", \"alive\", \"alive\", \"dead\"]))\n</pre> print(\"alive cell, 2 dead, 2 alive neighbors:\") print(\"result:\", update_state(\"alive\", [\"alive\", \"dead\", \"alive\", \"dead\"])) print(\"\") print(\"alive cell, 1 dead, 4 alive neighbors:\") print(\"result:\", update_state(\"alive\", [\"alive\", \"alive\", \"alive\", \"alive\"])) print(\"\") print(\"dead cell, 1 dead, 3 alive neighbors:\") print(\"result:\", update_state(\"dead\", [\"alive\", \"alive\", \"alive\", \"dead\"])) <pre>alive cell, 2 dead, 2 alive neighbors:\nresult: alive\n\nalive cell, 1 dead, 4 alive neighbors:\nresult: dead\n\ndead cell, 1 dead, 3 alive neighbors:\nresult: alive\n</pre> <p>The rule looks like it's working. Let's see how we can use pylattica to make this rule into a whole simulation.</p> <p>We know that Conway's Game of Life has cells that are either dead or alive. These cells are arranged on a 2D square grid. We refer to this grid as the lattice on which the simulation evolves. One of the core functions of <code>pylattica</code> is to make it easy to define such lattices.</p> <p>To construct our 2D square grid, we will use the <code>Lattice</code> class.</p> <p>NOTE: For detailed illustrations of the behavior of the <code>Lattice</code> class, please see the Lattice guide.</p> In\u00a0[5]: Copied! <pre>lattice = Lattice([\n    [1, 0],\n    [0, 1]\n])\n</pre> lattice = Lattice([     [1, 0],     [0, 1] ]) <p>Now that we've defined the unit cell of our lattice, we can build the structure of our simulation. This <code>Lattice</code> object defines the shape of a single square grid tile. We build a larger grid of tiles using the <code>PeriodicStructure</code> object.</p> <p>We'll place a single simulation site in the center of each of these tiles. We specify this arrangement using a \"motif\", as shown below.</p> <p>NOTE: For more detailed instructions for making <code>PeriodicStructure</code>s, please see the PeriodicStructure guide</p> <p>In this case, we are specifying a single site at each lattice point.</p> In\u00a0[50]: Copied! <pre>motif = [\n    [0, 0]\n]\n\nstructure = PeriodicStructure.build_from(lattice, (20,20), motif)\n</pre> motif = [     [0, 0] ]  structure = PeriodicStructure.build_from(lattice, (20,20), motif) <p>The lines of code above create a 10 x 10 square grid with periodic boundary conditions (see the <code>PeriodicStructure</code> guide for details on periodicity). This structure will be used to define the neighbors of each cell.</p> <p>Before we defined the neighborhood, let's set up a starting state for our simulation.</p> In\u00a0[51]: Copied! <pre>initial_state = SimulationState.from_struct(structure)\n</pre> initial_state = SimulationState.from_struct(structure) <p>This state object has entries for each of the sites in the structure. We can see this by grabbing an arbitrary site from the simulation structure.</p> In\u00a0[52]: Copied! <pre>arb_site = structure.id_at((0, 0))\n\nprint(\"State for site\", arb_site, \":\", initial_state.get_site_state(arb_site))\n</pre> arb_site = structure.id_at((0, 0))  print(\"State for site\", arb_site, \":\", initial_state.get_site_state(arb_site)) <pre>State for site 0 : {'_site_id': 0}\n</pre> <p>So far, this state is empty. There is no information contained in that dictionary that is specific to our simulation.</p> <p>In our simulation, each cell site is either \"dead\" or \"alive\". Since <code>SimulationState</code>s can contain any key value mapping, let's invent a convention for representing whether each site is alive or dead.</p> <p>The key for our state will be \"state\" and the value will be either \"alive\" or \"dead\". We can set up an initial simulation state by iterating over all the site IDs in the structure, and assigning a random dead or alive state to each of them.</p> In\u00a0[53]: Copied! <pre>import random\n\ndead = \"DEAD\"\nalive = \"ALIVE\"\nstate = \"STATE\"\n\nstate_choices = [dead, alive]\n\nfor site_id in structure.site_ids:\n    initial_state.set_site_state(site_id, {\n        state: random.choice(state_choices)\n    })\n    \nprint(\"State for site\", arb_site, \":\", initial_state.get_site_state(arb_site))\n</pre> import random  dead = \"DEAD\" alive = \"ALIVE\" state = \"STATE\"  state_choices = [dead, alive]  for site_id in structure.site_ids:     initial_state.set_site_state(site_id, {         state: random.choice(state_choices)     })      print(\"State for site\", arb_site, \":\", initial_state.get_site_state(arb_site)) <pre>State for site 0 : {'_site_id': 0, 'STATE': 'DEAD'}\n</pre> <p>That's it! Now we can do a quick visualization to see what the simulation state looks like. <code>pylattica</code> only supports visualization of square grid structures. We can use the <code>SquareGridArtist2D</code> and <code>CellArtist</code> classes for this.</p> <p>The <code>CellArtist</code> defines the color that should be shown for each cell, and the legend label for that cell, as a function of it's state. We define ours like this:</p> In\u00a0[54]: Copied! <pre>from pylattica.visualization import CellArtist\n\nclass GoLCellArtist(CellArtist):\n    \n    def get_color_from_cell_state(self, cell_state):\n        if cell_state[state] == dead:\n            return (0,100,150)\n        else:\n            return (255, 255, 150)\n    \n    def get_cell_legend_label(self, cell_state):\n        if cell_state[state] == dead:\n            return \"Dead\"\n        else:\n            return \"Alive\"\n</pre> from pylattica.visualization import CellArtist  class GoLCellArtist(CellArtist):          def get_color_from_cell_state(self, cell_state):         if cell_state[state] == dead:             return (0,100,150)         else:             return (255, 255, 150)          def get_cell_legend_label(self, cell_state):         if cell_state[state] == dead:             return \"Dead\"         else:             return \"Alive\" In\u00a0[69]: Copied! <pre>from pylattica.visualization import SquareGridArtist2D\n\ngrid_artist = SquareGridArtist2D(structure, cell_artist=GoLCellArtist())\n\ngrid_artist.jupyter_show(initial_state, cell_size=20)\n</pre> from pylattica.visualization import SquareGridArtist2D  grid_artist = SquareGridArtist2D(structure, cell_artist=GoLCellArtist())  grid_artist.jupyter_show(initial_state, cell_size=20) In\u00a0[56]: Copied! <pre>from pylattica.core.neighborhood_builders import DistanceNeighborhoodBuilder\n</pre> from pylattica.core.neighborhood_builders import DistanceNeighborhoodBuilder <p>To build a Moore Neighborhood, we will first observe that in the Moore Neighborhood, each neighbor is within 1.5 cell widths from the central cell. Using this observation, we know we can use a <code>DistanceNeighborhoodBuilder</code> for our use case. This builder makes assigns every cell neighbors which are within some specified cutoff radius.</p> <p>Here's how it works.</p> In\u00a0[57]: Copied! <pre>builder = DistanceNeighborhoodBuilder(cutoff=1.5)  \nnb_hood = builder.get(structure)\n</pre> builder = DistanceNeighborhoodBuilder(cutoff=1.5)   nb_hood = builder.get(structure) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:01&lt;00:00, 327.85it/s]\n</pre> <p>We can use the neighborhood to get the neighbors of any site, let's try the one at (5, 5).</p> In\u00a0[58]: Copied! <pre>site = structure.site_at((5,5))\nnbs = nb_hood.neighbors_of(site['_site_id'])\n</pre> site = structure.site_at((5,5)) nbs = nb_hood.neighbors_of(site['_site_id']) <p>What do we expect the locations of these neighboring sites to be?</p> In\u00a0[59]: Copied! <pre>for nb_id in nbs:\n    site = structure.get_site(nb_id)\n    print(f'Neighbor with ID {nb_id} is at {site[\"_location\"]}')\n</pre> for nb_id in nbs:     site = structure.get_site(nb_id)     print(f'Neighbor with ID {nb_id} is at {site[\"_location\"]}') <pre>Neighbor with ID 86 is at [4. 6.]\nNeighbor with ID 106 is at [5. 6.]\nNeighbor with ID 124 is at [6. 4.]\nNeighbor with ID 84 is at [4. 4.]\nNeighbor with ID 125 is at [6. 5.]\nNeighbor with ID 126 is at [6. 6.]\nNeighbor with ID 104 is at [5. 4.]\nNeighbor with ID 85 is at [4. 5.]\n</pre> <p>As expected, these eight coordinate pairs correspond to the sites above, below, right and left, and diagonal of the site at (5, 5).</p> In\u00a0[60]: Copied! <pre>from pylattica.core import BasicController, SimulationState\nfrom pylattica.discrete.state_constants import DISCRETE_OCCUPANCY\nfrom pylattica.core.simulation_state import SITES\n</pre> from pylattica.core import BasicController, SimulationState from pylattica.discrete.state_constants import DISCRETE_OCCUPANCY from pylattica.core.simulation_state import SITES <p>To accomplish this, we need to implement two methods in our controller class. The first, <code>pre_run</code> provides an opportunity to do any setup you'd like to before the simulation runs. It accepts as parameters the initial state of the simulation, and the structure underlying the state.</p> <p>All we'll do is setup a neighborhood based on the structure that we can use later.</p> <p>Second, we need to implement the <code>get_state_update</code> method. This is the fundamental piece of the controller. This method takes a site for which a new state should be calculated and the entire current simulation state. We can do any calculation we want to figure out the new state, but, armed with our neighborhood, and the update rule we implemented earlier, we have enough to create Conway's Game of Life.</p> In\u00a0[82]: Copied! <pre>def update_state(old_state, neighboring_states):\n    alive_neighbor_count = 0\n    dead_neighbor_count = 0\n    \n    for state in neighboring_states:\n        if state == alive:\n            alive_neighbor_count += 1\n        else:\n            # since all cells are either alive or dead, nothing else\n            dead_neighbor_count += 1\n    \n    # Now, we can implement the rules in python logic:\n    if old_state == alive:\n        if alive_neighbor_count &lt; 2:\n            return dead\n        elif alive_neighbor_count == 2 or alive_neighbor_count == 3:\n            return alive\n        elif alive_neighbor_count &gt; 3:\n            return dead\n    elif old_state == dead:\n        if alive_neighbor_count == 3:\n            return alive\n        else:\n            return dead\n    \n    return old_state\n\nclass GameOfLifeController(BasicController):\n    \n    def __init__(self, structure):\n        self.structure = structure\n    \n    def pre_run(self, initial_state):\n        # Before the simulation runs, we build a neighborhood based on the \n        # structure of the current simulation.\n        self.neighborhood = DistanceNeighborhoodBuilder(1.5).get(self.structure)\n    \n    def get_state_update(self, site_id, curr_state: SimulationState):\n        neighbor_site_ids = self.neighborhood.neighbors_of(site_id)\n        \n        neighbor_states = []\n        for nb_site_id in neighbor_site_ids:\n            neighbor_state = curr_state.get_site_state(nb_site_id)\n            neighbor_states.append(neighbor_state[state])\n\n        current_state = curr_state.get_site_state(site_id)[state]\n        \n        new_state = update_state(current_state, neighbor_states)\n        # print(site_id, current_state, neighbor_states, new_state)\n        updates = {\n            state: new_state\n        }\n        return updates\n</pre> def update_state(old_state, neighboring_states):     alive_neighbor_count = 0     dead_neighbor_count = 0          for state in neighboring_states:         if state == alive:             alive_neighbor_count += 1         else:             # since all cells are either alive or dead, nothing else             dead_neighbor_count += 1          # Now, we can implement the rules in python logic:     if old_state == alive:         if alive_neighbor_count &lt; 2:             return dead         elif alive_neighbor_count == 2 or alive_neighbor_count == 3:             return alive         elif alive_neighbor_count &gt; 3:             return dead     elif old_state == dead:         if alive_neighbor_count == 3:             return alive         else:             return dead          return old_state  class GameOfLifeController(BasicController):          def __init__(self, structure):         self.structure = structure          def pre_run(self, initial_state):         # Before the simulation runs, we build a neighborhood based on the          # structure of the current simulation.         self.neighborhood = DistanceNeighborhoodBuilder(1.5).get(self.structure)          def get_state_update(self, site_id, curr_state: SimulationState):         neighbor_site_ids = self.neighborhood.neighbors_of(site_id)                  neighbor_states = []         for nb_site_id in neighbor_site_ids:             neighbor_state = curr_state.get_site_state(nb_site_id)             neighbor_states.append(neighbor_state[state])          current_state = curr_state.get_site_state(site_id)[state]                  new_state = update_state(current_state, neighbor_states)         # print(site_id, current_state, neighbor_states, new_state)         updates = {             state: new_state         }         return updates              <p>Finally, we instantiate our controller and a <code>Runner</code>, and let the simulation run for a few steps.</p> In\u00a0[83]: Copied! <pre>controller = GameOfLifeController(structure)\nrunner = SynchronousRunner(parallel = True)\nresult = runner.run(initial_state, controller, 100)\n</pre> controller = GameOfLifeController(structure) runner = SynchronousRunner(parallel = True) result = runner.run(initial_state, controller, 100) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 400/400 [00:01&lt;00:00, 325.96it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:00&lt;00:00, 1013.13it/s]\n</pre> <p>Using the visualization tool we instantiated earlier, we can see the results here!</p> In\u00a0[87]: Copied! <pre>grid_artist.jupyter_show(result.get_step(10), cell_size=15)\ngrid_artist.jupyter_show(result.get_step(20), cell_size=15)\ngrid_artist.jupyter_show(result.get_step(30), cell_size=15)\n</pre> grid_artist.jupyter_show(result.get_step(10), cell_size=15) grid_artist.jupyter_show(result.get_step(20), cell_size=15) grid_artist.jupyter_show(result.get_step(30), cell_size=15) In\u00a0[88]: Copied! <pre>from pylattica.visualization import ResultArtist\nres_artist = ResultArtist(grid_artist, result)\nres_artist.to_gif(\"out.gif\", wait=0.1)\n</pre> from pylattica.visualization import ResultArtist res_artist = ResultArtist(grid_artist, result) res_artist.to_gif(\"out.gif\", wait=0.1)"},{"location":"guides/game_of_life/#conways-game-of-life-in-pylattica","title":"Conway's Game of Life in pylattica\u00b6","text":"<p>In this guide, we show how one can use the pieces provided by <code>pylattica</code> to implement Conway's Game of Life. Conway's Game of Life is a famous cellular automaton defined by mathematician John Conway. It demonstrates the way that very complex phenomena can emerge from simple local interactions, and has been studied extensively.</p> <p>In Conway's Game of Life, a 2D square grid of cells are labelled as \"alive\" or \"dead\". Then, as the simulation progresses, the cell states flip between \"dead\" and \"alive\" depending on how many living cells surround them.</p> <p>Before we begin though, take a quick look at the Wikipedia Article for the Game of Life to understand what the model is.</p> <p>In particular, note that the rules describing the game are simple:</p> <ol> <li>Any live cell with fewer than two live neighbours dies, as if by underpopulation.</li> <li>Any live cell with two or three live neighbours lives on to the next generation.</li> <li>Any live cell with more than three live neighbours dies, as if by overpopulation.</li> <li>Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.</li> </ol> <p>In this notebook, we will implement this model using <code>pylattica</code> and show some of the libarary's visualization capabilities.</p>"},{"location":"guides/game_of_life/#implementing-the-update-rule","title":"Implementing the Update Rule\u00b6","text":""},{"location":"guides/game_of_life/#setting-up-the-simulation-structure","title":"Setting Up The Simulation Structure\u00b6","text":""},{"location":"guides/game_of_life/#simulation-state","title":"Simulation State\u00b6","text":"<p>We can construct an empty simulation state using the structure we generated:</p> <p>NOTE: For more details about the <code>SimulationState</code> object, see the SimulationState guide</p>"},{"location":"guides/game_of_life/#site-neighborhoods","title":"Site Neighborhoods\u00b6","text":"<p>The final ingredient to the pylattica model is the concept of a neighborhood. A neighborhood is simply the set of other sites that are considered neighbors. There are many different neighborhood specifications that are possible including classic neighborhoods for 2D square grids like Moore Neighborhoods and Von Neumann Neighborhoods.</p> <p>You can specify neighborhoods in many different ways such as:</p> <ul> <li>All cells within a certain distance (actually Moore and Von Neumann neighborhoods both fall into this category, but with different distance cutoffs, or different distance metrics)</li> <li>All cells given by moving in a certain direction</li> <li>A random subset of surrounding cells</li> </ul> <p>As specified in the Game of Life Wikipedia article, we need a Moore neighborhood (includes the cells in each of the cardinal directions and the diagonal directions). Though <code>pylattica</code> comes with a <code>MooreNeighborhood</code> built in under the square grid module, we will build ours from scratch.</p> <p>NOTE: To learn more about <code>pylattica</code> <code>Neighborhood</code>s, take a look at the Neighborhood guide</p>"},{"location":"guides/game_of_life/#implementing-the-simulation-controller","title":"Implementing the Simulation Controller\u00b6","text":"<p>We've defined the possible states in our system, and initialized a starting point. The next step is move our update rule from before into a format the pylattica can understand. For this, we have to implement a new <code>Controller</code> class.</p>"},{"location":"guides/neighborhoods/","title":"Defining Neighborhoods","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n</pre> %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>from pylattica.core import Lattice, PeriodicStructure\nfrom pylattica.core.neighborhood_builders import DistanceNeighborhoodBuilder, AnnularNeighborhoodBuilder, MotifNeighborhoodBuilder\n</pre> from pylattica.core import Lattice, PeriodicStructure from pylattica.core.neighborhood_builders import DistanceNeighborhoodBuilder, AnnularNeighborhoodBuilder, MotifNeighborhoodBuilder In\u00a0[50]: Copied! <pre>lattice = Lattice([\n    [1, 0],\n    [0, 1]\n])\n\nmotif = [[0.5, 0.5]]\nstructure = PeriodicStructure.build_from(lattice, (5,5), motif)\n</pre> lattice = Lattice([     [1, 0],     [0, 1] ])  motif = [[0.5, 0.5]] structure = PeriodicStructure.build_from(lattice, (5,5), motif) In\u00a0[4]: Copied! <pre>builder = DistanceNeighborhoodBuilder(1.01)\nnbhood = builder.get(structure)\n</pre> builder = DistanceNeighborhoodBuilder(1.01) nbhood = builder.get(structure) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 25/25 [00:00&lt;00:00, 2868.25it/s]\n</pre> <p>The <code>nbhood</code> variable is an instance of the <code>Neighborhood</code> class. It allows you to retrieve the neighbors for a given site in the structure.</p> <p>Let's look at the central site in our structure. This site should have coordinates (2.5, 2.5). It should have 4 neighbors, one in each of the cardinal directions. We retrieve it's neighbors by passing its ID to the <code>.neighbors_of</code> method on the <code>Neighborhood</code> object. A generator is returned that allows you to iterate through the IDs of the neighboring sites.</p> In\u00a0[18]: Copied! <pre>central_site = structure.site_at((2.5, 2.5))\ncentral_id = central_site[\"_site_id\"]\nnbs = nbhood.neighbors_of(central_id)\n\nfor nb in nbs:\n    print(nb)\n</pre> central_site = structure.site_at((2.5, 2.5)) central_id = central_site[\"_site_id\"] nbs = nbhood.neighbors_of(central_id)  for nb in nbs:     print(nb) <pre>16\n8\n18\n22\n6\n14\n10\n2\n</pre> <p>We can use the structure object to get the location of these neighbors, and confirm our expectation that they are displaced from the central site by 1 unit in each of the cardinal directions.</p> In\u00a0[6]: Copied! <pre>for nb in nbs:\n    print(f\"Location of {nb}: \", structure.site_location(nb))\n</pre> for nb in nbs:     print(f\"Location of {nb}: \", structure.site_location(nb)) <pre>Location of 17:  (3.5, 2.5)\nLocation of 11:  (2.5, 1.5)\nLocation of 13:  (2.5, 3.5)\nLocation of 7:  (1.5, 2.5)\n</pre> <p>Incidentally, this is the Von Neumann neighborhood:</p> <p></p> <p>If we expand the distance cutoff to just over the square root of 2, we can get the Moore Neighborhood:</p> In\u00a0[19]: Copied! <pre>builder = DistanceNeighborhoodBuilder(1.50)\nnbhood = builder.get(structure)\n\nnbs = nbhood.neighbors_of(central_id)\n\nfor nb in nbs:\n    print(f\"Location of {nb}: \", structure.site_location(nb))\n</pre> builder = DistanceNeighborhoodBuilder(1.50) nbhood = builder.get(structure)  nbs = nbhood.neighbors_of(central_id)  for nb in nbs:     print(f\"Location of {nb}: \", structure.site_location(nb)) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 25/25 [00:00&lt;00:00, 2249.97it/s]</pre> <pre>Location of 6:  (1.5, 1.5)\nLocation of 11:  (2.5, 1.5)\nLocation of 7:  (1.5, 2.5)\nLocation of 16:  (3.5, 1.5)\nLocation of 13:  (2.5, 3.5)\nLocation of 8:  (1.5, 3.5)\nLocation of 18:  (3.5, 3.5)\nLocation of 17:  (3.5, 2.5)\n</pre> <pre>\n</pre> <p>Shown here:</p> <p></p> In\u00a0[8]: Copied! <pre>nbs = nbhood.neighbors_of(central_site[\"_site_id\"], include_weights=True)\n\nfor nb, distance in nbs:\n    print(f\"Location of {nb}: \", structure.site_location(nb), \" and distance: \", distance)\n</pre> nbs = nbhood.neighbors_of(central_site[\"_site_id\"], include_weights=True)  for nb, distance in nbs:     print(f\"Location of {nb}: \", structure.site_location(nb), \" and distance: \", distance) <pre>Location of 18:  (3.5, 3.5)  and distance:  1.414\nLocation of 16:  (3.5, 1.5)  and distance:  1.414\nLocation of 11:  (2.5, 1.5)  and distance:  1.0\nLocation of 8:  (1.5, 3.5)  and distance:  1.414\nLocation of 13:  (2.5, 3.5)  and distance:  1.0\nLocation of 6:  (1.5, 1.5)  and distance:  1.414\nLocation of 7:  (1.5, 2.5)  and distance:  1.0\nLocation of 17:  (3.5, 2.5)  and distance:  1.0\n</pre> In\u00a0[20]: Copied! <pre>builder = AnnularNeighborhoodBuilder(1.3, 2.01)\nnbhood = builder.get(structure)\n\nnbs = nbhood.neighbors_of(central_id, include_weights=True)\n\nprint(f\"This gives {len(nbs)} neighbors, as expected.\\n\")\n\nfor nb, distance in nbs:\n    print(f\"Location of {nb}: \", structure.site_location(nb), \" and distance: \", distance)\n</pre> builder = AnnularNeighborhoodBuilder(1.3, 2.01) nbhood = builder.get(structure)  nbs = nbhood.neighbors_of(central_id, include_weights=True)  print(f\"This gives {len(nbs)} neighbors, as expected.\\n\")  for nb, distance in nbs:     print(f\"Location of {nb}: \", structure.site_location(nb), \" and distance: \", distance) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 25/25 [00:00&lt;00:00, 2423.67it/s]</pre> <pre>This gives 8 neighbors, as expected.\n\nLocation of 6:  (1.5, 1.5)  and distance:  1.414\nLocation of 2:  (0.5, 2.5)  and distance:  2.0\nLocation of 14:  (2.5, 4.5)  and distance:  2.0\nLocation of 22:  (4.5, 2.5)  and distance:  2.0\nLocation of 16:  (3.5, 1.5)  and distance:  1.414\nLocation of 10:  (2.5, 0.5)  and distance:  2.0\nLocation of 18:  (3.5, 3.5)  and distance:  1.414\nLocation of 8:  (1.5, 3.5)  and distance:  1.414\n</pre> <pre>\n</pre> In\u00a0[21]: Copied! <pre>motif = [\n    (0, 2),\n    (1, 1),\n    (2, 0),\n    (1, -1),\n    (0, -2),\n    (-1, -1),\n    (-2, 0),\n    (-1, 1)\n]\n\nbuilder = MotifNeighborhoodBuilder(motif)\nnbhood = builder.get(structure)\n\nnbs = nbhood.neighbors_of(central_id, include_weights=True)\n\nassert len(nbs) == 8\nprint(f\"This gives {len(nbs)} neighbors, as expected.\\n\")\n\nfor nb, distance in nbs:\n    print(f\"Location of {nb}: \", structure.site_location(nb), \" and distance: \", distance)\n</pre> motif = [     (0, 2),     (1, 1),     (2, 0),     (1, -1),     (0, -2),     (-1, -1),     (-2, 0),     (-1, 1) ]  builder = MotifNeighborhoodBuilder(motif) nbhood = builder.get(structure)  nbs = nbhood.neighbors_of(central_id, include_weights=True)  assert len(nbs) == 8 print(f\"This gives {len(nbs)} neighbors, as expected.\\n\")  for nb, distance in nbs:     print(f\"Location of {nb}: \", structure.site_location(nb), \" and distance: \", distance) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 25/25 [00:00&lt;00:00, 9459.41it/s]</pre> <pre>This gives 8 neighbors, as expected.\n\nLocation of 22:  (4.5, 2.5)  and distance:  2.0\nLocation of 8:  (1.5, 3.5)  and distance:  1.41\nLocation of 18:  (3.5, 3.5)  and distance:  1.41\nLocation of 2:  (0.5, 2.5)  and distance:  2.0\nLocation of 16:  (3.5, 1.5)  and distance:  1.41\nLocation of 6:  (1.5, 1.5)  and distance:  1.41\nLocation of 14:  (2.5, 4.5)  and distance:  2.0\nLocation of 10:  (2.5, 0.5)  and distance:  2.0\n</pre> <pre>\n</pre> <p>See how the neighbors are the same as the ones given by the annular neighborhood?</p> In\u00a0[24]: Copied! <pre>from pylattica.core.neighborhood_builders import StochasticNeighborhoodBuilder\n</pre> from pylattica.core.neighborhood_builders import StochasticNeighborhoodBuilder <p>Say we wanted the neighbors of a given site to just be a random selection of the nearest neighbors. The way to do this is to use the <code>StochasticNeighborhood</code>. The <code>StochasticNeighborhood</code> choose randomly from a list of neighborhoods each time the neighbors are requested.</p> <p>We can define 4 motif neighborhood builders - one for each cardinal directions, and then use the <code>StochasticNeighborhoodBuilder</code> to make a neighborhood that selects randomly from among them.</p> In\u00a0[25]: Copied! <pre>motif1 = MotifNeighborhoodBuilder([(0,1)])\nmotif2 = MotifNeighborhoodBuilder([(0,-1)])\nmotif3 = MotifNeighborhoodBuilder([(1,0)])\nmotif4 = MotifNeighborhoodBuilder([(-1, 0)])\n\nstoch_nbbuilder = StochasticNeighborhoodBuilder([motif1, motif2, motif3, motif4])\nstoch_nb = stoch_nbbuilder.get(structure)\n</pre> motif1 = MotifNeighborhoodBuilder([(0,1)]) motif2 = MotifNeighborhoodBuilder([(0,-1)]) motif3 = MotifNeighborhoodBuilder([(1,0)]) motif4 = MotifNeighborhoodBuilder([(-1, 0)])  stoch_nbbuilder = StochasticNeighborhoodBuilder([motif1, motif2, motif3, motif4]) stoch_nb = stoch_nbbuilder.get(structure) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 25/25 [00:00&lt;00:00, 22598.62it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 25/25 [00:00&lt;00:00, 46561.99it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 25/25 [00:00&lt;00:00, 42956.82it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 25/25 [00:00&lt;00:00, 28934.22it/s]\n</pre> <p>We can see the effect by asking for the neighbors of the central cell several times in a row:</p> In\u00a0[28]: Copied! <pre>for _ in range(10):\n    print(\"Neighbors of central cell: \", stoch_nb.neighbors_of(central_id))\n</pre> for _ in range(10):     print(\"Neighbors of central cell: \", stoch_nb.neighbors_of(central_id)) <pre>Neighbors of central cell:  [11]\nNeighbors of central cell:  [13]\nNeighbors of central cell:  [7]\nNeighbors of central cell:  [13]\nNeighbors of central cell:  [11]\nNeighbors of central cell:  [17]\nNeighbors of central cell:  [13]\nNeighbors of central cell:  [11]\nNeighbors of central cell:  [7]\nNeighbors of central cell:  [13]\n</pre> In\u00a0[48]: Copied! <pre>from pylattica.core.neighborhood_builders import SiteClassNeighborhoodBuilder\n\nstructure_motif = {\n    \"A\": [(0.25, 0.25)],\n    \"B\": [(0.75, 0.75)],\n}\n\nclass_struct = PeriodicStructure.build_from(lattice, (3,3), structure_motif)\n\nA_nbhood = MotifNeighborhoodBuilder([(0, 1)])\nB_nbhood = MotifNeighborhoodBuilder([(1, 0)])\n\nclass_nbbuilder = SiteClassNeighborhoodBuilder({\"A\": A_nbhood, \"B\": B_nbhood})\nclass_nb = class_nbbuilder.get(class_struct)\n</pre> from pylattica.core.neighborhood_builders import SiteClassNeighborhoodBuilder  structure_motif = {     \"A\": [(0.25, 0.25)],     \"B\": [(0.75, 0.75)], }  class_struct = PeriodicStructure.build_from(lattice, (3,3), structure_motif)  A_nbhood = MotifNeighborhoodBuilder([(0, 1)]) B_nbhood = MotifNeighborhoodBuilder([(1, 0)])  class_nbbuilder = SiteClassNeighborhoodBuilder({\"A\": A_nbhood, \"B\": B_nbhood}) class_nb = class_nbbuilder.get(class_struct) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 9/9 [00:00&lt;00:00, 35444.82it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 9/9 [00:00&lt;00:00, 41665.27it/s]\n</pre> <p>Having built this neighborhood, we can inspect the neighbors of an A site and the neighbors of a B site.</p> In\u00a0[49]: Copied! <pre>a_site_id = class_struct.id_at((0.25, 0.25))\nb_site_id = class_struct.id_at((1.75, 1.75))\n\na_neighbs = class_nb.neighbors_of(a_site_id)\nprint(\"A's location:\", class_struct.site_location(a_site_id), \"and A neighbors:\", a_neighbs, \"and it's location\", class_struct.site_location(a_neighbs[0]))\n\nb_neighbs = class_nb.neighbors_of(b_site_id)\nprint(\"B's location:\", class_struct.site_location(b_site_id), \"and B neighbors:\", b_neighbs, \"and it's location\", class_struct.site_location(b_neighbs[0]))\n</pre> a_site_id = class_struct.id_at((0.25, 0.25)) b_site_id = class_struct.id_at((1.75, 1.75))  a_neighbs = class_nb.neighbors_of(a_site_id) print(\"A's location:\", class_struct.site_location(a_site_id), \"and A neighbors:\", a_neighbs, \"and it's location\", class_struct.site_location(a_neighbs[0]))  b_neighbs = class_nb.neighbors_of(b_site_id) print(\"B's location:\", class_struct.site_location(b_site_id), \"and B neighbors:\", b_neighbs, \"and it's location\", class_struct.site_location(b_neighbs[0])) <pre>A's location: (0.25, 0.25) and A neighbors: [2] and it's location (0.25, 1.25)\nB's location: (1.75, 1.75) and B neighbors: [15] and it's location (2.75, 1.75)\n</pre> In\u00a0[77]: Copied! <pre>lattice_vecs = [\n    [1, 0],\n    [0, 1]\n]\n\nmotif = [[0.5, 0.5]]\n\nvon_neumann_nb_builder = DistanceNeighborhoodBuilder(1.01)\n\nfull_periodic_lattice = Lattice(lattice_vecs, True)\nfull_periodic_struct = PeriodicStructure.build_from(full_periodic_lattice, (3,3), motif)\nfull_periodic_nbhood = von_neumann_nb_builder.get(full_periodic_struct)\n\npartial_periodic_lattice = Lattice(lattice_vecs, (False, True))\npartial_periodic_struct = PeriodicStructure.build_from(partial_periodic_lattice, (3,3), motif)\npartial_periodic_nbhood = von_neumann_nb_builder.get(partial_periodic_struct)\n\nnon_periodic_lattice = Lattice(lattice_vecs, False)\nnon_periodic_struct = PeriodicStructure.build_from(non_periodic_lattice, (3,3), motif)\nnon_periodic_nbhood = von_neumann_nb_builder.get(non_periodic_struct)\n</pre> lattice_vecs = [     [1, 0],     [0, 1] ]  motif = [[0.5, 0.5]]  von_neumann_nb_builder = DistanceNeighborhoodBuilder(1.01)  full_periodic_lattice = Lattice(lattice_vecs, True) full_periodic_struct = PeriodicStructure.build_from(full_periodic_lattice, (3,3), motif) full_periodic_nbhood = von_neumann_nb_builder.get(full_periodic_struct)  partial_periodic_lattice = Lattice(lattice_vecs, (False, True)) partial_periodic_struct = PeriodicStructure.build_from(partial_periodic_lattice, (3,3), motif) partial_periodic_nbhood = von_neumann_nb_builder.get(partial_periodic_struct)  non_periodic_lattice = Lattice(lattice_vecs, False) non_periodic_struct = PeriodicStructure.build_from(non_periodic_lattice, (3,3), motif) non_periodic_nbhood = von_neumann_nb_builder.get(non_periodic_struct) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 9/9 [00:00&lt;00:00, 4706.82it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 9/9 [00:00&lt;00:00, 4641.43it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 9/9 [00:00&lt;00:00, 5596.55it/s]\n</pre> <p>We will illustrate the behavior of this system by looking at corner and edge sites.</p> In\u00a0[78]: Copied! <pre>edge_coords = (0.5, 1.5)\ncorner_coords = (0.5, 2.5)\n\nedge_id = full_periodic_struct.id_at(edge_coords)\nedge_nbs = full_periodic_nbhood.neighbors_of(edge_id)\n\nprint(f\"The edge site {edge_coords} has\", len(edge_nbs), \"neighbors in the fully periodic system\")\nprint(\"Their coordinates are:\", [full_periodic_struct.site_location(nb_id) for nb_id in edge_nbs])\n\ncorner_id = full_periodic_struct.id_at(corner_coords)\ncorner_nbs = full_periodic_nbhood.neighbors_of(corner_id)\nprint()\nprint(f\"The corner {corner_coords} site has\", len(corner_nbs), \"neighbors in the fully periodic system\")\nprint(\"Their coordinates are:\", [full_periodic_struct.site_location(nb_id) for nb_id in corner_nbs])\n</pre> edge_coords = (0.5, 1.5) corner_coords = (0.5, 2.5)  edge_id = full_periodic_struct.id_at(edge_coords) edge_nbs = full_periodic_nbhood.neighbors_of(edge_id)  print(f\"The edge site {edge_coords} has\", len(edge_nbs), \"neighbors in the fully periodic system\") print(\"Their coordinates are:\", [full_periodic_struct.site_location(nb_id) for nb_id in edge_nbs])  corner_id = full_periodic_struct.id_at(corner_coords) corner_nbs = full_periodic_nbhood.neighbors_of(corner_id) print() print(f\"The corner {corner_coords} site has\", len(corner_nbs), \"neighbors in the fully periodic system\") print(\"Their coordinates are:\", [full_periodic_struct.site_location(nb_id) for nb_id in corner_nbs]) <pre>The edge site (0.5, 1.5) has 4 neighbors in the fully periodic system\nTheir coordinates are: [(2.5, 1.5), (1.5, 1.5), (0.5, 2.5), (0.5, 0.5)]\n\nThe corner (0.5, 2.5) site has 4 neighbors in the fully periodic system\nTheir coordinates are: [(0.5, 0.5), (1.5, 2.5), (0.5, 1.5), (2.5, 2.5)]\n</pre> In\u00a0[79]: Copied! <pre>edge_id = partial_periodic_struct.id_at(edge_coords)\nedge_nbs = partial_periodic_nbhood.neighbors_of(edge_id)\n\nprint(f\"The edge site {edge_coords} has\", len(edge_nbs), \"neighbors in the partially periodic system\")\nprint(\"Their coordinates are:\", [partial_periodic_struct.site_location(nb_id) for nb_id in edge_nbs])\n\ncorner_id = partial_periodic_struct.id_at(corner_coords)\ncorner_nbs = partial_periodic_nbhood.neighbors_of(corner_id)\nprint()\nprint(f\"The corner {corner_coords} site has\", len(corner_nbs), \"neighbors in the partially periodic system\")\nprint(\"Their coordinates are:\", [partial_periodic_struct.site_location(nb_id) for nb_id in corner_nbs])\n</pre> edge_id = partial_periodic_struct.id_at(edge_coords) edge_nbs = partial_periodic_nbhood.neighbors_of(edge_id)  print(f\"The edge site {edge_coords} has\", len(edge_nbs), \"neighbors in the partially periodic system\") print(\"Their coordinates are:\", [partial_periodic_struct.site_location(nb_id) for nb_id in edge_nbs])  corner_id = partial_periodic_struct.id_at(corner_coords) corner_nbs = partial_periodic_nbhood.neighbors_of(corner_id) print() print(f\"The corner {corner_coords} site has\", len(corner_nbs), \"neighbors in the partially periodic system\") print(\"Their coordinates are:\", [partial_periodic_struct.site_location(nb_id) for nb_id in corner_nbs]) <pre>The edge site (0.5, 1.5) has 3 neighbors in the partially periodic system\nTheir coordinates are: [(0.5, 2.5), (0.5, 0.5), (1.5, 1.5)]\n\nThe corner (0.5, 2.5) site has 3 neighbors in the partially periodic system\nTheir coordinates are: [(1.5, 2.5), (0.5, 0.5), (0.5, 1.5)]\n</pre> In\u00a0[81]: Copied! <pre>edge_id = non_periodic_struct.id_at(edge_coords)\nedge_nbs = non_periodic_nbhood.neighbors_of(edge_id)\n\nprint(f\"The edge site {edge_coords} has\", len(edge_nbs), \"neighbors in the non-periodic system\")\nprint(\"Their coordinates are:\", [non_periodic_struct.site_location(nb_id) for nb_id in edge_nbs])\n\ncorner_id = non_periodic_struct.id_at(corner_coords)\ncorner_nbs = non_periodic_nbhood.neighbors_of(corner_id)\nprint()\nprint(f\"The corner {corner_coords} site has\", len(corner_nbs), \"neighbors in the non-periodic system\")\nprint(\"Their coordinates are:\", [non_periodic_struct.site_location(nb_id) for nb_id in corner_nbs])\n</pre> edge_id = non_periodic_struct.id_at(edge_coords) edge_nbs = non_periodic_nbhood.neighbors_of(edge_id)  print(f\"The edge site {edge_coords} has\", len(edge_nbs), \"neighbors in the non-periodic system\") print(\"Their coordinates are:\", [non_periodic_struct.site_location(nb_id) for nb_id in edge_nbs])  corner_id = non_periodic_struct.id_at(corner_coords) corner_nbs = non_periodic_nbhood.neighbors_of(corner_id) print() print(f\"The corner {corner_coords} site has\", len(corner_nbs), \"neighbors in the non-periodic system\") print(\"Their coordinates are:\", [non_periodic_struct.site_location(nb_id) for nb_id in corner_nbs]) <pre>The edge site (0.5, 1.5) has 3 neighbors in the non-periodic system\nTheir coordinates are: [(0.5, 2.5), (1.5, 1.5), (0.5, 0.5)]\n\nThe corner (0.5, 2.5) site has 2 neighbors in the non-periodic system\nTheir coordinates are: [(0.5, 1.5), (1.5, 2.5)]\n</pre>"},{"location":"guides/neighborhoods/#defining-neighborhoods","title":"Defining Neighborhoods\u00b6","text":"<p>pylattica provides several methods for defining the neighborhood of each site in the simulation. Neighborhoods are built using a <code>PeriodicStructure</code> object, so it is assumed that you have defined your structure beforehand when creating a neighborhood.</p> <p>We will illustrate the use of some common neighborhood types here, using the 5x5 2D square grid as an example.</p>"},{"location":"guides/neighborhoods/#distance-neighborhoods","title":"Distance Neighborhoods\u00b6","text":"<p>An extremely common way of defining neighbors is using a distance cutoff. The <code>DistanceNeighborhoodBuilder</code> allows you to build a neighborhood that consists of each site within some cutoff radius of the site under consideration.</p> <p>In our case of a square grid, we can illustrate this by building a neighborhood with a distance cutoff of 1.01. This will contain the 4 closest sites, but no others.</p>"},{"location":"guides/neighborhoods/#iterating-through-sites-and-distances","title":"Iterating through sites and distances\u00b6","text":"<p><code>Neighborhood</code>s also allow you to read the distance between sites as you iterate through the neighbors by including the <code>include_weights=True</code> parameter to the <code>neighbors_of</code> method:</p>"},{"location":"guides/neighborhoods/#building-complex-neighborhoods","title":"Building complex neighborhoods\u00b6","text":"<p>Other simulations might call for other types of neighborhoods that are not given by a simple distance cutoff. Consider the following shape:</p> <p></p> <p>This neighborhood requires more information. This shape could be achieved by two of the built-in neighborhood types in pylattica.</p>"},{"location":"guides/neighborhoods/#using-the-annular-neighborhood","title":"Using the Annular Neighborhood\u00b6","text":"<p>The first option is to use the <code>AnnularNeighborhoodBuilder</code>. This NB builder is similar to the <code>DistanceNeighborhoodBuilder</code> but instead of taking a single distance cutoff, it takes both a minimum and maximum distance.</p>"},{"location":"guides/neighborhoods/#using-the-motif-neighborhood","title":"Using the Motif Neighborhood\u00b6","text":"<p>The most flexible neighborhood builder provided by pylattica is the <code>MotifNeighborhoodBuilder</code>. This NB builder uses a list of displacement vectors that specify the relative positions of the neighbors of each site.</p> <p>To specify the desired neighborhood above, we can use the following motif.</p>"},{"location":"guides/neighborhoods/#multi-neighborhoods","title":"Multi Neighborhoods\u00b6","text":"<p>Though what we have covered so far will enable most use cases, there is another type of helper neighborhood that pylattica provides. In some cases, the neighborhood for a given site should be different depending on some condition. It could also be random. The following sections describe these two cases.</p>"},{"location":"guides/neighborhoods/#stochastic-neighborhoods","title":"Stochastic Neighborhoods\u00b6","text":""},{"location":"guides/neighborhoods/#class-based-neighborhoods","title":"Class Based Neighborhoods\u00b6","text":"<p>We can also define neighborhoods where each site has a neighborhood specific to its class. We do this by mapping class names to neighborhood builders and using the <code>SiteClassNeighborhoodBuilder</code></p>"},{"location":"guides/neighborhoods/#periodic-boundary-conditions-and-neighborhoods","title":"Periodic Boundary Conditions and Neighborhoods\u00b6","text":"<p>Neighborhoods adhere to periodic boundary conditions as well. Below, we will illustrate this using a Von Neumann neighborhood.</p>"},{"location":"guides/neighborhoods/#full-periodicity","title":"Full Periodicity\u00b6","text":"<p>We expect the neighborhoods of edge and corner sites in the fully periodic system to look like this:</p> <p> </p> <p>To see that, lets get references to the edge site (coordinates [0.5, 1.5]) and the corner site (coordinates [0.5, 2.5]) and look at the number of their neighbors and the coordinates of their neighbors.</p>"},{"location":"guides/neighborhoods/#partial-periodicity","title":"Partial Periodicity\u00b6","text":"<p>In the partial periodic example, we expect these neighborhoods to look like this:</p> <p> </p> <p>Note that the neighborhood has not \"rolled over\" into the right side of the simulation box. Let's see the code for this.</p>"},{"location":"guides/neighborhoods/#non-periodic-system","title":"Non-periodic System\u00b6","text":"<p>In the system without any periodicity, we expect neighborhoods for these sites to look like so:</p> <p> </p> <p>Note that now the neighborhood does not roll over in either direction.</p>"},{"location":"guides/periodic_structures/","title":"Periodic Structures","text":"In\u00a0[10]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n</pre> %load_ext autoreload %autoreload 2 <pre>The autoreload extension is already loaded. To reload it, use:\n  %reload_ext autoreload\n</pre> In\u00a0[11]: Copied! <pre>from pylattica.core import PeriodicStructure, Lattice\n</pre> from pylattica.core import PeriodicStructure, Lattice In\u00a0[12]: Copied! <pre>lattice_vecs = [\n    [1, 0],\n    [0, 1]\n]\n\nlattice = Lattice(lattice_vecs)\n</pre> lattice_vecs = [     [1, 0],     [0, 1] ]  lattice = Lattice(lattice_vecs) <p>This lattice defines a unit cell for a two-dimensional square grid. We will need to define a motif in order to put sites in the structure. The motif specifies the location of sites in each unit cell. The simplest type of motif is given as a list of positions.</p> In\u00a0[15]: Copied! <pre>motif = [\n    [0.5, 0.75],\n    [0.5, 0.25]\n]\n</pre> motif = [     [0.5, 0.75],     [0.5, 0.25] ] <p>This motif is a list of coordinate pairs. Each item in the list specifies the position of a site in the unit cell. Let's build a structure from this motif.</p> In\u00a0[18]: Copied! <pre>structure = PeriodicStructure.build_from(\n    lattice,\n    num_cells=((3,3)),\n    site_motif=motif\n)\n</pre> structure = PeriodicStructure.build_from(     lattice,     num_cells=((3,3)),     site_motif=motif ) <p>This code creates a structure from the lattice and motif we defined by tiling the unit cell three times along each of the lattice vectors. As a result, we expect our structure to be a 3 by 3 cell square grid. We can see this by investigating the way the structure transforms coordinates, and by retrieving sites from the structure.</p> <p>The <code>num_cells</code> parameter specifies the extent of the structure along the directions of the lattice vectors. In this case, (3,3) indicates tiling the original lattice by three units in each direction.</p> <p>A new lattice has been created to support this structure. It's larger than the original one we used by a factor of 3 in each dimension.</p> In\u00a0[19]: Copied! <pre>structure.lattice.vecs\n</pre> structure.lattice.vecs Out[19]: <pre>array([[3, 0],\n       [0, 3]])</pre> <p>Note that because of the larger extent of this lattice, coordinates that would have fallen outside the original lattice now fall inside of this one:</p> In\u00a0[22]: Copied! <pre>coords = (1.5, 1.5)\nprint(\"Original periodized (1.5, 1.5): \", lattice.get_periodized_cartesian_coords(coords))\nprint(\"New periodized (1.5, 1.5): \", structure.lattice.get_periodized_cartesian_coords(coords))\n</pre> coords = (1.5, 1.5) print(\"Original periodized (1.5, 1.5): \", lattice.get_periodized_cartesian_coords(coords)) print(\"New periodized (1.5, 1.5): \", structure.lattice.get_periodized_cartesian_coords(coords)) <pre>Original periodized (1.5, 1.5):  [0.5 0.5]\nNew periodized (1.5, 1.5):  [1.5 1.5]\n</pre> <p>Now let's look at the structure itself. Our motif specified that there are two sites in each unit cell, so we expect 18 sites in the structure we generated (2 sites/cell * 9 cells = 18 sites).</p> In\u00a0[24]: Copied! <pre>print(\"Number of sites in structure: \", len(structure.sites()))\n</pre> print(\"Number of sites in structure: \", len(structure.sites())) <pre>Number of sites in structure:  18\n</pre> <p>Each site in the structure has three attributes:</p> <ul> <li>a location</li> <li>an ID</li> <li>a class</li> </ul> <p>You can refer to specific sites in the structure by either their location or their ID. The IDs are positive integers. Let's look at an example site. We know from our motif that there should be a site at [0.5, 0.75] (we can also expect sites at [1.5, 0.75], [1.5,1.75], etc).</p> In\u00a0[27]: Copied! <pre>site_location = (0.5, 0.75)\nsite = structure.site_at(site_location)\nprint(site)\n</pre> site_location = (0.5, 0.75) site = structure.site_at(site_location) print(site) <pre>{'_site_class': 'A', '_location': (0.5, 0.75), '_site_id': 0}\n</pre> <p>You can see the location of this site, and it's ID (0) in this dictionary. We'll discuss the <code>_site_class</code> attribute in a moment.</p> <p>Note that because this structure is periodic in all three dimensions, we can retrieve that same site by refering to a periodic image of it:</p> In\u00a0[28]: Copied! <pre>periodic_img_loc = (3.5, 3.75)\nsame_site = structure.site_at(periodic_img_loc)\nprint(same_site)\n</pre> periodic_img_loc = (3.5, 3.75) same_site = structure.site_at(periodic_img_loc) print(same_site) <pre>{'_site_class': 'A', '_location': (0.5, 0.75), '_site_id': 0}\n</pre> <p>As you can see, the site returned at those coordinates has the same ID (and is in fact the same site) as the one returned before.</p> <p>We can also retrieve sites by their ID:</p> In\u00a0[29]: Copied! <pre>site_by_id = structure.get_site(0)\nprint(site_by_id)\n</pre> site_by_id = structure.get_site(0) print(site_by_id) <pre>{'_site_class': 'A', '_location': (0.5, 0.75), '_site_id': 0}\n</pre> In\u00a0[32]: Copied! <pre>class_motif = {\n    \"A\": [\n        (0.5, 0.25)\n    ],\n    \"B\": [\n        (0.5, 0.75)\n    ]\n}\n</pre> class_motif = {     \"A\": [         (0.5, 0.25)     ],     \"B\": [         (0.5, 0.75)     ] } <p>In this new motif, the keys of the dictionary are the site classes, and the values are the lists of positions where sites with each class belong. Let's make a new structure using the same lattice as before, but this motif.</p> In\u00a0[33]: Copied! <pre>multi_class_struct = PeriodicStructure.build_from(\n    lattice,\n    num_cells=(3,3),\n    site_motif=class_motif\n)\n</pre> multi_class_struct = PeriodicStructure.build_from(     lattice,     num_cells=(3,3),     site_motif=class_motif ) <p>This structure has sites in all the same locations as the one we built before, but now half of them have class A and the other have class B.</p> In\u00a0[39]: Copied! <pre>print(\"Total number of sites: \", len(multi_class_struct.site_ids))\nprint(\"Number of A sites: \", len(multi_class_struct.sites(site_class=\"A\")))\nprint(\"Number of B sites: \", len(multi_class_struct.sites(site_class=\"B\")))\n</pre> print(\"Total number of sites: \", len(multi_class_struct.site_ids)) print(\"Number of A sites: \", len(multi_class_struct.sites(site_class=\"A\"))) print(\"Number of B sites: \", len(multi_class_struct.sites(site_class=\"B\"))) <pre>Total number of sites:  18\nNumber of A sites:  9\nNumber of B sites:  9\n</pre> <p>We can also see that sites with class A and B are in the locations we would expect.</p> In\u00a0[44]: Copied! <pre>print(\"We expect site A here: \", multi_class_struct.site_at((0.5, 0.25)))\nprint(\"And here: \", multi_class_struct.site_at((1.5, 0.25)))\nprint(\"And we expect site B here: \", multi_class_struct.site_at((0.5, 0.75)))\nprint(\"And here: \", multi_class_struct.site_at((0.5, 1.75)))\n</pre> print(\"We expect site A here: \", multi_class_struct.site_at((0.5, 0.25))) print(\"And here: \", multi_class_struct.site_at((1.5, 0.25))) print(\"And we expect site B here: \", multi_class_struct.site_at((0.5, 0.75))) print(\"And here: \", multi_class_struct.site_at((0.5, 1.75))) <pre>We expect site A here:  {'_site_class': 'A', '_location': (0.5, 0.25), '_site_id': 0}\nAnd here:  {'_site_class': 'A', '_location': (1.5, 0.25), '_site_id': 6}\nAnd we expect site B here:  {'_site_class': 'B', '_location': (0.5, 0.75), '_site_id': 1}\nAnd here:  {'_site_class': 'B', '_location': (0.5, 1.75), '_site_id': 3}\n</pre>"},{"location":"guides/periodic_structures/#periodic-structures","title":"Periodic Structures\u00b6","text":"<p>Although assigning geometric locations to the sites in your simulation is not strictly necessary, lattice simulations are defined in part by the geometry of the sites (the namesake lattice). In <code>pylattica</code>, these locations are given instances of the <code>PeriodicStructure</code> class. Though the name suggests that these structures are periodic, this is not a requirement. The periodicity of the structure is given by the periodicity of the <code>Lattice</code> it is built on (see the <code>Constructing Lattices</code> guide for more details).</p> <p>In this guide, we will illustrate the behavior of <code>PeriodicStructure</code>s by building two and three dimensional square grid structures.</p>"},{"location":"guides/periodic_structures/#defining-a-structure-using-a-lattice-and-a-motif","title":"Defining a Structure using a Lattice and a Motif\u00b6","text":"<p>A <code>PeriodicStructure</code> is defined by a <code>Lattice</code> object, and a motif. The <code>Lattice</code> defines the shape, dimensionality, and periodicity of the bounding box of the simulation (see <code>Constructing Lattices</code> for details), and the motif defines the position of simulation sites within that bounding box. In the parlance of materials science and chemistry, the <code>Lattice</code> gives a unit cell, and the motif defines the atomic basis.</p> <p>We will use a two dimensional square grid lattice for this demonstration:</p>"},{"location":"guides/periodic_structures/#site-classes","title":"Site Classes\u00b6","text":"<p>As you saw above, each site also has a <code>_site_class</code> attribute assigned to it. This attribute is used to distinguish types of sites that might exist in your structure. For instance, in crystallography, we frequently refer to sites by their coordination environment (e.g. octahedral or tetrahedral). Further, in surface catalysis, sites are distinguished by well known names: bridge, hollow, on-top. If this type of distinction is important to your simulation, it can be expressed using this attribute.</p> <p>If you specify a motif using a list of positions, like we did before, every site will have the same <code>_site_class</code> value, and will be of little use.</p> <p>If you want to distinguish between sites in your structure by class, we can use a more complex form of motif to achieve this, as shown below.</p>"},{"location":"guides/runners/","title":"Runners","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n</pre> %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>from pylattica.structures.square_grid import SimpleSquare2DStructureBuilder\n\nstructure = SimpleSquare2DStructureBuilder().build(10)\n</pre> from pylattica.structures.square_grid import SimpleSquare2DStructureBuilder  structure = SimpleSquare2DStructureBuilder().build(10) <p>Let's also set up a Von Neumann neighborhood to use here (also using a <code>pylattica</code> helper).</p> In\u00a0[3]: Copied! <pre>from pylattica.structures.square_grid.neighborhoods import VonNeumannNbHood2DBuilder\n\nnbhood = VonNeumannNbHood2DBuilder().get(structure)\n</pre> from pylattica.structures.square_grid.neighborhoods import VonNeumannNbHood2DBuilder  nbhood = VonNeumannNbHood2DBuilder().get(structure) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:00&lt;00:00, 18416.26it/s]\n</pre> <p>And finally, let's agree on a simulation state where the state at each cell looks like this:</p> <pre><code>{\n    \"value\": %some integer value%\n}\n</code></pre> <p>Let's also agree that the values will fall within the range 1 - 10.</p> <p>With that, we can construct a starting state for our simulation.</p> In\u00a0[4]: Copied! <pre>from pylattica.core import SimulationState\n\nstarting_state = SimulationState.from_struct(structure)\n</pre> from pylattica.core import SimulationState  starting_state = SimulationState.from_struct(structure) <p>And assign random values between 1 and 10 to each site in the structure. I'm putting this in a function so we can reuse it later in the guide.</p> In\u00a0[5]: Copied! <pre>import random\n\ndef set_random_state(state):\n    for site_id in structure.site_ids:\n        state.set_site_state(site_id, {\n            \"value\": random.randint(1,10)\n        })\n\nset_random_state(starting_state)\n</pre> import random  def set_random_state(state):     for site_id in structure.site_ids:         state.set_site_state(site_id, {             \"value\": random.randint(1,10)         })  set_random_state(starting_state) <p>We can visualize this state by creating a color scale corresponding to the sites 1 through 10:</p> In\u00a0[6]: Copied! <pre>from pylattica.visualization import SquareGridArtist2D, DiscreteCellArtist\n\ncolor_scale = {}\n\nfor i in range(1,11):\n    color_scale[i] = (30, int((i - 1) * 255/10), 30)\n    \ncell_artist = DiscreteCellArtist(color_map = color_scale, state_key=\"value\")\nstep_artist = SquareGridArtist2D(structure, cell_artist)\n\nstep_artist.jupyter_show(starting_state, cell_size=20)\n</pre> from pylattica.visualization import SquareGridArtist2D, DiscreteCellArtist  color_scale = {}  for i in range(1,11):     color_scale[i] = (30, int((i - 1) * 255/10), 30)      cell_artist = DiscreteCellArtist(color_map = color_scale, state_key=\"value\") step_artist = SquareGridArtist2D(structure, cell_artist)  step_artist.jupyter_show(starting_state, cell_size=20) In\u00a0[7]: Copied! <pre>from pylattica.core import BasicController\n\nclass SyncController(BasicController):\n    \n    def get_state_update(self, site_id: int, prev_state: SimulationState):\n        prev_site_val = prev_state.get_site_state(site_id).get(\"value\")\n        if prev_site_val &lt; 10:\n            new_site_val = prev_site_val + 1\n        else:\n            new_site_val = prev_site_val\n            \n        return {\n            \"value\": new_site_val\n        }\n</pre> from pylattica.core import BasicController  class SyncController(BasicController):          def get_state_update(self, site_id: int, prev_state: SimulationState):         prev_site_val = prev_state.get_site_state(site_id).get(\"value\")         if prev_site_val &lt; 10:             new_site_val = prev_site_val + 1         else:             new_site_val = prev_site_val                      return {             \"value\": new_site_val         } <p>And now we can instantiate a <code>SynchronousRunner</code> and run our simulation for 10 steps.</p> <p>NOTE: Since every site is updated during each step, we expect every site to have a value of 10 by the end.</p> <p>Let's generate a new starting state and look at it so we know where we are starting from?</p> In\u00a0[8]: Copied! <pre>sync_starting_state = SimulationState.from_struct(structure)\nset_random_state(sync_starting_state)\n\nstep_artist.jupyter_show(starting_state, cell_size=20)\n</pre> sync_starting_state = SimulationState.from_struct(structure) set_random_state(sync_starting_state)  step_artist.jupyter_show(starting_state, cell_size=20) <p>And now let's run for 10 steps:</p> In\u00a0[9]: Copied! <pre>from pylattica.core.runner import SynchronousRunner\n\nsync_runner = SynchronousRunner()\nsync_cont = SyncController()\nnum_steps = 10\n\nsync_result = sync_runner.run(starting_state, sync_cont, num_steps)\n</pre> from pylattica.core.runner import SynchronousRunner  sync_runner = SynchronousRunner() sync_cont = SyncController() num_steps = 10  sync_result = sync_runner.run(starting_state, sync_cont, num_steps) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10 [00:00&lt;00:00, 9754.20it/s]\n</pre> <p>Finally, we can visualize the last step of this simulation:</p> In\u00a0[10]: Copied! <pre>step_artist.jupyter_show(sync_result.last_step)\n</pre> step_artist.jupyter_show(sync_result.last_step) <p>As expected, every cell has been incremented to 10.</p> <p>We can also look at an intermediate step in the result:</p> In\u00a0[11]: Copied! <pre>step_artist.jupyter_show(sync_result.get_step(5))\n</pre> step_artist.jupyter_show(sync_result.get_step(5)) <p>As we expect, there are no cell states below 5 since every cell has been updated at least 5 times by this point.</p> In\u00a0[26]: Copied! <pre>class AsyncController(BasicController):\n    \n    def get_state_update(self, site_id: int, prev_state: SimulationState):\n        prev_site_val = prev_state.get_site_state(site_id).get(\"value\")\n        \n        neighbors = nbhood.neighbors_of(site_id)\n        rand_nb_id = random.choice(neighbors)\n        \n        prev_nb_val = prev_state.get_site_state(rand_nb_id).get(\"value\")\n        \n        direction = random.choice([-1, 1])\n        new_site_val = prev_site_val + direction\n        new_nb_val = prev_nb_val - direction\n        \n        return {\n            site_id: {\n                \"value\": new_site_val\n            },\n            rand_nb_id: {\n                \"value\": new_nb_val\n            }   \n        }\n</pre> class AsyncController(BasicController):          def get_state_update(self, site_id: int, prev_state: SimulationState):         prev_site_val = prev_state.get_site_state(site_id).get(\"value\")                  neighbors = nbhood.neighbors_of(site_id)         rand_nb_id = random.choice(neighbors)                  prev_nb_val = prev_state.get_site_state(rand_nb_id).get(\"value\")                  direction = random.choice([-1, 1])         new_site_val = prev_site_val + direction         new_nb_val = prev_nb_val - direction                  return {             site_id: {                 \"value\": new_site_val             },             rand_nb_id: {                 \"value\": new_nb_val             }            } <p>We also need a new color scale for this. Here's a color scale where the intensity of the green is related to the absolute value of the cell's state.</p> In\u00a0[27]: Copied! <pre>import math\n\ncolor_scale = {}\n\nb = 30\n\nfor i in range(-b, b + 1):\n    color_scale[i] = (30, int(math.fabs(i - 1) * 255/(b)), 30)\n    \nlegend = {}\n\nfor i in range(-b, b + 1, int((b+b)/ 10)):\n    legend[str(i)] = color_scale[i]\n\ncell_artist = DiscreteCellArtist(color_map = color_scale, state_key=\"value\", legend = legend)\nstep_artist = SquareGridArtist2D(structure, cell_artist)\n</pre> import math  color_scale = {}  b = 30  for i in range(-b, b + 1):     color_scale[i] = (30, int(math.fabs(i - 1) * 255/(b)), 30)      legend = {}  for i in range(-b, b + 1, int((b+b)/ 10)):     legend[str(i)] = color_scale[i]  cell_artist = DiscreteCellArtist(color_map = color_scale, state_key=\"value\", legend = legend) step_artist = SquareGridArtist2D(structure, cell_artist) <p>Additionally, let's create a starting state where every cell value is 0.</p> In\u00a0[28]: Copied! <pre>async_starting_state = SimulationState.from_struct(structure)\n\nfor site_id in structure.site_ids:\n    async_starting_state.set_site_state(site_id, { \"value\": 0 })\n</pre> async_starting_state = SimulationState.from_struct(structure)  for site_id in structure.site_ids:     async_starting_state.set_site_state(site_id, { \"value\": 0 }) <p>We can see by visualization that every site has a value of 0:</p> In\u00a0[29]: Copied! <pre>step_artist.jupyter_show(async_starting_state, cell_size=20)\n</pre> step_artist.jupyter_show(async_starting_state, cell_size=20) <p>But we can also make a helper function that adds the state values up to see that the total is 0:</p> In\u00a0[30]: Copied! <pre>def get_total(state: SimulationState):\n    total = 0\n    for state in state.all_site_states():\n        total += state.get(\"value\")\n    return total\n\nprint(\"The total of all sites for the starting state is:\", get_total(sync_starting_state))\n</pre> def get_total(state: SimulationState):     total = 0     for state in state.all_site_states():         total += state.get(\"value\")     return total  print(\"The total of all sites for the starting state is:\", get_total(sync_starting_state)) <pre>The total of all sites for the starting state is: 0\n</pre> <p>Great, as expected, the total is zero. Now let's run our simulation and see how this changes.</p> In\u00a0[32]: Copied! <pre>from pylattica.core.runner import AsynchronousRunner\n\nrunner = AsynchronousRunner()\ncontroller = AsyncController()\nnum_steps = 100\n\nasync_result = runner.run(async_starting_state, controller, num_steps)\n</pre> from pylattica.core.runner import AsynchronousRunner  runner = AsynchronousRunner() controller = AsyncController() num_steps = 100  async_result = runner.run(async_starting_state, controller, num_steps) <p>After 100 steps, we see that values have started to slightly diverge from 0:</p> In\u00a0[33]: Copied! <pre>step_artist.jupyter_show(async_result.last_step, cell_size=20)\n</pre> step_artist.jupyter_show(async_result.last_step, cell_size=20) <p>But the total is still zero!</p> In\u00a0[34]: Copied! <pre>print(\"Total after 100 steps:\", get_total(async_result.last_step))\n</pre> print(\"Total after 100 steps:\", get_total(async_result.last_step)) <pre>Total after 100 steps: 0\n</pre> <p>Let's run for 10000 steps and see what the result is:</p> In\u00a0[40]: Copied! <pre>async_result = runner.run(async_starting_state, controller, 10000)\nstep_artist.jupyter_show(async_result.last_step, cell_size=20)\nprint(\"Total after 10000 steps:\", get_total(async_result.last_step))\n</pre> async_result = runner.run(async_starting_state, controller, 10000) step_artist.jupyter_show(async_result.last_step, cell_size=20) print(\"Total after 10000 steps:\", get_total(async_result.last_step)) <pre>Total after 10000 steps: 0\n</pre> <p>The sum is still 0 even though the value of many of these cells has moved significantly away from 0.</p> <p>This illustrates how an <code>AsynchronousRunner</code> can be used to implement quantity conservation.</p>"},{"location":"guides/runners/#runners","title":"Runners\u00b6","text":"<p>After you have defined the form of your <code>SimulationState</code>, the shape of the <code>Lattice</code>, <code>PeriodicStructure</code> and <code>Neighborhood</code> and the <code>Controller</code> that implements your update rule, you are ready to run your simulation! The entity responsible for running the simulation is called a <code>Runner</code>. In <code>pylattica</code> there are two types of runners which run the simulation differently.</p> <ol> <li><code>SynchronousRunner</code> - This runner calculates and applies updates to every site at once during each simulation step.</li> <li><code>AsynchronousRunner</code> - This runner calculates and applies updates to a single site at a time during each simulation step.</li> </ol> <p>The <code>SynchronousRunner</code> behaves like a typical cellular automaton would. It's updates can be parallelized. The <code>AsynchronousRunner</code> is useful for implementing Monte Carlo type simulations, or \"asynchronous automata\", in which multiple cell states are updated during a single invocation of the update rule.</p>"},{"location":"guides/runners/#set-up","title":"Set up\u00b6","text":"<p>Before we dive into these distinctions, let's set up a small 2D square grid structure using some of the helper classes provided by <code>pylattica</code>.</p>"},{"location":"guides/runners/#synchronous-controller-and-evolution","title":"Synchronous Controller and Evolution\u00b6","text":"<p>To demonstrate the <code>SynchronousRunner</code>, we need an update rule that only affects the state of a single site at a time. A good simple example would be: the future value at a cell is given by incrementing the previous value, unless the value is at a maximum (10).</p> <p>Let's implement this rule in a controller.</p>"},{"location":"guides/runners/#asynchronous-controller-and-evolution","title":"Asynchronous Controller and Evolution\u00b6","text":"<p>We will continue our demonstration of <code>Runner</code> objects using the same structure and simulation state seen above, but we will tweak our update rule slightly.</p> <p>First, instead of incrementing by one during every update, let's say each update will randomly increment or decrement the cell it's applied to.</p> <p>Additionally, assume we want to conserve the sum of the values present in our simulation. In other words, if at any simulation step, we added up the values held by every cell, we would expect to see the same total.</p> <p>This would be impossible to achieve with a <code>SynchronousController</code> because the total value is a conserved quantity. The <code>SynchronousController</code> updates every site at once and therefore cannot coordinate site changes. There is no way to conserve a quantity unless we know all the changes that will take place during a given simulation step. This situation is encountered frequently - for instance, in the case of an adsorbed atom moving around on the surface of a crystal, the movement can only be represented by updating neighboring site states simultaneously.</p> <p>Note that we are removing the bounds on possible values, so our color scale may not be relevant.</p> <p>Let's make this concrete by implementing the <code>Controller</code> that does this.</p>"},{"location":"guides/simulation_state/","title":"Simulation State in pylattica","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n</pre> %load_ext autoreload %autoreload 2 In\u00a0[1]: Copied! <pre>from pylattica.core import SimulationState\n\nstate = SimulationState()\n</pre> from pylattica.core import SimulationState  state = SimulationState() <p>Now, you can specify the state value for a given site. By default, the site state is <code>None</code> for an unknown site.</p> In\u00a0[7]: Copied! <pre>print(\"State for site 1 before setting state: \", state.get_site_state(1))\nstate.set_site_state(1, { \"my state key\": \"my state value\"})\nprint(\"State for site 1 after setting state: \", state.get_site_state(1))\n</pre> print(\"State for site 1 before setting state: \", state.get_site_state(1)) state.set_site_state(1, { \"my state key\": \"my state value\"}) print(\"State for site 1 after setting state: \", state.get_site_state(1)) <pre>State for site 1 before setting state:  None\nState for site 1 after setting state:  {'_site_id': 1, 'my state key': 'my state value'}\n</pre> <p>Note that the simulation state will also return the ID of the site inside the state. This just simplifies calculations during simulations.</p> <p>Setting site state does not completely overwrite the previous state. It instead only overwrites the values that you specify.</p> In\u00a0[12]: Copied! <pre>state.set_site_state(1, { \"another key\": \"another value\" })\nstate.get_site_state(1)\n</pre> state.set_site_state(1, { \"another key\": \"another value\" }) state.get_site_state(1) Out[12]: <pre>{'_site_id': 1,\n 'my state key': 'my state value',\n 'another key': 'another value'}</pre> <p>Here's how you partially update existing state:</p> In\u00a0[13]: Copied! <pre>state.set_site_state(1, { \"my state key\": \"a brand new value\" })\nstate.get_site_state(1)\n</pre> state.set_site_state(1, { \"my state key\": \"a brand new value\" }) state.get_site_state(1) Out[13]: <pre>{'_site_id': 1,\n 'my state key': 'a brand new value',\n 'another key': 'another value'}</pre> <p>Note that only the state value for <code>\"my state key\"</code> was updated.</p> In\u00a0[8]: Copied! <pre>state.get_general_state()\n</pre> state.get_general_state() Out[8]: <pre>{}</pre> <p>It's a dictionary, just like the state for each site. You can update it like this:</p> In\u00a0[14]: Copied! <pre>state.set_general_state({\"key1\": \"value1\"})\nstate.get_general_state()\n</pre> state.set_general_state({\"key1\": \"value1\"}) state.get_general_state() Out[14]: <pre>{'key1': 'value1'}</pre>"},{"location":"guides/simulation_state/#simulation-state-in-pylattica","title":"Simulation State in pylattica\u00b6","text":"<p>At the core of every pylattica simulation is a state object. This object is implemented by the <code>SimulationState</code> class. The easiest way to think about it is as a dictionary mapping site IDs to state values. These site IDs refer to sites inside the lattice that you've defined for your simulation. Technically, the sites don't have to refer to physically arranged sites, but for the usual application of pylattica, they do.</p> <p>NOTE: The following examples are to show how the state of the simulation works. In application, the simulation runner performs most of the updates, and you will not explicitly run state update commands</p> <p>Here's the most basic way to set up a simulation state:</p>"},{"location":"guides/simulation_state/#general-state","title":"General State\u00b6","text":"<p>Some simulations require state at each simulation frame that isn't specific to any one single site, but instead applies to the whole simulation frame. The <code>SimulationState</code> class supports that with the concept of General State. This state is accessed as follows:</p>"},{"location":"guides/square_grids/","title":"Square Grid Simulations","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n</pre> %load_ext autoreload %autoreload 2 In\u00a0[8]: Copied! <pre>from pylattica.discrete import PhaseSet\nfrom pylattica.structures.square_grid import DiscreteGridSetup\nfrom pylattica.visualization import SquareGridArtist2D, DiscreteCellArtist\n</pre> from pylattica.discrete import PhaseSet from pylattica.structures.square_grid import DiscreteGridSetup from pylattica.visualization import SquareGridArtist2D, DiscreteCellArtist <p>Many of the most common Cellular Automaton simulations take place on a grid of square cells. <code>pylattica</code> has a number of classes that support this use case. In this demonstration, we will consider a simple simulation in which cells can take on one of the following states, each labelled by a letter:</p> In\u00a0[4]: Copied! <pre>phases = PhaseSet([\"A\", \"B\", \"C\", \"D\", \"E\"])\n</pre> phases = PhaseSet([\"A\", \"B\", \"C\", \"D\", \"E\"]) <p>To set up a simulation that involves discrete cell state values (i.e. \"A\", \"B\", \"C\", \"D\", or \"E\" in our case), and takes place on a square grid, we use the <code>DiscreteGridSetup</code> class. This class provides support for initializing a number of common scenarios that you might want to use as simulation starting points. To create the setup object, just provide the set of all possible phases that can occur during your simulation.</p> In\u00a0[10]: Copied! <pre>setup = DiscreteGridSetup(phases)\n</pre> setup = DiscreteGridSetup(phases) <p>This setup mode just provides a totally random distribution of the phases you specify.</p> In\u00a0[29]: Copied! <pre>simulation_side_length = 40\nphases_to_include = [\"B\", \"C\", \"D\"]\n\nsimulation = setup.setup_noise(60, phases_to_include)\n\ncell_artist = DiscreteCellArtist.from_discrete_state(simulation.state)\nstep_artist = SquareGridArtist2D(simulation.structure, cell_artist=cell_artist)\nstep_artist.jupyter_show(simulation.state, cell_size=5)\n</pre> simulation_side_length = 40 phases_to_include = [\"B\", \"C\", \"D\"]  simulation = setup.setup_noise(60, phases_to_include)  cell_artist = DiscreteCellArtist.from_discrete_state(simulation.state) step_artist = SquareGridArtist2D(simulation.structure, cell_artist=cell_artist) step_artist.jupyter_show(simulation.state, cell_size=5) In\u00a0[12]: Copied! <pre>simulation_side_length = 60\nleft_phase = \"A\"\nright_phase = \"B\"\n\nsimulation = setup.setup_interface(simulation_side_length, left_phase, right_phase)\n\ncell_artist = DiscreteCellArtist.from_discrete_state(simulation.state)\nstep_artist = SquareGridArtist2D(simulation.structure, cell_artist=cell_artist)\nstep_artist.jupyter_show(simulation.state, cell_size=5)\n</pre> simulation_side_length = 60 left_phase = \"A\" right_phase = \"B\"  simulation = setup.setup_interface(simulation_side_length, left_phase, right_phase)  cell_artist = DiscreteCellArtist.from_discrete_state(simulation.state) step_artist = SquareGridArtist2D(simulation.structure, cell_artist=cell_artist) step_artist.jupyter_show(simulation.state, cell_size=5) In\u00a0[13]: Copied! <pre>simulation_side_length = 60\ntotal_num_sites = 100\nbackground_phase = \"A\"\nsite_phases = [\"B\", \"C\"]\nsite_ratios = [1, 2] # There should be 2 C sites for every 1 B site\nbuffer = 2 # Each site should be at least 2 cells away from any other\n\nsimulation = setup.setup_random_sites(\n    simulation_side_length,\n    background_spec=background_phase,\n    num_sites_desired=total_num_sites,\n    nuc_species=site_phases,\n    nuc_ratios=site_ratios,\n    buffer=buffer\n)\n\ncell_artist = DiscreteCellArtist.from_discrete_state(simulation.state)\nstep_artist = SquareGridArtist2D(simulation.structure, cell_artist=cell_artist)\nstep_artist.jupyter_show(simulation.state, cell_size=5)\n</pre> simulation_side_length = 60 total_num_sites = 100 background_phase = \"A\" site_phases = [\"B\", \"C\"] site_ratios = [1, 2] # There should be 2 C sites for every 1 B site buffer = 2 # Each site should be at least 2 cells away from any other  simulation = setup.setup_random_sites(     simulation_side_length,     background_spec=background_phase,     num_sites_desired=total_num_sites,     nuc_species=site_phases,     nuc_ratios=site_ratios,     buffer=buffer )  cell_artist = DiscreteCellArtist.from_discrete_state(simulation.state) step_artist = SquareGridArtist2D(simulation.structure, cell_artist=cell_artist) step_artist.jupyter_show(simulation.state, cell_size=5) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3600/3600 [00:00&lt;00:00, 5413.62it/s]\n</pre> In\u00a0[14]: Copied! <pre>simulation_side_length = 60\nparticle_radius = 10\nbackground_phase = \"A\"\nparticle_phase = \"B\"\n\nsimulation = setup.setup_particle(\n    simulation_side_length,\n    radius = particle_radius,\n    bulk_phase = background_phase,\n    particle_phase = particle_phase\n)\n\ncell_artist = DiscreteCellArtist.from_discrete_state(simulation.state)\nstep_artist = SquareGridArtist2D(simulation.structure, cell_artist=cell_artist)\nstep_artist.jupyter_show(simulation.state, cell_size=5)\n</pre> simulation_side_length = 60 particle_radius = 10 background_phase = \"A\" particle_phase = \"B\"  simulation = setup.setup_particle(     simulation_side_length,     radius = particle_radius,     bulk_phase = background_phase,     particle_phase = particle_phase )  cell_artist = DiscreteCellArtist.from_discrete_state(simulation.state) step_artist = SquareGridArtist2D(simulation.structure, cell_artist=cell_artist) step_artist.jupyter_show(simulation.state, cell_size=5) In\u00a0[16]: Copied! <pre>from pylattica.structures.square_grid.growth_setup import GrowthSetup\nfrom pylattica.structures.square_grid.neighborhoods import MooreNbHoodBuilder\n\nsimulation_side_length = 60\ntotal_num_sites = 20\nbackground_phase = \"A\"\nsite_phases = [\"B\", \"C\", \"D\", \"E\"]\nbuffer = 2 # Each site should be at least 2 cells away from any other\n\ngrowth_setup = GrowthSetup(phases)\nsimulation = growth_setup.grow(\n    simulation_side_length,\n    background_spec=background_phase,\n    num_sites_desired=total_num_sites,\n    nuc_species=site_phases,\n    buffer=buffer,\n    nb_builder=MooreNbHoodBuilder(1)\n)\n\ncell_artist = DiscreteCellArtist.from_discrete_state(simulation.state)\nstep_artist = SquareGridArtist2D(simulation.structure, cell_artist=cell_artist)\nstep_artist.jupyter_show(simulation.state, cell_size=5)\n</pre> from pylattica.structures.square_grid.growth_setup import GrowthSetup from pylattica.structures.square_grid.neighborhoods import MooreNbHoodBuilder  simulation_side_length = 60 total_num_sites = 20 background_phase = \"A\" site_phases = [\"B\", \"C\", \"D\", \"E\"] buffer = 2 # Each site should be at least 2 cells away from any other  growth_setup = GrowthSetup(phases) simulation = growth_setup.grow(     simulation_side_length,     background_spec=background_phase,     num_sites_desired=total_num_sites,     nuc_species=site_phases,     buffer=buffer,     nb_builder=MooreNbHoodBuilder(1) )  cell_artist = DiscreteCellArtist.from_discrete_state(simulation.state) step_artist = SquareGridArtist2D(simulation.structure, cell_artist=cell_artist) step_artist.jupyter_show(simulation.state, cell_size=5) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3600/3600 [00:00&lt;00:00, 5371.84it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3600/3600 [00:00&lt;00:00, 14857.60it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 60/60 [00:00&lt;00:00, 288.28it/s]\n</pre> In\u00a0[18]: Copied! <pre>from pylattica.structures.square_grid.neighborhoods import VonNeumannNbHood2DBuilder\n\nsimulation = growth_setup.grow(\n    simulation_side_length,\n    background_spec=background_phase,\n    num_sites_desired=total_num_sites,\n    nuc_species=site_phases,\n    buffer=buffer,\n    nb_builder=VonNeumannNbHood2DBuilder()\n)\n\ncell_artist = DiscreteCellArtist.from_discrete_state(simulation.state)\nstep_artist = SquareGridArtist2D(simulation.structure, cell_artist=cell_artist)\nstep_artist.jupyter_show(simulation.state, cell_size=5)\n</pre> from pylattica.structures.square_grid.neighborhoods import VonNeumannNbHood2DBuilder  simulation = growth_setup.grow(     simulation_side_length,     background_spec=background_phase,     num_sites_desired=total_num_sites,     nuc_species=site_phases,     buffer=buffer,     nb_builder=VonNeumannNbHood2DBuilder() )  cell_artist = DiscreteCellArtist.from_discrete_state(simulation.state) step_artist = SquareGridArtist2D(simulation.structure, cell_artist=cell_artist) step_artist.jupyter_show(simulation.state, cell_size=5) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3600/3600 [00:00&lt;00:00, 4911.42it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3600/3600 [00:00&lt;00:00, 26419.10it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 60/60 [00:00&lt;00:00, 280.44it/s]\n</pre> In\u00a0[20]: Copied! <pre>from pylattica.core.neighborhood_builders import DistanceNeighborhoodBuilder\n\nsimulation = growth_setup.grow(\n    simulation_side_length,\n    background_spec=background_phase,\n    num_sites_desired=total_num_sites,\n    nuc_species=site_phases,\n    buffer=buffer,\n    nb_builder=DistanceNeighborhoodBuilder(5)\n)\n\ncell_artist = DiscreteCellArtist.from_discrete_state(simulation.state)\nstep_artist = SquareGridArtist2D(simulation.structure, cell_artist=cell_artist)\nstep_artist.jupyter_show(simulation.state, cell_size=5)\n</pre> from pylattica.core.neighborhood_builders import DistanceNeighborhoodBuilder  simulation = growth_setup.grow(     simulation_side_length,     background_spec=background_phase,     num_sites_desired=total_num_sites,     nuc_species=site_phases,     buffer=buffer,     nb_builder=DistanceNeighborhoodBuilder(5) )  cell_artist = DiscreteCellArtist.from_discrete_state(simulation.state) step_artist = SquareGridArtist2D(simulation.structure, cell_artist=cell_artist) step_artist.jupyter_show(simulation.state, cell_size=5) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3600/3600 [00:00&lt;00:00, 4786.48it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3600/3600 [02:03&lt;00:00, 29.27it/s]\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 60/60 [00:00&lt;00:00, 242.33it/s]\n</pre> <p>The output of the setup methods defined above is an instance of <code>Simulation</code>. This object has two attributes: <code>.structure</code> and <code>.state</code>. The structure refers to the lattice of sites that underpins the simulation. In the case of these states we just set up, that lattice is a 2D square grid. In general, it can be any type of lattice. This lattice is called the \"structure\" of the simulation state. It is subject to periodic boundary conditions, meaning that a cell on the edge of the structure is a neighbor to the cell on the opposite edge of the grid.</p> <p>You can access the structure via the <code>structure</code> attribute, and view it's sites. We'll use a small interface simulation for this example.</p> In\u00a0[21]: Copied! <pre>simulation_side_length = 4\nleft_phase = \"A\"\nright_phase = \"B\"\n\nsimulation = setup.setup_interface(simulation_side_length, left_phase, right_phase)\n</pre> simulation_side_length = 4 left_phase = \"A\" right_phase = \"B\"  simulation = setup.setup_interface(simulation_side_length, left_phase, right_phase) <p>Here's how you see all the sites in the structure:</p> In\u00a0[22]: Copied! <pre>simulation.structure.sites()\n</pre> simulation.structure.sites() Out[22]: <pre>[{'_site_class': '_A', '_location': array([0., 0.]), '_site_id': 0},\n {'_site_class': '_A', '_location': array([1., 0.]), '_site_id': 1},\n {'_site_class': '_A', '_location': array([2., 0.]), '_site_id': 2},\n {'_site_class': '_A', '_location': array([3., 0.]), '_site_id': 3},\n {'_site_class': '_A', '_location': array([0., 1.]), '_site_id': 4},\n {'_site_class': '_A', '_location': array([1., 1.]), '_site_id': 5},\n {'_site_class': '_A', '_location': array([2., 1.]), '_site_id': 6},\n {'_site_class': '_A', '_location': array([3., 1.]), '_site_id': 7},\n {'_site_class': '_A', '_location': array([0., 2.]), '_site_id': 8},\n {'_site_class': '_A', '_location': array([1., 2.]), '_site_id': 9},\n {'_site_class': '_A', '_location': array([2., 2.]), '_site_id': 10},\n {'_site_class': '_A', '_location': array([3., 2.]), '_site_id': 11},\n {'_site_class': '_A', '_location': array([0., 3.]), '_site_id': 12},\n {'_site_class': '_A', '_location': array([1., 3.]), '_site_id': 13},\n {'_site_class': '_A', '_location': array([2., 3.]), '_site_id': 14},\n {'_site_class': '_A', '_location': array([3., 3.]), '_site_id': 15}]</pre> <p>See how the locations are represented by two coordinates? They lie on a square grid.</p> <p>Every site in this structure has a <code>_site_class</code> of \"_A\". This is not significant. In other, more complex simulations, this attribute can be used to distinguish types of sites that exist in the structure. For instance, in materials science, we refer to lattice sites by their coordination structure (e.g. tetrahedral, octahedral).</p> In\u00a0[23]: Copied! <pre>site = simulation.structure.sites()[0]\nprint(f'Site {site[\"_site_id\"]} is at {site[\"_location\"]}')\n</pre> site = simulation.structure.sites()[0] print(f'Site {site[\"_site_id\"]} is at {site[\"_location\"]}') <pre>Site 0 is at [0. 0.]\n</pre> <p>Now let's see what it's state is:</p> In\u00a0[24]: Copied! <pre>simulation.state.get_site_state(0)\n</pre> simulation.state.get_site_state(0) Out[24]: <pre>{'_site_id': 0, 'DISCRETE_OCCUPANCY': 'A'}</pre> <p>The <code>DISCRETE_OCCUPANCY</code> key indicates the \"phase\" that occupies that cell. Let's see if that lines up with our visualization. Remember, this site is at (0,0), or the bottom left of the simulation state.</p> In\u00a0[28]: Copied! <pre>cell_artist = DiscreteCellArtist.from_discrete_state(simulation.state)\nstep_artist = SquareGridArtist2D(simulation.structure, cell_artist=cell_artist)\nstep_artist.jupyter_show(simulation.state, cell_size=30)\n</pre> cell_artist = DiscreteCellArtist.from_discrete_state(simulation.state) step_artist = SquareGridArtist2D(simulation.structure, cell_artist=cell_artist) step_artist.jupyter_show(simulation.state, cell_size=30) <p>Sure enough, that bottom left cell is an 'A' cell!</p> <p>Every site in this structure has a <code>_site_class</code> of \"_A\". This is not significant. In other, more complex simulations, this attribute can be used to distinguish types of sites that exist in the structure. For instance, in materials science, we refer to lattice sites by their coordination structure (e.g. tetrahedral, octahedral).</p>"},{"location":"guides/square_grids/#square-grid-simulations","title":"Square Grid Simulations\u00b6","text":""},{"location":"guides/square_grids/#random-noise","title":"Random Noise\u00b6","text":""},{"location":"guides/square_grids/#interface","title":"Interface\u00b6","text":"<p>This method sets up an interface between two phases</p>"},{"location":"guides/square_grids/#random-sites","title":"Random sites\u00b6","text":"<p>Chooses cells separated by a buffer and assigns phases with the desired ratio to them.</p>"},{"location":"guides/square_grids/#single-central-particle","title":"Single Central Particle\u00b6","text":"<p>Assigns the central region of the specified radius to one phase, and everything else to another.</p>"},{"location":"guides/square_grids/#organically-grown-grains","title":"Organically grown grains\u00b6","text":"<p>You can also setup organically grown grains using the included <code>GrowthModel</code>. In this model, we establish random sites, and then grow particles outward from them in the shape of the specified neighborhood. Here's how it looks with a few different neighborhoods:</p>"},{"location":"guides/square_grids/#moore","title":"Moore\u00b6","text":""},{"location":"guides/square_grids/#von-neumann","title":"Von Neumann\u00b6","text":""},{"location":"guides/square_grids/#circular","title":"Circular\u00b6","text":""},{"location":"guides/square_grids/#structure-and-state-or-the-simulation-object","title":"Structure and State (or the <code>Simulation</code> object)\u00b6","text":""},{"location":"guides/square_grids/#simulation-state-dictionary","title":"Simulation State Dictionary\u00b6","text":"<p>You may have noticed that the sites in our structure also have IDs. These IDs are referred to by the <code>SimulationState</code>. This object is essentially a dictionary that maps site IDs to the state of that site. A site state can be any arbitrary python dictionary, but in our case each site is just assigned an occupancy value. Let's make some sense of this.</p> <p>The first site we have is (0,0). It's ID is 0 as well.</p>"},{"location":"reference/atomic/pymatgen_struct_converter/","title":"PymatgenStructConverter","text":""},{"location":"reference/atomic/pymatgen_struct_converter/#pylattica.atomic.pymatgen_struct_converter.PymatgenStructureConverter","title":"<code>PymatgenStructureConverter</code>","text":"<p>A PymatgenStructureConverter provides utilities for converting pylattica PeriodicStructure and Lattice objects to pymatgen's Structure and Lattice objects.</p> Source code in <code>pylattica/atomic/pymatgen_struct_converter.py</code> <pre><code>class PymatgenStructureConverter:\n    \"\"\"A PymatgenStructureConverter provides utilities for converting pylattica\n    PeriodicStructure and Lattice objects to pymatgen's Structure and Lattice objects.\n    \"\"\"\n\n    def to_pylattica_lattice(self, pmg_lat: PmgLattice) -&gt; PylLattice:\n        \"\"\"Converts a pymatgen Lattice to a pylattica Lattice\n\n        Parameters\n        ----------\n        pmg_lat : PmgLattice\n            The pymatgen lattice to convert\n\n        Returns\n        -------\n        Lattice\n            A pylattica lattice\n        \"\"\"\n        pyl_lat = PylLattice(pmg_lat.matrix)\n        return pyl_lat\n\n    def to_pylattica_structure_builder(\n        self, pmg_struct: PmgStructure\n    ) -&gt; StructureBuilder:\n        \"\"\"Converts a pymatgen Structure into a pylattica StructureBuilder which\n        can be used to build pylattica Structures with the same symmetry as the\n        input pymatgen Structure.\n\n        Parameters\n        ----------\n        pmg_struct : PmgStructure\n            The pymatgen structure to convert\n\n        Returns\n        -------\n        StructureBuilder\n            The resulting StructureBuilder\n        \"\"\"\n        lat = self.to_pylattica_lattice(pmg_struct.lattice)\n\n        struct_motif = {}\n\n        for site in pmg_struct.sites:\n            site_cls = site.species_string\n            frac_coords = site.frac_coords\n\n            if site_cls in struct_motif:\n                struct_motif.get(site_cls).append(frac_coords)\n            else:\n                struct_motif[site_cls] = [frac_coords]\n\n        struct_builder = StructureBuilder(lat, struct_motif)\n        struct_builder.frac_coords = True\n        return struct_builder\n\n    def to_pylattica_structure_and_state(\n        self, pmg_struct: PmgStructure\n    ) -&gt; Tuple[PeriodicStructure, SimulationState]:\n        \"\"\"Converts a pymatgen Structure into a pylattica StructureBuilder which\n        can be used to build pylattica Structures with the same symmetry as the\n        input pymatgen Structure.\n\n        Parameters\n        ----------\n        pmg_struct : PmgStructure\n            The pymatgen structure to convert\n\n        Returns\n        -------\n        StructureBuilder\n            The resulting StructureBuilder\n        \"\"\"\n        struct_builder = self.to_pylattica_structure_builder(pmg_struct)\n\n        struct = struct_builder.build(1)\n        state = SimulationState.from_struct(struct)\n        for site in pmg_struct.sites:\n            site_id = struct.site_at(site.coords)[SITE_ID]\n            state.set_site_state(site_id, {DISCRETE_OCCUPANCY: site.species_string})\n\n        return struct, state\n\n    def to_pymatgen_lattice(self, pyl_lat: PylLattice) -&gt; PmgLattice:\n        \"\"\"Converts a pylattica Lattice object into a pymatgen Lattice object.\n\n        Parameters\n        ----------\n        pyl_lat : PylLattice\n            The pylattica Lattice to convert\n\n        Returns\n        -------\n        PmgLattice\n            The resulting pymatgen Lattice\n        \"\"\"\n        return PmgLattice(pyl_lat.vecs)\n\n    def to_pymatgen_structure(self, pyl_struct: PeriodicStructure) -&gt; PmgStructure:\n        \"\"\"Converts a pylattica PeriodicStructure into a pymatgen\n\n        Parameters\n        ----------\n        pyl_struct : PeriodicStructure\n            The pylattica PeriodicStructure to convert\n\n        Returns\n        -------\n        PmgStructure\n            The resulting pymatgen Structure\n        \"\"\"\n        pmg_lat = self.to_pymatgen_lattice(pyl_struct.lattice)\n\n        species = []\n        coords = []\n\n        for sid in pyl_struct.site_ids:\n            species.append(pyl_struct.site_class(sid))\n            coords.append(\n                pyl_struct.lattice.get_fractional_coords(pyl_struct.site_location(sid))\n            )\n\n        return PmgStructure(pmg_lat, species, coords)\n</code></pre>"},{"location":"reference/atomic/pymatgen_struct_converter/#pylattica.atomic.pymatgen_struct_converter.PymatgenStructureConverter.to_pylattica_lattice","title":"<code>to_pylattica_lattice(pmg_lat)</code>","text":"<p>Converts a pymatgen Lattice to a pylattica Lattice</p>"},{"location":"reference/atomic/pymatgen_struct_converter/#pylattica.atomic.pymatgen_struct_converter.PymatgenStructureConverter.to_pylattica_lattice--parameters","title":"Parameters","text":"PmgLattice <p>The pymatgen lattice to convert</p>"},{"location":"reference/atomic/pymatgen_struct_converter/#pylattica.atomic.pymatgen_struct_converter.PymatgenStructureConverter.to_pylattica_lattice--returns","title":"Returns","text":"<p>Lattice     A pylattica lattice</p> Source code in <code>pylattica/atomic/pymatgen_struct_converter.py</code> <pre><code>def to_pylattica_lattice(self, pmg_lat: PmgLattice) -&gt; PylLattice:\n    \"\"\"Converts a pymatgen Lattice to a pylattica Lattice\n\n    Parameters\n    ----------\n    pmg_lat : PmgLattice\n        The pymatgen lattice to convert\n\n    Returns\n    -------\n    Lattice\n        A pylattica lattice\n    \"\"\"\n    pyl_lat = PylLattice(pmg_lat.matrix)\n    return pyl_lat\n</code></pre>"},{"location":"reference/atomic/pymatgen_struct_converter/#pylattica.atomic.pymatgen_struct_converter.PymatgenStructureConverter.to_pylattica_structure_and_state","title":"<code>to_pylattica_structure_and_state(pmg_struct)</code>","text":"<p>Converts a pymatgen Structure into a pylattica StructureBuilder which can be used to build pylattica Structures with the same symmetry as the input pymatgen Structure.</p>"},{"location":"reference/atomic/pymatgen_struct_converter/#pylattica.atomic.pymatgen_struct_converter.PymatgenStructureConverter.to_pylattica_structure_and_state--parameters","title":"Parameters","text":"PmgStructure <p>The pymatgen structure to convert</p>"},{"location":"reference/atomic/pymatgen_struct_converter/#pylattica.atomic.pymatgen_struct_converter.PymatgenStructureConverter.to_pylattica_structure_and_state--returns","title":"Returns","text":"<p>StructureBuilder     The resulting StructureBuilder</p> Source code in <code>pylattica/atomic/pymatgen_struct_converter.py</code> <pre><code>def to_pylattica_structure_and_state(\n    self, pmg_struct: PmgStructure\n) -&gt; Tuple[PeriodicStructure, SimulationState]:\n    \"\"\"Converts a pymatgen Structure into a pylattica StructureBuilder which\n    can be used to build pylattica Structures with the same symmetry as the\n    input pymatgen Structure.\n\n    Parameters\n    ----------\n    pmg_struct : PmgStructure\n        The pymatgen structure to convert\n\n    Returns\n    -------\n    StructureBuilder\n        The resulting StructureBuilder\n    \"\"\"\n    struct_builder = self.to_pylattica_structure_builder(pmg_struct)\n\n    struct = struct_builder.build(1)\n    state = SimulationState.from_struct(struct)\n    for site in pmg_struct.sites:\n        site_id = struct.site_at(site.coords)[SITE_ID]\n        state.set_site_state(site_id, {DISCRETE_OCCUPANCY: site.species_string})\n\n    return struct, state\n</code></pre>"},{"location":"reference/atomic/pymatgen_struct_converter/#pylattica.atomic.pymatgen_struct_converter.PymatgenStructureConverter.to_pylattica_structure_builder","title":"<code>to_pylattica_structure_builder(pmg_struct)</code>","text":"<p>Converts a pymatgen Structure into a pylattica StructureBuilder which can be used to build pylattica Structures with the same symmetry as the input pymatgen Structure.</p>"},{"location":"reference/atomic/pymatgen_struct_converter/#pylattica.atomic.pymatgen_struct_converter.PymatgenStructureConverter.to_pylattica_structure_builder--parameters","title":"Parameters","text":"PmgStructure <p>The pymatgen structure to convert</p>"},{"location":"reference/atomic/pymatgen_struct_converter/#pylattica.atomic.pymatgen_struct_converter.PymatgenStructureConverter.to_pylattica_structure_builder--returns","title":"Returns","text":"<p>StructureBuilder     The resulting StructureBuilder</p> Source code in <code>pylattica/atomic/pymatgen_struct_converter.py</code> <pre><code>def to_pylattica_structure_builder(\n    self, pmg_struct: PmgStructure\n) -&gt; StructureBuilder:\n    \"\"\"Converts a pymatgen Structure into a pylattica StructureBuilder which\n    can be used to build pylattica Structures with the same symmetry as the\n    input pymatgen Structure.\n\n    Parameters\n    ----------\n    pmg_struct : PmgStructure\n        The pymatgen structure to convert\n\n    Returns\n    -------\n    StructureBuilder\n        The resulting StructureBuilder\n    \"\"\"\n    lat = self.to_pylattica_lattice(pmg_struct.lattice)\n\n    struct_motif = {}\n\n    for site in pmg_struct.sites:\n        site_cls = site.species_string\n        frac_coords = site.frac_coords\n\n        if site_cls in struct_motif:\n            struct_motif.get(site_cls).append(frac_coords)\n        else:\n            struct_motif[site_cls] = [frac_coords]\n\n    struct_builder = StructureBuilder(lat, struct_motif)\n    struct_builder.frac_coords = True\n    return struct_builder\n</code></pre>"},{"location":"reference/atomic/pymatgen_struct_converter/#pylattica.atomic.pymatgen_struct_converter.PymatgenStructureConverter.to_pymatgen_lattice","title":"<code>to_pymatgen_lattice(pyl_lat)</code>","text":"<p>Converts a pylattica Lattice object into a pymatgen Lattice object.</p>"},{"location":"reference/atomic/pymatgen_struct_converter/#pylattica.atomic.pymatgen_struct_converter.PymatgenStructureConverter.to_pymatgen_lattice--parameters","title":"Parameters","text":"PylLattice <p>The pylattica Lattice to convert</p>"},{"location":"reference/atomic/pymatgen_struct_converter/#pylattica.atomic.pymatgen_struct_converter.PymatgenStructureConverter.to_pymatgen_lattice--returns","title":"Returns","text":"<p>PmgLattice     The resulting pymatgen Lattice</p> Source code in <code>pylattica/atomic/pymatgen_struct_converter.py</code> <pre><code>def to_pymatgen_lattice(self, pyl_lat: PylLattice) -&gt; PmgLattice:\n    \"\"\"Converts a pylattica Lattice object into a pymatgen Lattice object.\n\n    Parameters\n    ----------\n    pyl_lat : PylLattice\n        The pylattica Lattice to convert\n\n    Returns\n    -------\n    PmgLattice\n        The resulting pymatgen Lattice\n    \"\"\"\n    return PmgLattice(pyl_lat.vecs)\n</code></pre>"},{"location":"reference/atomic/pymatgen_struct_converter/#pylattica.atomic.pymatgen_struct_converter.PymatgenStructureConverter.to_pymatgen_structure","title":"<code>to_pymatgen_structure(pyl_struct)</code>","text":"<p>Converts a pylattica PeriodicStructure into a pymatgen</p>"},{"location":"reference/atomic/pymatgen_struct_converter/#pylattica.atomic.pymatgen_struct_converter.PymatgenStructureConverter.to_pymatgen_structure--parameters","title":"Parameters","text":"PeriodicStructure <p>The pylattica PeriodicStructure to convert</p>"},{"location":"reference/atomic/pymatgen_struct_converter/#pylattica.atomic.pymatgen_struct_converter.PymatgenStructureConverter.to_pymatgen_structure--returns","title":"Returns","text":"<p>PmgStructure     The resulting pymatgen Structure</p> Source code in <code>pylattica/atomic/pymatgen_struct_converter.py</code> <pre><code>def to_pymatgen_structure(self, pyl_struct: PeriodicStructure) -&gt; PmgStructure:\n    \"\"\"Converts a pylattica PeriodicStructure into a pymatgen\n\n    Parameters\n    ----------\n    pyl_struct : PeriodicStructure\n        The pylattica PeriodicStructure to convert\n\n    Returns\n    -------\n    PmgStructure\n        The resulting pymatgen Structure\n    \"\"\"\n    pmg_lat = self.to_pymatgen_lattice(pyl_struct.lattice)\n\n    species = []\n    coords = []\n\n    for sid in pyl_struct.site_ids:\n        species.append(pyl_struct.site_class(sid))\n        coords.append(\n            pyl_struct.lattice.get_fractional_coords(pyl_struct.site_location(sid))\n        )\n\n    return PmgStructure(pmg_lat, species, coords)\n</code></pre>"},{"location":"reference/core/analyzer/","title":"Analyzer","text":""},{"location":"reference/core/analyzer/#pylattica.core.analyzer.StateAnalyzer","title":"<code>StateAnalyzer</code>","text":"<p>Provides basic functionality for analyzing a SimulationState object.</p> Source code in <code>pylattica/core/analyzer.py</code> <pre><code>class StateAnalyzer:\n    \"\"\"Provides basic functionality for analyzing a SimulationState object.\"\"\"\n\n    def __init__(self, structure: PeriodicStructure = None):\n        \"\"\"Ininitializes the StateAnalyzer with the structure provided.\n        The structure is used to filter sites down by site class, if desired.\n\n        Parameters\n        ----------\n        structure : PeriodicStructure\n            The structure to use as the source for site class information.\n        \"\"\"\n        self._structure = structure\n\n    def get_sites(\n        self,\n        state: SimulationState,\n        site_class: str = None,\n        state_criteria: List[Callable[[Dict], bool]] = None,\n    ) -&gt; List[int]:\n        \"\"\"Retrieves a list of site states matching the specified criteria.\n        Criteria are expressed as functions or lambdas that take a site state dictionary\n        and return a boolean indicating whether or not the site satisfies the criteria.\n\n        Parameters\n        ----------\n        state : SimulationState\n            The simulation state to analyze\n        site_class : str, optional\n            If desired, a site class to filter down on, by default None\n        state_criteria : List[Callable[[Dict], bool]], optional\n            A list of functions which must return true for a site to be included in the returned sites, by default None\n\n        Returns\n        -------\n        List[Dict]\n            A list of site IDs satisfying the specified criteria and belonging to the specified site class.\n        \"\"\"\n        if state_criteria is None:\n            state_criteria = []\n\n        if self._structure is not None:\n            sites = self._structure.sites(site_class)\n            sites = [state.get_site_state(site[SITE_ID]) for site in sites]\n        else:\n            sites = state.all_site_states()\n\n        matching_sites = []\n        for site in sites:\n            site_state = state.get_site_state(site[SITE_ID])\n            meets_criteria = True\n\n            for crit in state_criteria:\n                if not crit(site_state):\n                    meets_criteria = False\n                    break\n\n            if meets_criteria:\n                matching_sites.append(site[SITE_ID])\n\n        return matching_sites\n\n    def get_sites_where_equal(\n        self, state: SimulationState, search_pairs: Dict, site_class: str = None\n    ) -&gt; List[int]:\n        \"\"\"Returns sites whose state dictionaries contain values matching the\n        search_pairs parameters passed here. For instance, if you wanted every site\n        with had a state value for property \"B\" equal to 2, search_pairs would be:\n\n        {\n            \"B\": 2\n        }\n\n        Also supports filtering sites based on site class.\n\n        Parameters\n        ----------\n        state : SimulationState\n            The state to filter sites from.\n        search_pairs : Dict\n            The dictionary containing key value pairs that must match the site state.\n        site_class : str, optional\n            The class of sites to consider, by default None\n\n        Returns\n        -------\n        List[int]\n            A list of site IDs corresponding to the matching sites\n        \"\"\"\n\n        def _criteria(site_state: Dict) -&gt; bool:\n            for state_key, state_val in search_pairs.items():\n                if site_state.get(state_key) != state_val:\n                    return False\n            return True\n\n        return self.get_sites(state, site_class=site_class, state_criteria=[_criteria])\n\n    def get_site_count(\n        self,\n        state: SimulationState,\n        site_class: str = None,\n        state_criteria: List[Callable[[Dict], bool]] = None,\n    ) -&gt; int:\n        \"\"\"Counts the sites in the state matching the specified criteria. See documentation\n        for get_sites for more details.\n\n        Parameters\n        ----------\n        state : SimulationState\n            The simulation state to search\n        site_class : str, optional\n            The class of sites to consider, by default None\n        state_criteria : List[Callable[[Dict], bool]], optional\n            The criteria by which a site should be assessed for filtering, by default None\n\n        Returns\n        -------\n        int\n            The number of sites matching the specified criteria\n        \"\"\"\n        return len(\n            self.get_sites(state, site_class=site_class, state_criteria=state_criteria)\n        )\n\n    def get_site_count_where_equal(\n        self, state: SimulationState, search_pairs: Dict, site_class: str = None\n    ) -&gt; int:\n        \"\"\"Counts the sites which have state values equal to those specified by search_pairs.\n        See get_sites_equal for a specification of the search_pairs parameter.\n\n        Parameters\n        ----------\n        state : SimulationState\n            The state to search for sites.\n        search_pairs : Dict\n            The state values that must be matched\n        site_class : str, optional\n            The class of sites to consider, by default None\n\n        Returns\n        -------\n        int\n            The number of sites matching the criteria\n        \"\"\"\n        return len(\n            self.get_sites_where_equal(\n                state, site_class=site_class, search_pairs=search_pairs\n            )\n        )\n</code></pre>"},{"location":"reference/core/analyzer/#pylattica.core.analyzer.StateAnalyzer.__init__","title":"<code>__init__(structure=None)</code>","text":"<p>Ininitializes the StateAnalyzer with the structure provided. The structure is used to filter sites down by site class, if desired.</p>"},{"location":"reference/core/analyzer/#pylattica.core.analyzer.StateAnalyzer.__init__--parameters","title":"Parameters","text":"PeriodicStructure <p>The structure to use as the source for site class information.</p> Source code in <code>pylattica/core/analyzer.py</code> <pre><code>def __init__(self, structure: PeriodicStructure = None):\n    \"\"\"Ininitializes the StateAnalyzer with the structure provided.\n    The structure is used to filter sites down by site class, if desired.\n\n    Parameters\n    ----------\n    structure : PeriodicStructure\n        The structure to use as the source for site class information.\n    \"\"\"\n    self._structure = structure\n</code></pre>"},{"location":"reference/core/analyzer/#pylattica.core.analyzer.StateAnalyzer.get_site_count","title":"<code>get_site_count(state, site_class=None, state_criteria=None)</code>","text":"<p>Counts the sites in the state matching the specified criteria. See documentation for get_sites for more details.</p>"},{"location":"reference/core/analyzer/#pylattica.core.analyzer.StateAnalyzer.get_site_count--parameters","title":"Parameters","text":"SimulationState <p>The simulation state to search</p> str, optional <p>The class of sites to consider, by default None</p> List[Callable[[Dict], bool]], optional <p>The criteria by which a site should be assessed for filtering, by default None</p>"},{"location":"reference/core/analyzer/#pylattica.core.analyzer.StateAnalyzer.get_site_count--returns","title":"Returns","text":"<p>int     The number of sites matching the specified criteria</p> Source code in <code>pylattica/core/analyzer.py</code> <pre><code>def get_site_count(\n    self,\n    state: SimulationState,\n    site_class: str = None,\n    state_criteria: List[Callable[[Dict], bool]] = None,\n) -&gt; int:\n    \"\"\"Counts the sites in the state matching the specified criteria. See documentation\n    for get_sites for more details.\n\n    Parameters\n    ----------\n    state : SimulationState\n        The simulation state to search\n    site_class : str, optional\n        The class of sites to consider, by default None\n    state_criteria : List[Callable[[Dict], bool]], optional\n        The criteria by which a site should be assessed for filtering, by default None\n\n    Returns\n    -------\n    int\n        The number of sites matching the specified criteria\n    \"\"\"\n    return len(\n        self.get_sites(state, site_class=site_class, state_criteria=state_criteria)\n    )\n</code></pre>"},{"location":"reference/core/analyzer/#pylattica.core.analyzer.StateAnalyzer.get_site_count_where_equal","title":"<code>get_site_count_where_equal(state, search_pairs, site_class=None)</code>","text":"<p>Counts the sites which have state values equal to those specified by search_pairs. See get_sites_equal for a specification of the search_pairs parameter.</p>"},{"location":"reference/core/analyzer/#pylattica.core.analyzer.StateAnalyzer.get_site_count_where_equal--parameters","title":"Parameters","text":"SimulationState <p>The state to search for sites.</p> Dict <p>The state values that must be matched</p> str, optional <p>The class of sites to consider, by default None</p>"},{"location":"reference/core/analyzer/#pylattica.core.analyzer.StateAnalyzer.get_site_count_where_equal--returns","title":"Returns","text":"<p>int     The number of sites matching the criteria</p> Source code in <code>pylattica/core/analyzer.py</code> <pre><code>def get_site_count_where_equal(\n    self, state: SimulationState, search_pairs: Dict, site_class: str = None\n) -&gt; int:\n    \"\"\"Counts the sites which have state values equal to those specified by search_pairs.\n    See get_sites_equal for a specification of the search_pairs parameter.\n\n    Parameters\n    ----------\n    state : SimulationState\n        The state to search for sites.\n    search_pairs : Dict\n        The state values that must be matched\n    site_class : str, optional\n        The class of sites to consider, by default None\n\n    Returns\n    -------\n    int\n        The number of sites matching the criteria\n    \"\"\"\n    return len(\n        self.get_sites_where_equal(\n            state, site_class=site_class, search_pairs=search_pairs\n        )\n    )\n</code></pre>"},{"location":"reference/core/analyzer/#pylattica.core.analyzer.StateAnalyzer.get_sites","title":"<code>get_sites(state, site_class=None, state_criteria=None)</code>","text":"<p>Retrieves a list of site states matching the specified criteria. Criteria are expressed as functions or lambdas that take a site state dictionary and return a boolean indicating whether or not the site satisfies the criteria.</p>"},{"location":"reference/core/analyzer/#pylattica.core.analyzer.StateAnalyzer.get_sites--parameters","title":"Parameters","text":"SimulationState <p>The simulation state to analyze</p> str, optional <p>If desired, a site class to filter down on, by default None</p> List[Callable[[Dict], bool]], optional <p>A list of functions which must return true for a site to be included in the returned sites, by default None</p>"},{"location":"reference/core/analyzer/#pylattica.core.analyzer.StateAnalyzer.get_sites--returns","title":"Returns","text":"<p>List[Dict]     A list of site IDs satisfying the specified criteria and belonging to the specified site class.</p> Source code in <code>pylattica/core/analyzer.py</code> <pre><code>def get_sites(\n    self,\n    state: SimulationState,\n    site_class: str = None,\n    state_criteria: List[Callable[[Dict], bool]] = None,\n) -&gt; List[int]:\n    \"\"\"Retrieves a list of site states matching the specified criteria.\n    Criteria are expressed as functions or lambdas that take a site state dictionary\n    and return a boolean indicating whether or not the site satisfies the criteria.\n\n    Parameters\n    ----------\n    state : SimulationState\n        The simulation state to analyze\n    site_class : str, optional\n        If desired, a site class to filter down on, by default None\n    state_criteria : List[Callable[[Dict], bool]], optional\n        A list of functions which must return true for a site to be included in the returned sites, by default None\n\n    Returns\n    -------\n    List[Dict]\n        A list of site IDs satisfying the specified criteria and belonging to the specified site class.\n    \"\"\"\n    if state_criteria is None:\n        state_criteria = []\n\n    if self._structure is not None:\n        sites = self._structure.sites(site_class)\n        sites = [state.get_site_state(site[SITE_ID]) for site in sites]\n    else:\n        sites = state.all_site_states()\n\n    matching_sites = []\n    for site in sites:\n        site_state = state.get_site_state(site[SITE_ID])\n        meets_criteria = True\n\n        for crit in state_criteria:\n            if not crit(site_state):\n                meets_criteria = False\n                break\n\n        if meets_criteria:\n            matching_sites.append(site[SITE_ID])\n\n    return matching_sites\n</code></pre>"},{"location":"reference/core/analyzer/#pylattica.core.analyzer.StateAnalyzer.get_sites_where_equal","title":"<code>get_sites_where_equal(state, search_pairs, site_class=None)</code>","text":"<p>Returns sites whose state dictionaries contain values matching the search_pairs parameters passed here. For instance, if you wanted every site with had a state value for property \"B\" equal to 2, search_pairs would be:</p> <p>{     \"B\": 2 }</p> <p>Also supports filtering sites based on site class.</p>"},{"location":"reference/core/analyzer/#pylattica.core.analyzer.StateAnalyzer.get_sites_where_equal--parameters","title":"Parameters","text":"SimulationState <p>The state to filter sites from.</p> Dict <p>The dictionary containing key value pairs that must match the site state.</p> str, optional <p>The class of sites to consider, by default None</p>"},{"location":"reference/core/analyzer/#pylattica.core.analyzer.StateAnalyzer.get_sites_where_equal--returns","title":"Returns","text":"<p>List[int]     A list of site IDs corresponding to the matching sites</p> Source code in <code>pylattica/core/analyzer.py</code> <pre><code>def get_sites_where_equal(\n    self, state: SimulationState, search_pairs: Dict, site_class: str = None\n) -&gt; List[int]:\n    \"\"\"Returns sites whose state dictionaries contain values matching the\n    search_pairs parameters passed here. For instance, if you wanted every site\n    with had a state value for property \"B\" equal to 2, search_pairs would be:\n\n    {\n        \"B\": 2\n    }\n\n    Also supports filtering sites based on site class.\n\n    Parameters\n    ----------\n    state : SimulationState\n        The state to filter sites from.\n    search_pairs : Dict\n        The dictionary containing key value pairs that must match the site state.\n    site_class : str, optional\n        The class of sites to consider, by default None\n\n    Returns\n    -------\n    List[int]\n        A list of site IDs corresponding to the matching sites\n    \"\"\"\n\n    def _criteria(site_state: Dict) -&gt; bool:\n        for state_key, state_val in search_pairs.items():\n            if site_state.get(state_key) != state_val:\n                return False\n        return True\n\n    return self.get_sites(state, site_class=site_class, state_criteria=[_criteria])\n</code></pre>"},{"location":"reference/core/basic_controller/","title":"BasicController","text":""},{"location":"reference/core/basic_controller/#pylattica.core.basic_controller.BasicController","title":"<code>BasicController</code>","text":"<p>         Bases: <code>ABC</code></p> <p>The base class which all Controllers extend. Every new type of simulation will involve creating a new Controller class. The controller class has a single responsibility, which is to implement the update rule for the simulation.</p> <p>To do this, implement the get_state_update method. The entire current SimulationState will be passed to this method, along with the ID of the site at which the update rule should be applied. It is up to the user to decide what updates should be produced using this information.</p> Source code in <code>pylattica/core/basic_controller.py</code> <pre><code>class BasicController(ABC):\n    \"\"\"The base class which all Controllers extend. Every new type of\n    simulation will involve creating a new Controller class. The controller\n    class has a single responsibility, which is to implement the update\n    rule for the simulation.\n\n    To do this, implement the get_state_update method. The entire current\n    SimulationState will be passed to this method, along with the ID of\n    the site at which the update rule should be applied. It is up to the\n    user to decide what updates should be produced using this information.\n    \"\"\"\n\n    @abstractmethod\n    def get_state_update(self, site_id: int, prev_state: SimulationState):\n        pass  # pragma: no cover\n\n    def pre_run(self, initial_state: SimulationState) -&gt; None:\n        pass\n\n    def get_random_site(self, state: SimulationState):\n        return random.randint(0, len(state.site_ids()) - 1)\n\n    def instantiate_result(self, starting_state: SimulationState):\n        return SimulationResult(starting_state=starting_state)\n</code></pre>"},{"location":"reference/core/coordinate_utils/","title":"Coordinate Utilities","text":""},{"location":"reference/core/coordinate_utils/#pylattica.core.coordinate_utils.get_points_in_box","title":"<code>get_points_in_box(lbs, ubs)</code>","text":"<p>Using a Cartesian product, returns a list of integer points in some region.</p>"},{"location":"reference/core/coordinate_utils/#pylattica.core.coordinate_utils.get_points_in_box--parameters","title":"Parameters","text":"Iterable[Number] <p>description</p> Iterable[Number] <p>description</p>"},{"location":"reference/core/coordinate_utils/#pylattica.core.coordinate_utils.get_points_in_box--returns","title":"Returns","text":"<p>List[List[Number]]     description</p>"},{"location":"reference/core/coordinate_utils/#pylattica.core.coordinate_utils.get_points_in_box--examples","title":"Examples","text":"<p>get_points_in_box([0,1], [1,2]) [[0, 1], [0, 2], [1, 1], [1, 2]]</p> Source code in <code>pylattica/core/coordinate_utils.py</code> <pre><code>def get_points_in_box(lbs: Iterable[int], ubs: Iterable[int]) -&gt; List[List[int]]:\n    \"\"\"Using a Cartesian product, returns a list of integer points in some region.\n\n    Parameters\n    ----------\n    lbs : Iterable[Number]\n        _description_\n    ubs : Iterable[Number]\n        _description_\n\n    Returns\n    -------\n    List[List[Number]]\n        _description_\n\n    Examples\n    --------\n    &gt;&gt;&gt; get_points_in_box([0,1], [1,2])\n    [[0, 1], [0, 2], [1, 1], [1, 2]]\n    \"\"\"\n    args = [list(range(lb, ub)) for lb, ub in zip(lbs, ubs)]\n    return list(itertools.product(*args))\n</code></pre>"},{"location":"reference/core/coordinate_utils/#pylattica.core.coordinate_utils.get_points_in_cube","title":"<code>get_points_in_cube(lb, ub, dim)</code>","text":"<p>Returns the list of all integer separated points in a box of dimension dim with lower bound and upper bounds in each direction specified by lb and ub.</p>"},{"location":"reference/core/coordinate_utils/#pylattica.core.coordinate_utils.get_points_in_cube--parameters","title":"Parameters","text":"int <p>the lower bound of the cube</p> int <p>the uppwer bound of the cube</p>"},{"location":"reference/core/coordinate_utils/#pylattica.core.coordinate_utils.get_points_in_cube--returns","title":"Returns","text":"<p>List[List[int]]     A list of points in the cube</p> Source code in <code>pylattica/core/coordinate_utils.py</code> <pre><code>def get_points_in_cube(lb: int, ub: int, dim: int) -&gt; List[List[int]]:\n    \"\"\"Returns the list of all integer separated points in a box of dimension\n    dim with lower bound and upper bounds in each direction specified by\n    lb and ub.\n\n    Parameters\n    ----------\n    lb : int\n        the lower bound of the cube\n    ub : int\n        the uppwer bound of the cube\n\n    Returns\n    -------\n    List[List[int]]\n        A list of points in the cube\n    \"\"\"\n    return get_points_in_box([lb for _ in range(dim)], [ub for _ in range(dim)])\n</code></pre>"},{"location":"reference/core/distance_map/","title":"DistanceMap","text":""},{"location":"reference/core/distance_map/#pylattica.core.distance_map.DistanceMap","title":"<code>DistanceMap</code>","text":"<p>The DistanceMap is a dictionary containing the distance from a center point to each point in a list of neighbor relative locations.</p> <p>This exists to avoid repeated recomputation of neighbor distances.</p> <p>For instance, if a neighborhood included one neighbor that was one unit in the positive x direction, and one that was offset by one unit in both the x and y directions, this map would be summarized by the following:</p> <p>{     (1, 0): 1,     (1, 1): math.sqrt(2) }</p> Source code in <code>pylattica/core/distance_map.py</code> <pre><code>class DistanceMap:\n    \"\"\"\n    The DistanceMap is a dictionary containing the distance from a\n    center point to each point in a list of neighbor relative locations.\n\n    This exists to avoid repeated recomputation of neighbor distances.\n\n    For instance, if a neighborhood included one neighbor that was one\n    unit in the positive x direction, and one that was offset by\n    one unit in both the x and y directions, this map would be summarized\n    by the following:\n\n    {\n        (1, 0): 1,\n        (1, 1): math.sqrt(2)\n    }\n    \"\"\"\n\n    def __init__(self, relative_neighbor_locs: List[Tuple]):\n        \"\"\"Intializes a DistanceMap.\n\n        Parameters\n        ----------\n        relative_neighbor_locs : List[Tuple]\n            The relative neighbor locations to calculate and store distances\n            for.\n        \"\"\"\n        self.distances: np.array = self._find_distances(relative_neighbor_locs)\n\n    def _find_distances(\n        self, relative_neighbor_locs: List[Tuple]\n    ) -&gt; Dict[Tuple, float]:\n        \"\"\"Generates a map of relative neighbor locations to their distances away.\n\n        Parameters\n        ----------\n        relative_neighbor_locs : List[Tuple]\n            _description_\n\n        Returns\n        -------\n        Dict[Tuple, float]\n            A map of each location to it's distance away.\n        \"\"\"\n        distances = {}\n        for loc in relative_neighbor_locs:\n            distances[loc] = self._distance(np.zeros(len(loc)), np.array(loc))\n\n        return distances\n\n    def get_dist(self, relative_loc: Tuple[Number]) -&gt; float:\n        \"\"\"Given a relative location, returns the stored distance for that location.\n\n        Parameters\n        ----------\n        relative_loc : Tuple[Number]\n            The location of the neighbor to calculate a distance for.\n\n        Returns\n        -------\n        float\n            The distance of that neighbor.\n        \"\"\"\n        return self.distances.get(relative_loc)\n</code></pre>"},{"location":"reference/core/distance_map/#pylattica.core.distance_map.DistanceMap.__init__","title":"<code>__init__(relative_neighbor_locs)</code>","text":"<p>Intializes a DistanceMap.</p>"},{"location":"reference/core/distance_map/#pylattica.core.distance_map.DistanceMap.__init__--parameters","title":"Parameters","text":"List[Tuple] <p>The relative neighbor locations to calculate and store distances for.</p> Source code in <code>pylattica/core/distance_map.py</code> <pre><code>def __init__(self, relative_neighbor_locs: List[Tuple]):\n    \"\"\"Intializes a DistanceMap.\n\n    Parameters\n    ----------\n    relative_neighbor_locs : List[Tuple]\n        The relative neighbor locations to calculate and store distances\n        for.\n    \"\"\"\n    self.distances: np.array = self._find_distances(relative_neighbor_locs)\n</code></pre>"},{"location":"reference/core/distance_map/#pylattica.core.distance_map.DistanceMap.get_dist","title":"<code>get_dist(relative_loc)</code>","text":"<p>Given a relative location, returns the stored distance for that location.</p>"},{"location":"reference/core/distance_map/#pylattica.core.distance_map.DistanceMap.get_dist--parameters","title":"Parameters","text":"Tuple[Number] <p>The location of the neighbor to calculate a distance for.</p>"},{"location":"reference/core/distance_map/#pylattica.core.distance_map.DistanceMap.get_dist--returns","title":"Returns","text":"<p>float     The distance of that neighbor.</p> Source code in <code>pylattica/core/distance_map.py</code> <pre><code>def get_dist(self, relative_loc: Tuple[Number]) -&gt; float:\n    \"\"\"Given a relative location, returns the stored distance for that location.\n\n    Parameters\n    ----------\n    relative_loc : Tuple[Number]\n        The location of the neighbor to calculate a distance for.\n\n    Returns\n    -------\n    float\n        The distance of that neighbor.\n    \"\"\"\n    return self.distances.get(relative_loc)\n</code></pre>"},{"location":"reference/core/distance_map/#pylattica.core.distance_map.EuclideanDistanceMap","title":"<code>EuclideanDistanceMap</code>","text":"<p>         Bases: <code>DistanceMap</code></p> <p>A distance map for storing Euclidean distances.</p> Source code in <code>pylattica/core/distance_map.py</code> <pre><code>class EuclideanDistanceMap(DistanceMap):\n    \"\"\"A distance map for storing Euclidean distances.\"\"\"\n\n    def _distance(self, p1, p2):\n        return round(distance(p1, p2), 2)\n</code></pre>"},{"location":"reference/core/distance_map/#pylattica.core.distance_map.ManhattanDistanceMap","title":"<code>ManhattanDistanceMap</code>","text":"<p>         Bases: <code>DistanceMap</code></p> <p>A distance map that calculates and stores Manhattan distances</p> Source code in <code>pylattica/core/distance_map.py</code> <pre><code>class ManhattanDistanceMap(DistanceMap):\n    \"\"\"A distance map that calculates and stores Manhattan distances\"\"\"\n\n    def _distance(self, p1, p2):\n        return np.abs(p1 - p2).sum()\n</code></pre>"},{"location":"reference/core/distance_map/#pylattica.core.distance_map.distance","title":"<code>distance(arr1, arr2)</code>","text":"<p>Given two 2D or 3D coordinate tuples, return the Euclidean distance between them. This implementation is simpler than the scipy.distance one, but it is much more efficient for small array.</p>"},{"location":"reference/core/distance_map/#pylattica.core.distance_map.distance--parameters","title":"Parameters","text":"np.array <p>The first point</p> np.array <p>The second point</p>"},{"location":"reference/core/distance_map/#pylattica.core.distance_map.distance--returns","title":"Returns","text":"<p>float     The Euclidean distance between the points.</p> Source code in <code>pylattica/core/distance_map.py</code> <pre><code>def distance(arr1: np.array, arr2: np.array) -&gt; float:\n    \"\"\"Given two 2D or 3D coordinate tuples, return the Euclidean distance\n    between them. This implementation is simpler than the scipy.distance\n    one, but it is much more efficient for small array.\n\n    Parameters\n    ----------\n    arr1 : np.array\n        The first point\n    arr2 : np.array\n        The second point\n\n    Returns\n    -------\n    float\n        The Euclidean distance between the points.\n    \"\"\"\n    return np.sqrt(np.square(arr1 - arr2).sum())\n</code></pre>"},{"location":"reference/core/lattice/","title":"Lattice","text":""},{"location":"reference/core/lattice/#pylattica.core.lattice.Lattice","title":"<code>Lattice</code>","text":"<p>A lattice is specified by it's lattice vectors. This class can then be used to create PeriodicStructure instances which are filled with a given motif. The usage flow for this class is:</p> <p>1) Define your lattice by specifying the lattice vectors and instantiating this class 2) Define a motif of sites, which is a dictionary mapping each site class to the basis vectors that point to the site locations 3) Use build_from to generate a periodic structure by repeating the unit cell defined by this lattice in every direction.</p>"},{"location":"reference/core/lattice/#pylattica.core.lattice.Lattice--attributes","title":"Attributes","text":"np.ndarray <p>The lattice vectors defining the unit cell of this lattice.</p> Source code in <code>pylattica/core/lattice.py</code> <pre><code>class Lattice:\n    \"\"\"A lattice is specified by it's lattice vectors. This class can then\n    be used to create PeriodicStructure instances which are filled with\n    a given motif. The usage flow for this class is:\n\n    1) Define your lattice by specifying the lattice vectors and instantiating this class\n    2) Define a motif of sites, which is a dictionary mapping each site class to the\n    basis vectors that point to the site locations\n    3) Use build_from to generate a periodic structure by repeating the unit cell\n    defined by this lattice in every direction.\n\n    Attributes\n    ----------\n\n    vecs : np.ndarray\n        The lattice vectors defining the unit cell of this lattice.\n    \"\"\"\n\n    @classmethod\n    def from_dict(cls, d):\n        return cls(d[\"vectors\"], d[\"periodic\"])\n\n    def __init__(self, vecs: List[Tuple[float]], periodic=True):\n        \"\"\"Initializes a lattice with the vectors defining its unit cell provided.\n        The dimension of the lattice is inferred from the dimension of the lattice vectors.\n\n        Parameters\n        ----------\n        vecs : List[Tuple[float]]\n            A list of vectors establishing the unit cell of the lattice. Any dimension is accepted.\n        \"\"\"\n\n        # This set up of matrix and inversion matrix is taken from pymatgen\n        # I would prefer to use the pymatgen lattice directly, but it is hardcoded\n        # to utilize 3 dimensions - i.e. no game of life, 2D Ising, etc\n\n        self.vecs = np.array(vecs)\n\n        if not isinstance(periodic, tuple) and not isinstance(periodic, list):\n            self.periodic = tuple(periodic for _ in vecs)\n        else:\n            self.periodic = tuple(periodic)\n\n        self._periodic_bool = np.array(periodic, dtype=int)\n\n        dim = int(math.sqrt(len(np.array(self.vecs).flatten())))\n        mat = np.array(self.vecs, dtype=np.float64).reshape((dim, dim))\n        mat.setflags(write=False)\n\n        self._matrix: np.ndarray = mat\n        self._inv_matrix: np.ndarray | None = None\n\n        self.dim = len(vecs[0])\n        self.vec_lengths = [np.linalg.norm(np.array(vec)) for vec in vecs]\n        assert (\n            len(list(set(len(v) for v in vecs))) == 1\n        ), \"Lattice instantiated with vectors of unequal dimension\"\n\n    def as_dict(self):\n        return {\"vectors\": self.vecs.tolist(), \"periodic\": self.periodic}\n\n    @property\n    def matrix(self) -&gt; np.ndarray:\n        \"\"\"Copy of matrix representing the Lattice. (Taken from pymatgen)\"\"\"\n        return self._matrix\n\n    @property\n    def inv_matrix(self) -&gt; np.ndarray:\n        \"\"\"Inverse of lattice matrix. (Taken from pymatgen)\"\"\"\n        if self._inv_matrix is None:\n            self._inv_matrix = np.linalg.inv(self._matrix)\n            self._inv_matrix.setflags(write=False)\n        return self._inv_matrix\n\n    def get_cartesian_coords(self, fractional_coords: ArrayLike) -&gt; np.ndarray:\n        \"\"\"Returns the Cartesian coordinates given fractional coordinates. (taken from pymatgen)\n\n        Parameters\n        ----------\n        fractional_coords : ArrayLike\n            Fractional coords\n\n        Returns\n        -------\n        np.ndarray\n            The equivalent Cartesian coordinates\n        \"\"\"\n        return np.dot(fractional_coords, self._matrix)\n\n    def get_fractional_coords(self, cart_coords: ArrayLike) -&gt; np.ndarray:\n        \"\"\"Returns the fractional coordinates given Cartesian coordinates. (taken from pymatgen)\n\n        Parameters\n        ----------\n        cart_coords : ArrayLike\n            Cartesian coords.\n\n        Returns\n        -------\n        np.ndarray\n            Fractional coordinates.\n        \"\"\"\n        return np.dot(cart_coords, self.inv_matrix)\n\n    def get_periodized_cartesian_coords(self, cart_coords: ArrayLike) -&gt; np.ndarray:\n        \"\"\"Given a set of Cartesian coordinates, returns the periodized version\n        within this lattice.\n\n        Parameters\n        ----------\n        cart_coords : ArrayLike\n            The coordinates to periodize\n\n        Returns\n        -------\n        np.ndarray\n            The periodized coordinates\n        \"\"\"\n        frac = self.get_fractional_coords(cart_coords)\n        return self.get_cartesian_coords(periodize(frac, self.periodic))\n\n    def get_scaled_lattice(self, num_cells: ArrayLike) -&gt; Lattice:\n        \"\"\"Return a copy of this lattice with a unit cell scaled to the dimensions provided.\n        If the num_cells parameter was [3, 3, 3], this would return a lattice 3 times larger\n        in the direction of each basis vector.\n\n        Parameters\n        ----------\n        num_cells : ArrayLike\n            The extent of scaling along each basis direciton\n\n        Returns\n        -------\n        Lattice\n            The new, scaled Lattice instance.\n        \"\"\"\n        return Lattice(\n            np.array([v * amt for amt, v in zip(num_cells, self.vecs)]), self.periodic\n        )\n\n    def cartesian_periodic_distance(self, loc1: ArrayLike, loc2: ArrayLike) -&gt; float:\n        \"\"\"Returns the Cartesian distance between two coordinates after periodizing them.\n\n        Parameters\n        ----------\n        loc1 : ArrayLike\n            The first location.\n        loc2 : ArrayLike\n            The second location.\n\n        Returns\n        -------\n        float\n            The distance between the locations.\n        \"\"\"\n        return pbc_diff_cart(\n            loc1,\n            loc2,\n            self,\n        )\n</code></pre>"},{"location":"reference/core/lattice/#pylattica.core.lattice.Lattice.__init__","title":"<code>__init__(vecs, periodic=True)</code>","text":"<p>Initializes a lattice with the vectors defining its unit cell provided. The dimension of the lattice is inferred from the dimension of the lattice vectors.</p>"},{"location":"reference/core/lattice/#pylattica.core.lattice.Lattice.__init__--parameters","title":"Parameters","text":"List[Tuple[float]] <p>A list of vectors establishing the unit cell of the lattice. Any dimension is accepted.</p> Source code in <code>pylattica/core/lattice.py</code> <pre><code>def __init__(self, vecs: List[Tuple[float]], periodic=True):\n    \"\"\"Initializes a lattice with the vectors defining its unit cell provided.\n    The dimension of the lattice is inferred from the dimension of the lattice vectors.\n\n    Parameters\n    ----------\n    vecs : List[Tuple[float]]\n        A list of vectors establishing the unit cell of the lattice. Any dimension is accepted.\n    \"\"\"\n\n    # This set up of matrix and inversion matrix is taken from pymatgen\n    # I would prefer to use the pymatgen lattice directly, but it is hardcoded\n    # to utilize 3 dimensions - i.e. no game of life, 2D Ising, etc\n\n    self.vecs = np.array(vecs)\n\n    if not isinstance(periodic, tuple) and not isinstance(periodic, list):\n        self.periodic = tuple(periodic for _ in vecs)\n    else:\n        self.periodic = tuple(periodic)\n\n    self._periodic_bool = np.array(periodic, dtype=int)\n\n    dim = int(math.sqrt(len(np.array(self.vecs).flatten())))\n    mat = np.array(self.vecs, dtype=np.float64).reshape((dim, dim))\n    mat.setflags(write=False)\n\n    self._matrix: np.ndarray = mat\n    self._inv_matrix: np.ndarray | None = None\n\n    self.dim = len(vecs[0])\n    self.vec_lengths = [np.linalg.norm(np.array(vec)) for vec in vecs]\n    assert (\n        len(list(set(len(v) for v in vecs))) == 1\n    ), \"Lattice instantiated with vectors of unequal dimension\"\n</code></pre>"},{"location":"reference/core/lattice/#pylattica.core.lattice.Lattice.cartesian_periodic_distance","title":"<code>cartesian_periodic_distance(loc1, loc2)</code>","text":"<p>Returns the Cartesian distance between two coordinates after periodizing them.</p>"},{"location":"reference/core/lattice/#pylattica.core.lattice.Lattice.cartesian_periodic_distance--parameters","title":"Parameters","text":"ArrayLike <p>The first location.</p> ArrayLike <p>The second location.</p>"},{"location":"reference/core/lattice/#pylattica.core.lattice.Lattice.cartesian_periodic_distance--returns","title":"Returns","text":"<p>float     The distance between the locations.</p> Source code in <code>pylattica/core/lattice.py</code> <pre><code>def cartesian_periodic_distance(self, loc1: ArrayLike, loc2: ArrayLike) -&gt; float:\n    \"\"\"Returns the Cartesian distance between two coordinates after periodizing them.\n\n    Parameters\n    ----------\n    loc1 : ArrayLike\n        The first location.\n    loc2 : ArrayLike\n        The second location.\n\n    Returns\n    -------\n    float\n        The distance between the locations.\n    \"\"\"\n    return pbc_diff_cart(\n        loc1,\n        loc2,\n        self,\n    )\n</code></pre>"},{"location":"reference/core/lattice/#pylattica.core.lattice.Lattice.get_cartesian_coords","title":"<code>get_cartesian_coords(fractional_coords)</code>","text":"<p>Returns the Cartesian coordinates given fractional coordinates. (taken from pymatgen)</p>"},{"location":"reference/core/lattice/#pylattica.core.lattice.Lattice.get_cartesian_coords--parameters","title":"Parameters","text":"ArrayLike <p>Fractional coords</p>"},{"location":"reference/core/lattice/#pylattica.core.lattice.Lattice.get_cartesian_coords--returns","title":"Returns","text":"<p>np.ndarray     The equivalent Cartesian coordinates</p> Source code in <code>pylattica/core/lattice.py</code> <pre><code>def get_cartesian_coords(self, fractional_coords: ArrayLike) -&gt; np.ndarray:\n    \"\"\"Returns the Cartesian coordinates given fractional coordinates. (taken from pymatgen)\n\n    Parameters\n    ----------\n    fractional_coords : ArrayLike\n        Fractional coords\n\n    Returns\n    -------\n    np.ndarray\n        The equivalent Cartesian coordinates\n    \"\"\"\n    return np.dot(fractional_coords, self._matrix)\n</code></pre>"},{"location":"reference/core/lattice/#pylattica.core.lattice.Lattice.get_fractional_coords","title":"<code>get_fractional_coords(cart_coords)</code>","text":"<p>Returns the fractional coordinates given Cartesian coordinates. (taken from pymatgen)</p>"},{"location":"reference/core/lattice/#pylattica.core.lattice.Lattice.get_fractional_coords--parameters","title":"Parameters","text":"ArrayLike <p>Cartesian coords.</p>"},{"location":"reference/core/lattice/#pylattica.core.lattice.Lattice.get_fractional_coords--returns","title":"Returns","text":"<p>np.ndarray     Fractional coordinates.</p> Source code in <code>pylattica/core/lattice.py</code> <pre><code>def get_fractional_coords(self, cart_coords: ArrayLike) -&gt; np.ndarray:\n    \"\"\"Returns the fractional coordinates given Cartesian coordinates. (taken from pymatgen)\n\n    Parameters\n    ----------\n    cart_coords : ArrayLike\n        Cartesian coords.\n\n    Returns\n    -------\n    np.ndarray\n        Fractional coordinates.\n    \"\"\"\n    return np.dot(cart_coords, self.inv_matrix)\n</code></pre>"},{"location":"reference/core/lattice/#pylattica.core.lattice.Lattice.get_periodized_cartesian_coords","title":"<code>get_periodized_cartesian_coords(cart_coords)</code>","text":"<p>Given a set of Cartesian coordinates, returns the periodized version within this lattice.</p>"},{"location":"reference/core/lattice/#pylattica.core.lattice.Lattice.get_periodized_cartesian_coords--parameters","title":"Parameters","text":"ArrayLike <p>The coordinates to periodize</p>"},{"location":"reference/core/lattice/#pylattica.core.lattice.Lattice.get_periodized_cartesian_coords--returns","title":"Returns","text":"<p>np.ndarray     The periodized coordinates</p> Source code in <code>pylattica/core/lattice.py</code> <pre><code>def get_periodized_cartesian_coords(self, cart_coords: ArrayLike) -&gt; np.ndarray:\n    \"\"\"Given a set of Cartesian coordinates, returns the periodized version\n    within this lattice.\n\n    Parameters\n    ----------\n    cart_coords : ArrayLike\n        The coordinates to periodize\n\n    Returns\n    -------\n    np.ndarray\n        The periodized coordinates\n    \"\"\"\n    frac = self.get_fractional_coords(cart_coords)\n    return self.get_cartesian_coords(periodize(frac, self.periodic))\n</code></pre>"},{"location":"reference/core/lattice/#pylattica.core.lattice.Lattice.get_scaled_lattice","title":"<code>get_scaled_lattice(num_cells)</code>","text":"<p>Return a copy of this lattice with a unit cell scaled to the dimensions provided. If the num_cells parameter was [3, 3, 3], this would return a lattice 3 times larger in the direction of each basis vector.</p>"},{"location":"reference/core/lattice/#pylattica.core.lattice.Lattice.get_scaled_lattice--parameters","title":"Parameters","text":"ArrayLike <p>The extent of scaling along each basis direciton</p>"},{"location":"reference/core/lattice/#pylattica.core.lattice.Lattice.get_scaled_lattice--returns","title":"Returns","text":"<p>Lattice     The new, scaled Lattice instance.</p> Source code in <code>pylattica/core/lattice.py</code> <pre><code>def get_scaled_lattice(self, num_cells: ArrayLike) -&gt; Lattice:\n    \"\"\"Return a copy of this lattice with a unit cell scaled to the dimensions provided.\n    If the num_cells parameter was [3, 3, 3], this would return a lattice 3 times larger\n    in the direction of each basis vector.\n\n    Parameters\n    ----------\n    num_cells : ArrayLike\n        The extent of scaling along each basis direciton\n\n    Returns\n    -------\n    Lattice\n        The new, scaled Lattice instance.\n    \"\"\"\n    return Lattice(\n        np.array([v * amt for amt, v in zip(num_cells, self.vecs)]), self.periodic\n    )\n</code></pre>"},{"location":"reference/core/lattice/#pylattica.core.lattice.Lattice.inv_matrix","title":"<code>inv_matrix()</code>  <code>property</code>","text":"<p>Inverse of lattice matrix. (Taken from pymatgen)</p> Source code in <code>pylattica/core/lattice.py</code> <pre><code>@property\ndef inv_matrix(self) -&gt; np.ndarray:\n    \"\"\"Inverse of lattice matrix. (Taken from pymatgen)\"\"\"\n    if self._inv_matrix is None:\n        self._inv_matrix = np.linalg.inv(self._matrix)\n        self._inv_matrix.setflags(write=False)\n    return self._inv_matrix\n</code></pre>"},{"location":"reference/core/lattice/#pylattica.core.lattice.Lattice.matrix","title":"<code>matrix()</code>  <code>property</code>","text":"<p>Copy of matrix representing the Lattice. (Taken from pymatgen)</p> Source code in <code>pylattica/core/lattice.py</code> <pre><code>@property\ndef matrix(self) -&gt; np.ndarray:\n    \"\"\"Copy of matrix representing the Lattice. (Taken from pymatgen)\"\"\"\n    return self._matrix\n</code></pre>"},{"location":"reference/core/lattice/#pylattica.core.lattice.pbc_diff_cart","title":"<code>pbc_diff_cart(cart_coords1, cart_coords2, lattice)</code>","text":"<p>Returns the Cartesian distance between two coordinates taking into account periodic boundary conditions. (from pymatgen)</p>"},{"location":"reference/core/lattice/#pylattica.core.lattice.pbc_diff_cart--parameters","title":"Parameters","text":"ArrayLike <p>First set of Cartesian coordinates</p> ArrayLike <p>Second set of Cartesian coordinates</p> Lattice <p>The Lattice within which the distance should be calculated</p>"},{"location":"reference/core/lattice/#pylattica.core.lattice.pbc_diff_cart--returns","title":"Returns","text":"<p>type description</p> Source code in <code>pylattica/core/lattice.py</code> <pre><code>def pbc_diff_cart(cart_coords1: ArrayLike, cart_coords2: ArrayLike, lattice: Lattice):\n    \"\"\"Returns the Cartesian distance between two coordinates taking into\n    account periodic boundary conditions. (from pymatgen)\n\n    Parameters\n    ----------\n    cart_coords1 : ArrayLike\n        First set of Cartesian coordinates\n    cart_coords2 : ArrayLike\n        Second set of Cartesian coordinates\n    lattice : Lattice\n        The Lattice within which the distance should be calculated\n\n    Returns\n    -------\n    _type_\n        _description_\n    \"\"\"\n    fcoords1 = lattice.get_fractional_coords(cart_coords1)\n    fcoords2 = lattice.get_fractional_coords(cart_coords2)\n    frac_dist = pbc_diff_frac_vec(fcoords1, fcoords2, lattice.periodic)\n    return np.round(\n        np.linalg.norm(lattice.get_cartesian_coords(frac_dist)), OFFSET_PRECISION\n    )\n</code></pre>"},{"location":"reference/core/lattice/#pylattica.core.lattice.pbc_diff_frac_vec","title":"<code>pbc_diff_frac_vec(fcoords1, fcoords2, periodic)</code>","text":"<p>Returns the 'fractional distance' between two coordinates taking into account periodic boundary conditions. (from pymatgen)</p>"},{"location":"reference/core/lattice/#pylattica.core.lattice.pbc_diff_frac_vec--parameters","title":"Parameters","text":"ArrayLike <p>First set of fractional coordinates. e.g., [0.5, 0.6, 0.7] or [[1.1, 1.2, 4.3], [0.5, 0.6, 0.7]]. It can be a single coord or any array of coords.</p> ArrayLike <p>Second set of fractional coordinates.</p> ArrayLike <p>a tuple defining the periodic boundary conditions along the three axis of the lattice.</p>"},{"location":"reference/core/lattice/#pylattica.core.lattice.pbc_diff_frac_vec--returns","title":"Returns","text":"<p>float     Fractional distance. Each coordinate must have the  operty that     abs(a) &lt;= 0.5. Examples:     pbc_diff([0.1, 0.1, 0.1], [0.3, 0.5, 0.9]) = [-0.2, -0.4, 0.2]     pbc_diff([0.9, 0.1, 1.01], [0.3, 0.5, 0.9]) = [-0.4, -0.4, 0.11]</p> Source code in <code>pylattica/core/lattice.py</code> <pre><code>def pbc_diff_frac_vec(fcoords1: ArrayLike, fcoords2: ArrayLike, periodic):\n    \"\"\"Returns the 'fractional distance' between two coordinates taking into\n    account periodic boundary conditions. (from pymatgen)\n\n    Parameters\n    ----------\n    fcoords1 : ArrayLike\n        First set of fractional coordinates. e.g., [0.5, 0.6,\n        0.7] or [[1.1, 1.2, 4.3], [0.5, 0.6, 0.7]]. It can be a single\n        coord or any array of coords.\n    fcoords2 : ArrayLike\n        Second set of fractional coordinates.\n    periodic : ArrayLike\n        a tuple defining the periodic boundary conditions along the three\n        axis of the lattice.\n\n    Returns\n    -------\n    float\n        Fractional distance. Each coordinate must have the  operty that\n        abs(a) &lt;= 0.5. Examples:\n        pbc_diff([0.1, 0.1, 0.1], [0.3, 0.5, 0.9]) = [-0.2, -0.4, 0.2]\n        pbc_diff([0.9, 0.1, 1.01], [0.3, 0.5, 0.9]) = [-0.4, -0.4, 0.11]\n    \"\"\"\n    fdist = np.subtract(fcoords1, fcoords2)\n    return fdist - np.round(fdist) * periodic\n</code></pre>"},{"location":"reference/core/lattice/#pylattica.core.lattice.periodize","title":"<code>periodize(frac_coords, periodic=True)</code>","text":"<p>Moves fractional coordinates into the unit cell.</p>"},{"location":"reference/core/lattice/#pylattica.core.lattice.periodize--parameters","title":"Parameters","text":"ArrayLike <p>The fractional coordinates to periodize.</p> bool, optional <p>Either a single boolean or a tuple of booleans indicating the periodicity of each dimension, by default True</p>"},{"location":"reference/core/lattice/#pylattica.core.lattice.periodize--returns","title":"Returns","text":"<p>ArrayLike     The periodized coordinates</p> Source code in <code>pylattica/core/lattice.py</code> <pre><code>def periodize(frac_coords, periodic: Union[Tuple[bool], bool] = True):\n    \"\"\"Moves fractional coordinates into the unit cell.\n\n    Parameters\n    ----------\n    frac_coords : ArrayLike\n        The fractional coordinates to periodize.\n    periodic : bool, optional\n        Either a single boolean or a tuple of booleans indicating the periodicity\n        of each dimension, by default True\n\n    Returns\n    -------\n    ArrayLike\n        The periodized coordinates\n    \"\"\"\n    if not isinstance(periodic, tuple):\n        periodic = [periodic for _ in frac_coords]\n\n    return frac_coords - np.floor(frac_coords) * np.array(periodic, dtype=int)\n</code></pre>"},{"location":"reference/core/neighborhood/","title":"Neighborhoods","text":""},{"location":"reference/core/neighborhood/#pylattica.core.neighborhoods.Neighborhood","title":"<code>Neighborhood</code>","text":"<p>         Bases: <code>AbstractNeighborhood</code></p> <p>A specific Neighborhood. An instance of this classes corresponds to a particular SimulationState. It stores a map of each site_id in the SimulationState to the IDs of the sites which are it's neighbors.</p> Source code in <code>pylattica/core/neighborhoods.py</code> <pre><code>class Neighborhood(AbstractNeighborhood):\n    \"\"\"A specific Neighborhood. An instance of this classes corresponds\n    to a particular SimulationState. It stores a map of each site_id\n    in the SimulationState to the IDs of the sites which are it's neighbors.\n    \"\"\"\n\n    def __init__(self, graph: rx.PyGraph):\n        \"\"\"Instantiates a NeighborhoodGraph.\"\"\"\n        self._graph = graph\n\n    def neighbors_of(self, site_id: int, include_weights: bool = False) -&gt; List[int]:\n        \"\"\"Retrieves a list of the IDs of the sites which are neighbors of the\n        provided site. Optionally includes the weights of the connections to those\n        neighbors.\n\n        Parameters\n        ----------\n        site_id : int\n            The site for which neighbors should be retrieved\n        include_weights : bool, optional\n            Whether or not weights if the neighbor connections should\n            be included, by default False\n\n        Returns\n        -------\n        list[int]\n            Either a list of site IDs, or a list of tuples of (site ID, connection weight)\n        \"\"\"\n        nbs = self._graph.neighbors(site_id)\n        if include_weights:\n            weighted_nbs = [\n                (nb_id, self._graph.get_edge_data(site_id, nb_id)) for nb_id in nbs\n            ]\n            return weighted_nbs\n\n        return list(nbs)\n</code></pre>"},{"location":"reference/core/neighborhood/#pylattica.core.neighborhoods.Neighborhood.__init__","title":"<code>__init__(graph)</code>","text":"<p>Instantiates a NeighborhoodGraph.</p> Source code in <code>pylattica/core/neighborhoods.py</code> <pre><code>def __init__(self, graph: rx.PyGraph):\n    \"\"\"Instantiates a NeighborhoodGraph.\"\"\"\n    self._graph = graph\n</code></pre>"},{"location":"reference/core/neighborhood/#pylattica.core.neighborhoods.Neighborhood.neighbors_of","title":"<code>neighbors_of(site_id, include_weights=False)</code>","text":"<p>Retrieves a list of the IDs of the sites which are neighbors of the provided site. Optionally includes the weights of the connections to those neighbors.</p>"},{"location":"reference/core/neighborhood/#pylattica.core.neighborhoods.Neighborhood.neighbors_of--parameters","title":"Parameters","text":"int <p>The site for which neighbors should be retrieved</p> bool, optional <p>Whether or not weights if the neighbor connections should be included, by default False</p>"},{"location":"reference/core/neighborhood/#pylattica.core.neighborhoods.Neighborhood.neighbors_of--returns","title":"Returns","text":"<p>list[int]     Either a list of site IDs, or a list of tuples of (site ID, connection weight)</p> Source code in <code>pylattica/core/neighborhoods.py</code> <pre><code>def neighbors_of(self, site_id: int, include_weights: bool = False) -&gt; List[int]:\n    \"\"\"Retrieves a list of the IDs of the sites which are neighbors of the\n    provided site. Optionally includes the weights of the connections to those\n    neighbors.\n\n    Parameters\n    ----------\n    site_id : int\n        The site for which neighbors should be retrieved\n    include_weights : bool, optional\n        Whether or not weights if the neighbor connections should\n        be included, by default False\n\n    Returns\n    -------\n    list[int]\n        Either a list of site IDs, or a list of tuples of (site ID, connection weight)\n    \"\"\"\n    nbs = self._graph.neighbors(site_id)\n    if include_weights:\n        weighted_nbs = [\n            (nb_id, self._graph.get_edge_data(site_id, nb_id)) for nb_id in nbs\n        ]\n        return weighted_nbs\n\n    return list(nbs)\n</code></pre>"},{"location":"reference/core/neighborhood/#pylattica.core.neighborhoods.SiteClassNeighborhood","title":"<code>SiteClassNeighborhood</code>","text":"<p>         Bases: <code>MultiNeighborhood</code></p> <p>A Neighborhood that distinguished neighbors of sites based on their class</p> Source code in <code>pylattica/core/neighborhoods.py</code> <pre><code>class SiteClassNeighborhood(MultiNeighborhood):\n    \"\"\"A Neighborhood that distinguished neighbors of sites based on their class\"\"\"\n\n    def __init__(\n        self, structure: PeriodicStructure, neighborhoods: Dict[str, Neighborhood]\n    ):\n        self._struct = structure\n        self._nbhoods = neighborhoods\n\n    def _get_nbhood(self, site_id: int) -&gt; List[int]:\n        site_class = self._struct.site_class(site_id)\n        return self._nbhoods.get(site_class)\n</code></pre>"},{"location":"reference/core/neighborhood/#pylattica.core.neighborhoods.StochasticNeighborhood","title":"<code>StochasticNeighborhood</code>","text":"<p>         Bases: <code>MultiNeighborhood</code></p> <p>A NeighborhoodGraph for stochastic neighborhoods.</p> Source code in <code>pylattica/core/neighborhoods.py</code> <pre><code>class StochasticNeighborhood(MultiNeighborhood):\n    \"\"\"A NeighborhoodGraph for stochastic neighborhoods.\"\"\"\n\n    def __init__(self, neighborhoods: List[Neighborhood]):\n        self._neighborhoods = neighborhoods\n\n    def _get_nbhood(self, _) -&gt; List[int]:\n        return random.choice(self._neighborhoods)\n</code></pre>"},{"location":"reference/core/neighborhood_builders/","title":"NeighborhoodBuilders","text":""},{"location":"reference/core/neighborhood_builders/#pylattica.core.neighborhood_builders.AnnularNeighborhoodBuilder","title":"<code>AnnularNeighborhoodBuilder</code>","text":"<p>         Bases: <code>NeighborhoodBuilder</code></p> <p>This neighborhood builder creates neighbor connections between sites which are within a ring-shaped region around eachother. This region is specified by a minimum (inner radius) and maximum (outer radius) distance.</p> Source code in <code>pylattica/core/neighborhood_builders.py</code> <pre><code>class AnnularNeighborhoodBuilder(NeighborhoodBuilder):\n    \"\"\"This neighborhood builder creates neighbor connections between\n    sites which are within a ring-shaped region around eachother. This region\n    is specified by a minimum (inner radius) and maximum (outer radius) distance.\n    \"\"\"\n\n    def __init__(self, inner_radius: float, outer_radius: float):\n        \"\"\"Instantiates an AnnularNeighborhoodBuilder\n\n        Parameters\n        ----------\n        inner_radius : float\n            The minimum at which two sites are considered neighbors.\n        outer_radius : float\n            The maximum distance at which two sites are considered neighbors.\n        \"\"\"\n        self.inner_radius = inner_radius\n        self.outer_radius = outer_radius\n\n    def get_neighbors(self, curr_site: Dict, struct: PeriodicStructure) -&gt; List[Tuple]:\n        \"\"\"Builds a NeighborGraph from the provided structure according\n        to the cutoff distance of this Builder.\n\n        Parameters\n        ----------\n        struct : PeriodicStructure\n            The structure from which a NeighborGraph should be constructed.\n\n        Returns\n        -------\n        NeighborGraph\n            The resulting NeighborGraph\n        \"\"\"\n        nbs = []\n        for other_site in struct.sites():\n            if curr_site[SITE_ID] != other_site[SITE_ID]:\n                dist = pbc_diff_cart(\n                    np.array(other_site[LOCATION]),\n                    np.array(curr_site[LOCATION]),\n                    struct.lattice,\n                )\n\n                if self.inner_radius &lt; dist &lt; self.outer_radius:\n                    nbs.append((other_site[SITE_ID], dist))\n\n        return nbs\n</code></pre>"},{"location":"reference/core/neighborhood_builders/#pylattica.core.neighborhood_builders.AnnularNeighborhoodBuilder.__init__","title":"<code>__init__(inner_radius, outer_radius)</code>","text":"<p>Instantiates an AnnularNeighborhoodBuilder</p>"},{"location":"reference/core/neighborhood_builders/#pylattica.core.neighborhood_builders.AnnularNeighborhoodBuilder.__init__--parameters","title":"Parameters","text":"float <p>The minimum at which two sites are considered neighbors.</p> float <p>The maximum distance at which two sites are considered neighbors.</p> Source code in <code>pylattica/core/neighborhood_builders.py</code> <pre><code>def __init__(self, inner_radius: float, outer_radius: float):\n    \"\"\"Instantiates an AnnularNeighborhoodBuilder\n\n    Parameters\n    ----------\n    inner_radius : float\n        The minimum at which two sites are considered neighbors.\n    outer_radius : float\n        The maximum distance at which two sites are considered neighbors.\n    \"\"\"\n    self.inner_radius = inner_radius\n    self.outer_radius = outer_radius\n</code></pre>"},{"location":"reference/core/neighborhood_builders/#pylattica.core.neighborhood_builders.AnnularNeighborhoodBuilder.get_neighbors","title":"<code>get_neighbors(curr_site, struct)</code>","text":"<p>Builds a NeighborGraph from the provided structure according to the cutoff distance of this Builder.</p>"},{"location":"reference/core/neighborhood_builders/#pylattica.core.neighborhood_builders.AnnularNeighborhoodBuilder.get_neighbors--parameters","title":"Parameters","text":"PeriodicStructure <p>The structure from which a NeighborGraph should be constructed.</p>"},{"location":"reference/core/neighborhood_builders/#pylattica.core.neighborhood_builders.AnnularNeighborhoodBuilder.get_neighbors--returns","title":"Returns","text":"<p>NeighborGraph     The resulting NeighborGraph</p> Source code in <code>pylattica/core/neighborhood_builders.py</code> <pre><code>def get_neighbors(self, curr_site: Dict, struct: PeriodicStructure) -&gt; List[Tuple]:\n    \"\"\"Builds a NeighborGraph from the provided structure according\n    to the cutoff distance of this Builder.\n\n    Parameters\n    ----------\n    struct : PeriodicStructure\n        The structure from which a NeighborGraph should be constructed.\n\n    Returns\n    -------\n    NeighborGraph\n        The resulting NeighborGraph\n    \"\"\"\n    nbs = []\n    for other_site in struct.sites():\n        if curr_site[SITE_ID] != other_site[SITE_ID]:\n            dist = pbc_diff_cart(\n                np.array(other_site[LOCATION]),\n                np.array(curr_site[LOCATION]),\n                struct.lattice,\n            )\n\n            if self.inner_radius &lt; dist &lt; self.outer_radius:\n                nbs.append((other_site[SITE_ID], dist))\n\n    return nbs\n</code></pre>"},{"location":"reference/core/neighborhood_builders/#pylattica.core.neighborhood_builders.DistanceNeighborhoodBuilder","title":"<code>DistanceNeighborhoodBuilder</code>","text":"<p>         Bases: <code>NeighborhoodBuilder</code></p> <p>This neighborhood builder creates neighbor connections between sites which are within some cutoff distance of eachother.</p> Source code in <code>pylattica/core/neighborhood_builders.py</code> <pre><code>class DistanceNeighborhoodBuilder(NeighborhoodBuilder):\n    \"\"\"This neighborhood builder creates neighbor connections between\n    sites which are within some cutoff distance of eachother.\n    \"\"\"\n\n    def __init__(self, cutoff: float):\n        \"\"\"Instantiates a DistanceNeighborhoodBuilder\n\n        Parameters\n        ----------\n        cutoff : float\n            The maximum distance at which two sites are considered neighbors.\n        \"\"\"\n        self.cutoff = cutoff\n\n    def get_neighbors(self, curr_site: Dict, struct: PeriodicStructure) -&gt; List[Tuple]:\n        \"\"\"Builds a NeighborGraph from the provided structure according\n        to the cutoff distance of this Builder.\n\n        Parameters\n        ----------\n        struct : PeriodicStructure\n            The structure from which a NeighborGraph should be constructed.\n\n        Returns\n        -------\n        NeighborGraph\n            The resulting NeighborGraph\n        \"\"\"\n        nbs = []\n        curr_loc = curr_site[LOCATION]\n        curr_id = curr_site[SITE_ID]\n        for other_site in struct.sites():\n            other_id = other_site[SITE_ID]\n            if curr_id != other_id:\n                dist = struct.lattice.cartesian_periodic_distance(\n                    other_site[LOCATION],\n                    curr_loc,\n                )\n\n                if dist &lt; self.cutoff:\n                    nbs.append((other_id, dist))\n\n        return nbs\n</code></pre>"},{"location":"reference/core/neighborhood_builders/#pylattica.core.neighborhood_builders.DistanceNeighborhoodBuilder.__init__","title":"<code>__init__(cutoff)</code>","text":"<p>Instantiates a DistanceNeighborhoodBuilder</p>"},{"location":"reference/core/neighborhood_builders/#pylattica.core.neighborhood_builders.DistanceNeighborhoodBuilder.__init__--parameters","title":"Parameters","text":"float <p>The maximum distance at which two sites are considered neighbors.</p> Source code in <code>pylattica/core/neighborhood_builders.py</code> <pre><code>def __init__(self, cutoff: float):\n    \"\"\"Instantiates a DistanceNeighborhoodBuilder\n\n    Parameters\n    ----------\n    cutoff : float\n        The maximum distance at which two sites are considered neighbors.\n    \"\"\"\n    self.cutoff = cutoff\n</code></pre>"},{"location":"reference/core/neighborhood_builders/#pylattica.core.neighborhood_builders.DistanceNeighborhoodBuilder.get_neighbors","title":"<code>get_neighbors(curr_site, struct)</code>","text":"<p>Builds a NeighborGraph from the provided structure according to the cutoff distance of this Builder.</p>"},{"location":"reference/core/neighborhood_builders/#pylattica.core.neighborhood_builders.DistanceNeighborhoodBuilder.get_neighbors--parameters","title":"Parameters","text":"PeriodicStructure <p>The structure from which a NeighborGraph should be constructed.</p>"},{"location":"reference/core/neighborhood_builders/#pylattica.core.neighborhood_builders.DistanceNeighborhoodBuilder.get_neighbors--returns","title":"Returns","text":"<p>NeighborGraph     The resulting NeighborGraph</p> Source code in <code>pylattica/core/neighborhood_builders.py</code> <pre><code>def get_neighbors(self, curr_site: Dict, struct: PeriodicStructure) -&gt; List[Tuple]:\n    \"\"\"Builds a NeighborGraph from the provided structure according\n    to the cutoff distance of this Builder.\n\n    Parameters\n    ----------\n    struct : PeriodicStructure\n        The structure from which a NeighborGraph should be constructed.\n\n    Returns\n    -------\n    NeighborGraph\n        The resulting NeighborGraph\n    \"\"\"\n    nbs = []\n    curr_loc = curr_site[LOCATION]\n    curr_id = curr_site[SITE_ID]\n    for other_site in struct.sites():\n        other_id = other_site[SITE_ID]\n        if curr_id != other_id:\n            dist = struct.lattice.cartesian_periodic_distance(\n                other_site[LOCATION],\n                curr_loc,\n            )\n\n            if dist &lt; self.cutoff:\n                nbs.append((other_id, dist))\n\n    return nbs\n</code></pre>"},{"location":"reference/core/neighborhood_builders/#pylattica.core.neighborhood_builders.MotifNeighborhoodBuilder","title":"<code>MotifNeighborhoodBuilder</code>","text":"<p>         Bases: <code>NeighborhoodBuilder</code></p> <p>This NeighborhoodBuilder constructs NeighborGraphs with connections between points that are separated by one of a set of specific offset vectors.</p> <p>For example, consider a 2D structure with two types of sites, A and B. Each A site is connected to two other A sites, one offset by 1 unit in each of the positive and negative x directions. Each A site is also connected to two B sites, one offset by one unit in each of the positive and negative y directions, then the spec parameter for this arrangement would look as follows.</p> <pre><code>{\n    \"A\": [\n        [0, 1],\n        [1, 0],\n        [0, -1],\n        [-1, 0],\n    ],\n    \"B\": [\n        [0, 1],\n        [0, -1],\n    ]\n}\n</code></pre> <p>Note that there is reciprocity here between the A and B sites. The A sites list B sites as their neighbors, and the B sites list A sites as their neighbors.</p> Source code in <code>pylattica/core/neighborhood_builders.py</code> <pre><code>class MotifNeighborhoodBuilder(NeighborhoodBuilder):\n    \"\"\"This NeighborhoodBuilder constructs NeighborGraphs with connections between\n    points that are separated by one of a set of specific offset vectors.\n\n    For example, consider a 2D structure with two types of sites, A and B. Each A\n    site is connected to two other A sites, one offset by 1 unit in each of the positive\n    and negative x directions. Each A site is also connected to two B sites, one offset\n    by one unit in each of the positive and negative y directions, then the spec\n    parameter for this arrangement would look as follows.\n\n    ```\n    {\n        \"A\": [\n            [0, 1],\n            [1, 0],\n            [0, -1],\n            [-1, 0],\n        ],\n        \"B\": [\n            [0, 1],\n            [0, -1],\n        ]\n    }\n    ```\n\n    Note that there is reciprocity here between the A and B sites. The A sites\n    list B sites as their neighbors, and the B sites list A sites as their neighbors.\n    \"\"\"\n\n    def __init__(self, motif: List[List[float]]):\n        \"\"\"Instantiates the MotifNeighborhoodBuilder by a motif as described in\n        the docstring for the class.\n\n        Parameters\n        ----------\n        motif : Dict[str, List[List[float]]]\n            See class docstring.\n        \"\"\"\n        self._motif = motif\n\n        self.distances = EuclideanDistanceMap(motif)\n\n    def get_neighbors(self, curr_site: Dict, struct: PeriodicStructure) -&gt; List[Tuple]:\n        \"\"\"Given a structure, constructs a NeighborGraph with site connections\n        according to the motif.\n\n        Parameters\n        ----------\n        struct : PeriodicStructure\n            The structure for which a NeighborGraph should be constructed.\n\n        Returns\n        -------\n        NeighborGraph\n            The resulting NeighborGraph.\n        \"\"\"\n\n        location = curr_site[LOCATION]\n        nbs = []\n        for neighbor_vec in self._motif:\n            loc = tuple(s + n for s, n in zip(location, neighbor_vec))\n            nb_id = struct.id_at(loc)\n            if nb_id != curr_site[SITE_ID]:\n                nbs.append((nb_id, self.distances.get_dist(neighbor_vec)))\n        return nbs\n</code></pre>"},{"location":"reference/core/neighborhood_builders/#pylattica.core.neighborhood_builders.MotifNeighborhoodBuilder.__init__","title":"<code>__init__(motif)</code>","text":"<p>Instantiates the MotifNeighborhoodBuilder by a motif as described in the docstring for the class.</p>"},{"location":"reference/core/neighborhood_builders/#pylattica.core.neighborhood_builders.MotifNeighborhoodBuilder.__init__--parameters","title":"Parameters","text":"Dict[str, List[List[float]]] <p>See class docstring.</p> Source code in <code>pylattica/core/neighborhood_builders.py</code> <pre><code>def __init__(self, motif: List[List[float]]):\n    \"\"\"Instantiates the MotifNeighborhoodBuilder by a motif as described in\n    the docstring for the class.\n\n    Parameters\n    ----------\n    motif : Dict[str, List[List[float]]]\n        See class docstring.\n    \"\"\"\n    self._motif = motif\n\n    self.distances = EuclideanDistanceMap(motif)\n</code></pre>"},{"location":"reference/core/neighborhood_builders/#pylattica.core.neighborhood_builders.MotifNeighborhoodBuilder.get_neighbors","title":"<code>get_neighbors(curr_site, struct)</code>","text":"<p>Given a structure, constructs a NeighborGraph with site connections according to the motif.</p>"},{"location":"reference/core/neighborhood_builders/#pylattica.core.neighborhood_builders.MotifNeighborhoodBuilder.get_neighbors--parameters","title":"Parameters","text":"PeriodicStructure <p>The structure for which a NeighborGraph should be constructed.</p>"},{"location":"reference/core/neighborhood_builders/#pylattica.core.neighborhood_builders.MotifNeighborhoodBuilder.get_neighbors--returns","title":"Returns","text":"<p>NeighborGraph     The resulting NeighborGraph.</p> Source code in <code>pylattica/core/neighborhood_builders.py</code> <pre><code>def get_neighbors(self, curr_site: Dict, struct: PeriodicStructure) -&gt; List[Tuple]:\n    \"\"\"Given a structure, constructs a NeighborGraph with site connections\n    according to the motif.\n\n    Parameters\n    ----------\n    struct : PeriodicStructure\n        The structure for which a NeighborGraph should be constructed.\n\n    Returns\n    -------\n    NeighborGraph\n        The resulting NeighborGraph.\n    \"\"\"\n\n    location = curr_site[LOCATION]\n    nbs = []\n    for neighbor_vec in self._motif:\n        loc = tuple(s + n for s, n in zip(location, neighbor_vec))\n        nb_id = struct.id_at(loc)\n        if nb_id != curr_site[SITE_ID]:\n            nbs.append((nb_id, self.distances.get_dist(neighbor_vec)))\n    return nbs\n</code></pre>"},{"location":"reference/core/neighborhood_builders/#pylattica.core.neighborhood_builders.NeighborhoodBuilder","title":"<code>NeighborhoodBuilder</code>","text":"<p>An abstract class to extend in order to implement a new type of NeighborhoodBuilder</p> Source code in <code>pylattica/core/neighborhood_builders.py</code> <pre><code>class NeighborhoodBuilder:\n    \"\"\"An abstract class to extend in order to implement a new type of\n    NeighborhoodBuilder\"\"\"\n\n    def get(self, struct: PeriodicStructure, site_class: str = None) -&gt; Neighborhood:\n        \"\"\"Given a structure and a site class to build a neighborhood for,\n        build the neighborhood.\n\n        Parameters\n        ----------\n        struct : PeriodicStructure\n            The structure for which the Neighborhood of every site should be\n            calculated\n        site_class : str, optional\n            Specify a single class of sites to calculate the neighborhood for,\n            by default None\n\n        Returns\n        -------\n        Neighborhood\n            _description_\n        \"\"\"\n        graph = rx.PyDiGraph()\n\n        if site_class is None:\n            sites = struct.sites()\n        else:\n            sites = struct.sites(site_class=site_class)\n\n        for site in struct.sites():\n            graph.add_node(site[SITE_ID])\n\n        for curr_site in tqdm(sites):\n            nbs = self.get_neighbors(curr_site, struct)\n            for nb_id, weight in nbs:\n                graph.add_edge(curr_site[SITE_ID], nb_id, weight)\n\n        return Neighborhood(graph)\n\n    @abstractmethod\n    def get_neighbors(self, curr_site: Dict, struct: PeriodicStructure) -&gt; List[Tuple]:\n        pass  # pragma: no cover\n</code></pre>"},{"location":"reference/core/neighborhood_builders/#pylattica.core.neighborhood_builders.NeighborhoodBuilder.get","title":"<code>get(struct, site_class=None)</code>","text":"<p>Given a structure and a site class to build a neighborhood for, build the neighborhood.</p>"},{"location":"reference/core/neighborhood_builders/#pylattica.core.neighborhood_builders.NeighborhoodBuilder.get--parameters","title":"Parameters","text":"PeriodicStructure <p>The structure for which the Neighborhood of every site should be calculated</p> str, optional <p>Specify a single class of sites to calculate the neighborhood for, by default None</p>"},{"location":"reference/core/neighborhood_builders/#pylattica.core.neighborhood_builders.NeighborhoodBuilder.get--returns","title":"Returns","text":"<p>Neighborhood     description</p> Source code in <code>pylattica/core/neighborhood_builders.py</code> <pre><code>def get(self, struct: PeriodicStructure, site_class: str = None) -&gt; Neighborhood:\n    \"\"\"Given a structure and a site class to build a neighborhood for,\n    build the neighborhood.\n\n    Parameters\n    ----------\n    struct : PeriodicStructure\n        The structure for which the Neighborhood of every site should be\n        calculated\n    site_class : str, optional\n        Specify a single class of sites to calculate the neighborhood for,\n        by default None\n\n    Returns\n    -------\n    Neighborhood\n        _description_\n    \"\"\"\n    graph = rx.PyDiGraph()\n\n    if site_class is None:\n        sites = struct.sites()\n    else:\n        sites = struct.sites(site_class=site_class)\n\n    for site in struct.sites():\n        graph.add_node(site[SITE_ID])\n\n    for curr_site in tqdm(sites):\n        nbs = self.get_neighbors(curr_site, struct)\n        for nb_id, weight in nbs:\n            graph.add_edge(curr_site[SITE_ID], nb_id, weight)\n\n    return Neighborhood(graph)\n</code></pre>"},{"location":"reference/core/neighborhood_builders/#pylattica.core.neighborhood_builders.SiteClassNeighborhoodBuilder","title":"<code>SiteClassNeighborhoodBuilder</code>","text":"<p>         Bases: <code>NeighborhoodBuilder</code></p> <p>A class which constructs the neighborhood of each site as a function of the class of that site.</p> Source code in <code>pylattica/core/neighborhood_builders.py</code> <pre><code>class SiteClassNeighborhoodBuilder(NeighborhoodBuilder):\n    \"\"\"A class which constructs the neighborhood of each site as a function\n    of the class of that site.\"\"\"\n\n    def __init__(self, nb_builders: Dict[str, NeighborhoodBuilder]):\n        \"\"\"Instantiates the SiteClassNeighborhoodBuilder.\n\n        Parameters\n        ----------\n        nb_builders : Dict[str, NeighborhoodBuilder]\n            A mapping of site classes to the NeighborhoodBuilders which\n            specify what neighborhood that class of sites should have.\n        \"\"\"\n        self._builders = nb_builders\n\n    def get(self, struct: PeriodicStructure) -&gt; Neighborhood:\n        \"\"\"Constructs the neighborhood of every site in the provided\n        structure, conditional on the class of each site.\n\n        Parameters\n        ----------\n        struct : PeriodicStructure\n            The structure for which the neigborhood should be calculated.\n\n        Returns\n        -------\n        Neighborhood\n            The resulting Neighborhood object.\n        \"\"\"\n        nbhood_map = {}\n        for sclass, builder in self._builders.items():\n            nbhood = builder.get(struct, site_class=sclass)\n            nbhood_map[sclass] = nbhood\n\n        return SiteClassNeighborhood(struct, nbhood_map)\n</code></pre>"},{"location":"reference/core/neighborhood_builders/#pylattica.core.neighborhood_builders.SiteClassNeighborhoodBuilder.__init__","title":"<code>__init__(nb_builders)</code>","text":"<p>Instantiates the SiteClassNeighborhoodBuilder.</p>"},{"location":"reference/core/neighborhood_builders/#pylattica.core.neighborhood_builders.SiteClassNeighborhoodBuilder.__init__--parameters","title":"Parameters","text":"Dict[str, NeighborhoodBuilder] <p>A mapping of site classes to the NeighborhoodBuilders which specify what neighborhood that class of sites should have.</p> Source code in <code>pylattica/core/neighborhood_builders.py</code> <pre><code>def __init__(self, nb_builders: Dict[str, NeighborhoodBuilder]):\n    \"\"\"Instantiates the SiteClassNeighborhoodBuilder.\n\n    Parameters\n    ----------\n    nb_builders : Dict[str, NeighborhoodBuilder]\n        A mapping of site classes to the NeighborhoodBuilders which\n        specify what neighborhood that class of sites should have.\n    \"\"\"\n    self._builders = nb_builders\n</code></pre>"},{"location":"reference/core/neighborhood_builders/#pylattica.core.neighborhood_builders.SiteClassNeighborhoodBuilder.get","title":"<code>get(struct)</code>","text":"<p>Constructs the neighborhood of every site in the provided structure, conditional on the class of each site.</p>"},{"location":"reference/core/neighborhood_builders/#pylattica.core.neighborhood_builders.SiteClassNeighborhoodBuilder.get--parameters","title":"Parameters","text":"PeriodicStructure <p>The structure for which the neigborhood should be calculated.</p>"},{"location":"reference/core/neighborhood_builders/#pylattica.core.neighborhood_builders.SiteClassNeighborhoodBuilder.get--returns","title":"Returns","text":"<p>Neighborhood     The resulting Neighborhood object.</p> Source code in <code>pylattica/core/neighborhood_builders.py</code> <pre><code>def get(self, struct: PeriodicStructure) -&gt; Neighborhood:\n    \"\"\"Constructs the neighborhood of every site in the provided\n    structure, conditional on the class of each site.\n\n    Parameters\n    ----------\n    struct : PeriodicStructure\n        The structure for which the neigborhood should be calculated.\n\n    Returns\n    -------\n    Neighborhood\n        The resulting Neighborhood object.\n    \"\"\"\n    nbhood_map = {}\n    for sclass, builder in self._builders.items():\n        nbhood = builder.get(struct, site_class=sclass)\n        nbhood_map[sclass] = nbhood\n\n    return SiteClassNeighborhood(struct, nbhood_map)\n</code></pre>"},{"location":"reference/core/neighborhood_builders/#pylattica.core.neighborhood_builders.StochasticNeighborhoodBuilder","title":"<code>StochasticNeighborhoodBuilder</code>","text":"<p>         Bases: <code>NeighborhoodBuilder</code></p> <p>A helper class for building StochasticNeighborhoods - that is, neighborhoods for which one of several random neighbor sets is chosen each time a site's neighbors are requested.</p> Source code in <code>pylattica/core/neighborhood_builders.py</code> <pre><code>class StochasticNeighborhoodBuilder(NeighborhoodBuilder):\n    \"\"\"A helper class for building StochasticNeighborhoods - that is,\n    neighborhoods for which one of several random neighbor sets is chosen\n    each time a site's neighbors are requested.\"\"\"\n\n    def __init__(self, builders: List[NeighborhoodBuilder]):\n        \"\"\"Instantiates the StochasticNeighborhoodBuilder class.\n\n        Parameters\n        ----------\n        builders : List[NeighborhoodBuilder]\n            A list of builders which will give the neighborhoods that\n            might be returned by the StochasticNeighborhood\n        \"\"\"\n        self.builders = builders\n\n    def get(self, struct: PeriodicStructure) -&gt; Neighborhood:\n        \"\"\"For the provided structure, calculate the StochasticNeighborhood\n        specified by the list of builders originally provided to this class.\n\n        Parameters\n        ----------\n        struct : PeriodicStructure\n            The structure for which the neighborhood should be calculated.\n\n        Returns\n        -------\n        Neighborhood\n            The resulting StochasticNeighborhood\n        \"\"\"\n        return StochasticNeighborhood([b.get(struct) for b in self.builders])\n</code></pre>"},{"location":"reference/core/neighborhood_builders/#pylattica.core.neighborhood_builders.StochasticNeighborhoodBuilder.__init__","title":"<code>__init__(builders)</code>","text":"<p>Instantiates the StochasticNeighborhoodBuilder class.</p>"},{"location":"reference/core/neighborhood_builders/#pylattica.core.neighborhood_builders.StochasticNeighborhoodBuilder.__init__--parameters","title":"Parameters","text":"List[NeighborhoodBuilder] <p>A list of builders which will give the neighborhoods that might be returned by the StochasticNeighborhood</p> Source code in <code>pylattica/core/neighborhood_builders.py</code> <pre><code>def __init__(self, builders: List[NeighborhoodBuilder]):\n    \"\"\"Instantiates the StochasticNeighborhoodBuilder class.\n\n    Parameters\n    ----------\n    builders : List[NeighborhoodBuilder]\n        A list of builders which will give the neighborhoods that\n        might be returned by the StochasticNeighborhood\n    \"\"\"\n    self.builders = builders\n</code></pre>"},{"location":"reference/core/neighborhood_builders/#pylattica.core.neighborhood_builders.StochasticNeighborhoodBuilder.get","title":"<code>get(struct)</code>","text":"<p>For the provided structure, calculate the StochasticNeighborhood specified by the list of builders originally provided to this class.</p>"},{"location":"reference/core/neighborhood_builders/#pylattica.core.neighborhood_builders.StochasticNeighborhoodBuilder.get--parameters","title":"Parameters","text":"PeriodicStructure <p>The structure for which the neighborhood should be calculated.</p>"},{"location":"reference/core/neighborhood_builders/#pylattica.core.neighborhood_builders.StochasticNeighborhoodBuilder.get--returns","title":"Returns","text":"<p>Neighborhood     The resulting StochasticNeighborhood</p> Source code in <code>pylattica/core/neighborhood_builders.py</code> <pre><code>def get(self, struct: PeriodicStructure) -&gt; Neighborhood:\n    \"\"\"For the provided structure, calculate the StochasticNeighborhood\n    specified by the list of builders originally provided to this class.\n\n    Parameters\n    ----------\n    struct : PeriodicStructure\n        The structure for which the neighborhood should be calculated.\n\n    Returns\n    -------\n    Neighborhood\n        The resulting StochasticNeighborhood\n    \"\"\"\n    return StochasticNeighborhood([b.get(struct) for b in self.builders])\n</code></pre>"},{"location":"reference/core/periodic_structure/","title":"PeriodicStructure","text":""},{"location":"reference/core/periodic_structure/#pylattica.core.periodic_structure.PeriodicStructure","title":"<code>PeriodicStructure</code>","text":"<p>Represents a periodic arrangement of sites. Assigns identifiers to sites so that they can be referred to elsewhere.</p> <p>Supports retrieving sites by identifier or by location.</p>"},{"location":"reference/core/periodic_structure/#pylattica.core.periodic_structure.PeriodicStructure--attributes","title":"Attributes","text":"Lattice <p>The periodic lattice in which this structure exists</p> int <p>The dimensionality of the structure</p> Source code in <code>pylattica/core/periodic_structure.py</code> <pre><code>class PeriodicStructure:\n    \"\"\"\n    Represents a periodic arrangement of sites. Assigns\n    identifiers to sites so that they can be referred to elsewhere.\n\n    Supports retrieving sites by identifier or by location.\n\n    Attributes\n    ----------\n    lattice : Lattice\n        The periodic lattice in which this structure exists\n    dim : int\n        The dimensionality of the structure\n    \"\"\"\n\n    @classmethod\n    def build_from(\n        _,\n        lattice: Lattice,\n        num_cells: List[int],\n        site_motif: Union[Dict, List],\n        frac_coords: bool = False,\n    ):\n        \"\"\"Builds a PeriodicStructure by repeating the unit cell num_cell times\n        in each dimension. For instance, to build a structure that has 2 unit cells in\n        each direction (and itself is three dimensional), the num_cells parameter should be\n\n        [2, 2, 2]\n\n        Lattice sites must also be specified by the site_motif parameter. This allows\n        specification of which sites are where in the unit cell. For instance, if my 2D\n        lattice has two types of sites, A and B, and each type exists in two different\n        places, I might use the following site_motif:\n\n        {\n            \"A\": [\n                [0.2, 0.2],\n                [0.4, 0.4]\n            ],\n            \"B\": [\n                [0.6, 0.6],\n                [0.8, 0.8]\n            ]\n        }\n\n        Parameters\n        ----------\n        num_cells : List[int]\n            As described above, a list of the number of repetitions of the unit cell\n            in each direction.\n        site_motif : dict\n            A dictionary mapping string site classes to lists of the locations within\n            the unit cell at which a site of that type exists.\n\n        Returns\n        -------\n        PeriodicStructure\n            The structure resulting from the lattice tiling and motif filling specified.\n        \"\"\"\n        new_lattice = lattice.get_scaled_lattice(num_cells)\n\n        struct = PeriodicStructure(new_lattice)\n\n        if not isinstance(site_motif, dict):\n            site_motif = {DEFAULT_SITE_CLASS: site_motif}\n\n        # these are in \"fractional\" coordinates\n        vec_coeffs = get_points_in_box([0 for _ in range(new_lattice.dim)], num_cells)\n        for vec_coeff_set in vec_coeffs:\n            if not frac_coords:  # convert lattice points to \"cartesian coordinates\"\n                point = lattice.matrix @ np.array(vec_coeff_set)\n            else:\n                point = np.array(vec_coeff_set)\n\n            for site_class, basis_vecs in site_motif.items():\n                for vec in basis_vecs:\n                    # if the motif is specified in cartesian coordinates, we're good here\n                    site_loc = tuple(point + np.array(vec))\n\n                    if (\n                        frac_coords\n                    ):  # convert lattice point back to cartesian coordinates\n                        site_loc = lattice.get_cartesian_coords(site_loc)\n\n                    # site_loc should be in cartesian coordinates at this point\n                    struct.add_site(site_class, site_loc)\n\n        return struct\n\n    def __init__(self, lattice: Lattice):\n        \"\"\"Instantiates a structure with the specified lattice.\n        The dimensionaliity is inferred by the dimensionality of the lattice.\n\n        Parameters\n        ----------\n        lattice : Lattice\n            _description_\n        \"\"\"\n        self.lattice = lattice\n        self.dim = lattice.dim\n        self._sites = {}\n        self.site_ids = []\n        self._location_lookup = {}\n        self._offset_vector = np.array([VEC_OFFSET for _ in range(self.dim)])\n\n    def as_dict(self):\n        copied = copy.deepcopy(self._sites)\n        for _, site in copied.items():\n            site[LOCATION] = site[LOCATION].tolist()\n\n        return {\n            \"lattice\": self.lattice.as_dict(),\n            \"_sites\": copied,\n        }\n\n    @classmethod\n    def from_dict(cls, d):\n        struct = cls(Lattice.from_dict(d[\"lattice\"]))\n        sites = {int(k): v for k, v in d[\"_sites\"].items()}\n\n        for _, site in sites.items():\n            struct.add_site(site[SITE_CLASS], site[LOCATION])\n\n        return struct\n\n    def _get_rounded_coords(self, location: Iterable[float]) -&gt; Iterable[float]:\n        return np.round(location, OFFSET_PRECISION)\n\n    def _coords_with_offset(self, location: Iterable[float]) -&gt; Iterable[float]:\n        return self._get_rounded_coords(location + self._offset_vector)\n\n    def _transformed_coords(self, location: Iterable[float]) -&gt; Iterable[float]:\n        periodized_coords = self.lattice.get_periodized_cartesian_coords(location)\n        offset_periodized_coords = self._coords_with_offset(periodized_coords)\n        return offset_periodized_coords\n\n    def add_site(self, site_class: str, location: Tuple[float]) -&gt; int:\n        \"\"\"Adds a new site to the structure.\n\n        Parameters\n        ----------\n        site_class : str\n            The class of the site to be added. This can be anything, but must be provided\n            Think of this as a tag for the site\n        location : Tuple[float]\n            The location of the new site in Cartesian coordinates\n\n        Returns\n        -------\n        int\n            The ID of the site. This can be used to retrieve the site later\n        \"\"\"\n        new_site_id = len(self._sites)\n\n        periodized_coords = self._get_rounded_coords(\n            self.lattice.get_periodized_cartesian_coords(location)\n        )\n        offset_periodized_coords = tuple(self._transformed_coords(location))\n\n        assert (\n            self._location_lookup.get(offset_periodized_coords, None) is None\n        ), \"That site is already occupied\"\n\n        self._sites[new_site_id] = {\n            SITE_CLASS: site_class,\n            LOCATION: periodized_coords,\n            SITE_ID: new_site_id,\n        }\n\n        self._location_lookup[offset_periodized_coords] = new_site_id\n        self.site_ids.append(new_site_id)\n        return new_site_id\n\n    def site_at(self, location: Tuple[float]) -&gt; Dict:\n        \"\"\"Retrieves the site at a particular location. Uses float equality to check.\n\n        Parameters\n        ----------\n        location : Tuple[float]\n            The location of the desired site\n\n        Returns\n        -------\n        int\n            A dictionary with keys \"site_class\", \"location\", and \"id\" representing the site.\n        \"\"\"\n        _transformed_coords = tuple(self._transformed_coords(location))\n        site_id = self._location_lookup.get(_transformed_coords)\n\n        if site_id is not None:\n            return self.get_site(site_id)\n        else:\n            return None\n\n    def id_at(self, location: Tuple[float]) -&gt; Dict:\n        site = self.site_at(location)\n        if site is None:\n            return None\n        else:\n            return site[SITE_ID]\n\n    def class_at(self, location: Tuple[float]) -&gt; Dict:\n        site = self.site_at(location)\n        if site is None:\n            return None\n        else:\n            return site[SITE_CLASS]\n\n    def site_class(self, site_id: int) -&gt; str:\n        return self.get_site(site_id)[SITE_CLASS]\n\n    def site_location(self, site_id: int) -&gt; str:\n        return self.get_site(site_id)[LOCATION]\n\n    def get_site(self, site_id: int) -&gt; Dict:\n        \"\"\"Returns the site with the specified ID.\n\n        Parameters\n        ----------\n        site_id : int\n            The ID of the desired site.\n\n        Returns\n        -------\n        Dict\n            A dictionary with keys \"site_class\", \"location\", and \"id\" representing the site.\n        \"\"\"\n        return self._sites.get(site_id)\n\n    def all_site_classes(self) -&gt; List[str]:\n        \"\"\"Returns a list of all the site classes present in this structure.\n\n        Returns\n        -------\n        List[str]\n            The site classes in this structure. Each class appears once in this list.\n        \"\"\"\n        return list({site[SITE_CLASS] for site in self.sites()})\n\n    def sites(self, site_class: str = None) -&gt; List[Dict]:\n        \"\"\"Returns a list of the sites with the specified site class.\n\n        Parameters\n        ----------\n        site_class : str, optional\n            The desired site class, by default None\n\n        Returns\n        -------\n        List[Dict]\n            A list of the sites matching that site class.\n        \"\"\"\n        all_sites = list(self._sites.values())\n        if site_class is None:\n            return all_sites\n\n        return [site for site in all_sites if site[SITE_CLASS] == site_class]\n</code></pre>"},{"location":"reference/core/periodic_structure/#pylattica.core.periodic_structure.PeriodicStructure.__init__","title":"<code>__init__(lattice)</code>","text":"<p>Instantiates a structure with the specified lattice. The dimensionaliity is inferred by the dimensionality of the lattice.</p>"},{"location":"reference/core/periodic_structure/#pylattica.core.periodic_structure.PeriodicStructure.__init__--parameters","title":"Parameters","text":"Lattice <p>description</p> Source code in <code>pylattica/core/periodic_structure.py</code> <pre><code>def __init__(self, lattice: Lattice):\n    \"\"\"Instantiates a structure with the specified lattice.\n    The dimensionaliity is inferred by the dimensionality of the lattice.\n\n    Parameters\n    ----------\n    lattice : Lattice\n        _description_\n    \"\"\"\n    self.lattice = lattice\n    self.dim = lattice.dim\n    self._sites = {}\n    self.site_ids = []\n    self._location_lookup = {}\n    self._offset_vector = np.array([VEC_OFFSET for _ in range(self.dim)])\n</code></pre>"},{"location":"reference/core/periodic_structure/#pylattica.core.periodic_structure.PeriodicStructure.add_site","title":"<code>add_site(site_class, location)</code>","text":"<p>Adds a new site to the structure.</p>"},{"location":"reference/core/periodic_structure/#pylattica.core.periodic_structure.PeriodicStructure.add_site--parameters","title":"Parameters","text":"str <p>The class of the site to be added. This can be anything, but must be provided Think of this as a tag for the site</p> Tuple[float] <p>The location of the new site in Cartesian coordinates</p>"},{"location":"reference/core/periodic_structure/#pylattica.core.periodic_structure.PeriodicStructure.add_site--returns","title":"Returns","text":"<p>int     The ID of the site. This can be used to retrieve the site later</p> Source code in <code>pylattica/core/periodic_structure.py</code> <pre><code>def add_site(self, site_class: str, location: Tuple[float]) -&gt; int:\n    \"\"\"Adds a new site to the structure.\n\n    Parameters\n    ----------\n    site_class : str\n        The class of the site to be added. This can be anything, but must be provided\n        Think of this as a tag for the site\n    location : Tuple[float]\n        The location of the new site in Cartesian coordinates\n\n    Returns\n    -------\n    int\n        The ID of the site. This can be used to retrieve the site later\n    \"\"\"\n    new_site_id = len(self._sites)\n\n    periodized_coords = self._get_rounded_coords(\n        self.lattice.get_periodized_cartesian_coords(location)\n    )\n    offset_periodized_coords = tuple(self._transformed_coords(location))\n\n    assert (\n        self._location_lookup.get(offset_periodized_coords, None) is None\n    ), \"That site is already occupied\"\n\n    self._sites[new_site_id] = {\n        SITE_CLASS: site_class,\n        LOCATION: periodized_coords,\n        SITE_ID: new_site_id,\n    }\n\n    self._location_lookup[offset_periodized_coords] = new_site_id\n    self.site_ids.append(new_site_id)\n    return new_site_id\n</code></pre>"},{"location":"reference/core/periodic_structure/#pylattica.core.periodic_structure.PeriodicStructure.all_site_classes","title":"<code>all_site_classes()</code>","text":"<p>Returns a list of all the site classes present in this structure.</p>"},{"location":"reference/core/periodic_structure/#pylattica.core.periodic_structure.PeriodicStructure.all_site_classes--returns","title":"Returns","text":"<p>List[str]     The site classes in this structure. Each class appears once in this list.</p> Source code in <code>pylattica/core/periodic_structure.py</code> <pre><code>def all_site_classes(self) -&gt; List[str]:\n    \"\"\"Returns a list of all the site classes present in this structure.\n\n    Returns\n    -------\n    List[str]\n        The site classes in this structure. Each class appears once in this list.\n    \"\"\"\n    return list({site[SITE_CLASS] for site in self.sites()})\n</code></pre>"},{"location":"reference/core/periodic_structure/#pylattica.core.periodic_structure.PeriodicStructure.build_from","title":"<code>build_from(_, lattice, num_cells, site_motif, frac_coords=False)</code>  <code>classmethod</code>","text":"<p>Builds a PeriodicStructure by repeating the unit cell num_cell times in each dimension. For instance, to build a structure that has 2 unit cells in each direction (and itself is three dimensional), the num_cells parameter should be</p> <p>[2, 2, 2]</p> <p>Lattice sites must also be specified by the site_motif parameter. This allows specification of which sites are where in the unit cell. For instance, if my 2D lattice has two types of sites, A and B, and each type exists in two different places, I might use the following site_motif:</p> <p>{     \"A\": [         [0.2, 0.2],         [0.4, 0.4]     ],     \"B\": [         [0.6, 0.6],         [0.8, 0.8]     ] }</p>"},{"location":"reference/core/periodic_structure/#pylattica.core.periodic_structure.PeriodicStructure.build_from--parameters","title":"Parameters","text":"List[int] <p>As described above, a list of the number of repetitions of the unit cell in each direction.</p> dict <p>A dictionary mapping string site classes to lists of the locations within the unit cell at which a site of that type exists.</p>"},{"location":"reference/core/periodic_structure/#pylattica.core.periodic_structure.PeriodicStructure.build_from--returns","title":"Returns","text":"<p>PeriodicStructure     The structure resulting from the lattice tiling and motif filling specified.</p> Source code in <code>pylattica/core/periodic_structure.py</code> <pre><code>@classmethod\ndef build_from(\n    _,\n    lattice: Lattice,\n    num_cells: List[int],\n    site_motif: Union[Dict, List],\n    frac_coords: bool = False,\n):\n    \"\"\"Builds a PeriodicStructure by repeating the unit cell num_cell times\n    in each dimension. For instance, to build a structure that has 2 unit cells in\n    each direction (and itself is three dimensional), the num_cells parameter should be\n\n    [2, 2, 2]\n\n    Lattice sites must also be specified by the site_motif parameter. This allows\n    specification of which sites are where in the unit cell. For instance, if my 2D\n    lattice has two types of sites, A and B, and each type exists in two different\n    places, I might use the following site_motif:\n\n    {\n        \"A\": [\n            [0.2, 0.2],\n            [0.4, 0.4]\n        ],\n        \"B\": [\n            [0.6, 0.6],\n            [0.8, 0.8]\n        ]\n    }\n\n    Parameters\n    ----------\n    num_cells : List[int]\n        As described above, a list of the number of repetitions of the unit cell\n        in each direction.\n    site_motif : dict\n        A dictionary mapping string site classes to lists of the locations within\n        the unit cell at which a site of that type exists.\n\n    Returns\n    -------\n    PeriodicStructure\n        The structure resulting from the lattice tiling and motif filling specified.\n    \"\"\"\n    new_lattice = lattice.get_scaled_lattice(num_cells)\n\n    struct = PeriodicStructure(new_lattice)\n\n    if not isinstance(site_motif, dict):\n        site_motif = {DEFAULT_SITE_CLASS: site_motif}\n\n    # these are in \"fractional\" coordinates\n    vec_coeffs = get_points_in_box([0 for _ in range(new_lattice.dim)], num_cells)\n    for vec_coeff_set in vec_coeffs:\n        if not frac_coords:  # convert lattice points to \"cartesian coordinates\"\n            point = lattice.matrix @ np.array(vec_coeff_set)\n        else:\n            point = np.array(vec_coeff_set)\n\n        for site_class, basis_vecs in site_motif.items():\n            for vec in basis_vecs:\n                # if the motif is specified in cartesian coordinates, we're good here\n                site_loc = tuple(point + np.array(vec))\n\n                if (\n                    frac_coords\n                ):  # convert lattice point back to cartesian coordinates\n                    site_loc = lattice.get_cartesian_coords(site_loc)\n\n                # site_loc should be in cartesian coordinates at this point\n                struct.add_site(site_class, site_loc)\n\n    return struct\n</code></pre>"},{"location":"reference/core/periodic_structure/#pylattica.core.periodic_structure.PeriodicStructure.get_site","title":"<code>get_site(site_id)</code>","text":"<p>Returns the site with the specified ID.</p>"},{"location":"reference/core/periodic_structure/#pylattica.core.periodic_structure.PeriodicStructure.get_site--parameters","title":"Parameters","text":"int <p>The ID of the desired site.</p>"},{"location":"reference/core/periodic_structure/#pylattica.core.periodic_structure.PeriodicStructure.get_site--returns","title":"Returns","text":"<p>Dict     A dictionary with keys \"site_class\", \"location\", and \"id\" representing the site.</p> Source code in <code>pylattica/core/periodic_structure.py</code> <pre><code>def get_site(self, site_id: int) -&gt; Dict:\n    \"\"\"Returns the site with the specified ID.\n\n    Parameters\n    ----------\n    site_id : int\n        The ID of the desired site.\n\n    Returns\n    -------\n    Dict\n        A dictionary with keys \"site_class\", \"location\", and \"id\" representing the site.\n    \"\"\"\n    return self._sites.get(site_id)\n</code></pre>"},{"location":"reference/core/periodic_structure/#pylattica.core.periodic_structure.PeriodicStructure.site_at","title":"<code>site_at(location)</code>","text":"<p>Retrieves the site at a particular location. Uses float equality to check.</p>"},{"location":"reference/core/periodic_structure/#pylattica.core.periodic_structure.PeriodicStructure.site_at--parameters","title":"Parameters","text":"Tuple[float] <p>The location of the desired site</p>"},{"location":"reference/core/periodic_structure/#pylattica.core.periodic_structure.PeriodicStructure.site_at--returns","title":"Returns","text":"<p>int     A dictionary with keys \"site_class\", \"location\", and \"id\" representing the site.</p> Source code in <code>pylattica/core/periodic_structure.py</code> <pre><code>def site_at(self, location: Tuple[float]) -&gt; Dict:\n    \"\"\"Retrieves the site at a particular location. Uses float equality to check.\n\n    Parameters\n    ----------\n    location : Tuple[float]\n        The location of the desired site\n\n    Returns\n    -------\n    int\n        A dictionary with keys \"site_class\", \"location\", and \"id\" representing the site.\n    \"\"\"\n    _transformed_coords = tuple(self._transformed_coords(location))\n    site_id = self._location_lookup.get(_transformed_coords)\n\n    if site_id is not None:\n        return self.get_site(site_id)\n    else:\n        return None\n</code></pre>"},{"location":"reference/core/periodic_structure/#pylattica.core.periodic_structure.PeriodicStructure.sites","title":"<code>sites(site_class=None)</code>","text":"<p>Returns a list of the sites with the specified site class.</p>"},{"location":"reference/core/periodic_structure/#pylattica.core.periodic_structure.PeriodicStructure.sites--parameters","title":"Parameters","text":"str, optional <p>The desired site class, by default None</p>"},{"location":"reference/core/periodic_structure/#pylattica.core.periodic_structure.PeriodicStructure.sites--returns","title":"Returns","text":"<p>List[Dict]     A list of the sites matching that site class.</p> Source code in <code>pylattica/core/periodic_structure.py</code> <pre><code>def sites(self, site_class: str = None) -&gt; List[Dict]:\n    \"\"\"Returns a list of the sites with the specified site class.\n\n    Parameters\n    ----------\n    site_class : str, optional\n        The desired site class, by default None\n\n    Returns\n    -------\n    List[Dict]\n        A list of the sites matching that site class.\n    \"\"\"\n    all_sites = list(self._sites.values())\n    if site_class is None:\n        return all_sites\n\n    return [site for site in all_sites if site[SITE_CLASS] == site_class]\n</code></pre>"},{"location":"reference/core/simulation/","title":"Simulation","text":""},{"location":"reference/core/simulation/#pylattica.core.simulation.Simulation","title":"<code>Simulation</code>","text":"<p>A wrapper class for binding a SimulationState to the structure with which it belongs. Simplifies actions like retrieving simulation state based on site location.</p> Source code in <code>pylattica/core/simulation.py</code> <pre><code>class Simulation:\n    \"\"\"A wrapper class for binding a SimulationState to the structure\n    with which it belongs. Simplifies actions like retrieving simulation\n    state based on site location.\n    \"\"\"\n\n    def __init__(self, state: SimulationState, structure: PeriodicStructure):\n        \"\"\"Instantiates a Simulation with the provided state and structure.\n\n        Parameters\n        ----------\n        state : SimulationState\n            The SimulationState\n        structure : PeriodicStructure\n            The structure to which the SimulationState site IDs refer.\n        \"\"\"\n        self.state = state\n        self.structure = structure\n\n    def as_dict(self):\n        res = {\"state\": self.state.as_dict(), \"structure\": self.structure.as_dict()}\n        return res\n\n    def to_file(self, fname):\n        with open(fname, \"w+\", encoding=\"utf-8\") as f:\n            json.dump(self.as_dict(), f)\n\n    @classmethod\n    def from_dict(cls, d):\n        state = SimulationState.from_dict(d[\"state\"])\n        structure = PeriodicStructure.from_dict(d[\"structure\"])\n        return cls(state, structure)\n\n    @classmethod\n    def from_file(cls, fname):\n        with open(fname, \"r+\", encoding=\"utf-8\") as f:\n            d = json.load(f)\n            return cls.from_dict(d)\n\n    def state_at(self, location: Tuple[float]) -&gt; Dict:\n        \"\"\"Retrieves the state of the site at the requested location.\n\n        Parameters\n        ----------\n        location : Tuple[float]\n            The location of the desired site\n\n        Returns\n        -------\n        Dict\n            The state of the found site.\n        \"\"\"\n        site = self.structure.site_at(location)\n\n        if site is None:\n            return None\n\n        site_state = self.state.get_site_state(site[SITE_ID])\n        return site_state\n</code></pre>"},{"location":"reference/core/simulation/#pylattica.core.simulation.Simulation.__init__","title":"<code>__init__(state, structure)</code>","text":"<p>Instantiates a Simulation with the provided state and structure.</p>"},{"location":"reference/core/simulation/#pylattica.core.simulation.Simulation.__init__--parameters","title":"Parameters","text":"SimulationState <p>The SimulationState</p> PeriodicStructure <p>The structure to which the SimulationState site IDs refer.</p> Source code in <code>pylattica/core/simulation.py</code> <pre><code>def __init__(self, state: SimulationState, structure: PeriodicStructure):\n    \"\"\"Instantiates a Simulation with the provided state and structure.\n\n    Parameters\n    ----------\n    state : SimulationState\n        The SimulationState\n    structure : PeriodicStructure\n        The structure to which the SimulationState site IDs refer.\n    \"\"\"\n    self.state = state\n    self.structure = structure\n</code></pre>"},{"location":"reference/core/simulation/#pylattica.core.simulation.Simulation.state_at","title":"<code>state_at(location)</code>","text":"<p>Retrieves the state of the site at the requested location.</p>"},{"location":"reference/core/simulation/#pylattica.core.simulation.Simulation.state_at--parameters","title":"Parameters","text":"Tuple[float] <p>The location of the desired site</p>"},{"location":"reference/core/simulation/#pylattica.core.simulation.Simulation.state_at--returns","title":"Returns","text":"<p>Dict     The state of the found site.</p> Source code in <code>pylattica/core/simulation.py</code> <pre><code>def state_at(self, location: Tuple[float]) -&gt; Dict:\n    \"\"\"Retrieves the state of the site at the requested location.\n\n    Parameters\n    ----------\n    location : Tuple[float]\n        The location of the desired site\n\n    Returns\n    -------\n    Dict\n        The state of the found site.\n    \"\"\"\n    site = self.structure.site_at(location)\n\n    if site is None:\n        return None\n\n    site_state = self.state.get_site_state(site[SITE_ID])\n    return site_state\n</code></pre>"},{"location":"reference/core/simulation_result/","title":"SimulationResult","text":""},{"location":"reference/core/simulation_result/#pylattica.core.simulation_result.SimulationResult","title":"<code>SimulationResult</code>","text":"<p>A class that stores the result of running a simulation.</p>"},{"location":"reference/core/simulation_result/#pylattica.core.simulation_result.SimulationResult--attributes","title":"Attributes","text":"SimulationState <p>The state with which the simulation started.</p> Source code in <code>pylattica/core/simulation_result.py</code> <pre><code>class SimulationResult:\n    \"\"\"A class that stores the result of running a simulation.\n\n    Attributes\n    ----------\n    initial_state : SimulationState\n        The state with which the simulation started.\n    \"\"\"\n\n    @classmethod\n    def from_file(cls, fpath):\n        return loadfn(fpath)\n\n    @classmethod\n    def from_dict(cls, res_dict):\n        diffs = res_dict[\"diffs\"]\n        res = cls(SimulationState.from_dict(res_dict[\"initial_state\"]))\n        for diff in diffs:\n            formatted = {int(k): v for k, v in diff.items() if k != \"GENERAL\"}\n            res.add_step(formatted)\n        return res\n\n    def __init__(self, starting_state: SimulationState):\n        \"\"\"Initializes a SimulationResult with the specified starting_state.\n\n        Parameters\n        ----------\n        starting_state : SimulationState\n            The state with which the simulation started.\n        \"\"\"\n        self.initial_state = starting_state\n        self._diffs: list[dict] = []\n        self._stored_states = {}\n\n    def add_step(self, updates: Dict[int, Dict]) -&gt; None:\n        \"\"\"Takes a set of updates as a dictionary mapping site IDs\n        to the new values for various state parameters. For instance, if at the\n        new step, my_state_attribute at site 23 changed to 12, updates would look\n        like this:\n\n        {\n            23: {\n                \"my_state_attribute\": 12\n            }\n        }\n\n        Parameters\n        ----------\n        updates : dict\n            The changes associated with a new simulation step.\n        \"\"\"\n        self._diffs.append(updates)\n\n    def __len__(self) -&gt; int:\n        return len(self._diffs) + 1\n\n    def steps(self) -&gt; List[SimulationState]:\n        \"\"\"Returns a list of all the steps from this simulation.\n\n        Returns\n        -------\n        List[SimulationState]\n            The list of steps\n        \"\"\"\n        live_state = self.initial_state.copy()\n        for diff in self._diffs:\n            yield live_state\n            live_state.batch_update(diff)\n\n    @property\n    def last_step(self) -&gt; SimulationState:\n        \"\"\"The last step of the simulation.\n\n        Returns\n        -------\n        SimulationState\n            The last step of the simulation\n        \"\"\"\n        return self.get_step(len(self) - 1)\n\n    @property\n    def first_step(self):\n        return self.get_step(0)\n\n    def set_output(self, step: SimulationState):\n        self.output = step\n\n    def load_steps(self, interval=1):\n        live_state = self.initial_state.copy()\n        self._stored_states[0] = self.initial_state.copy()\n        for ud_idx in tqdm.tqdm(\n            range(0, len(self._diffs)), desc=\"Constructing result from diffs\"\n        ):\n            step_no = ud_idx + 1\n            live_state.batch_update(self._diffs[ud_idx])\n            if step_no % interval == 0 and self._stored_states.get(step_no) is None:\n                stored_state = live_state.copy()\n                self._stored_states[step_no] = stored_state\n\n    def get_step(self, step_no) -&gt; SimulationState:\n        \"\"\"Retrieves the step at the provided number.\n\n        Parameters\n        ----------\n        step_no : int\n            The number of the step to return.\n\n        Returns\n        -------\n        SimulationState\n            The simulation state at the requested step.\n        \"\"\"\n\n        stored = self._stored_states.get(step_no)\n        if stored is not None:\n            return stored\n        else:\n            state = self.initial_state.copy()\n            for ud_idx in range(0, step_no):\n                state.batch_update(self._diffs[ud_idx])\n            return state\n\n    def as_dict(self):\n        return {\n            \"initial_state\": self.initial_state.as_dict(),\n            \"diffs\": self._diffs,\n            \"@module\": self.__class__.__module__,\n            \"@class\": self.__class__.__name__,\n        }\n\n    def to_file(self, fpath: str = None) -&gt; None:\n        \"\"\"Serializes this result to the specified filepath.\n\n        Parameters\n        ----------\n        fpath : str\n            The filepath at which to save the serialized simulation result.\n        \"\"\"\n        if fpath is None:\n            now = datetime.datetime.now()\n            date_string = now.strftime(\"%m-%d-%Y-%H-%M\")\n            fpath = f\"{date_string}.json\"\n\n        dumpfn(self, fpath)\n        return fpath\n</code></pre>"},{"location":"reference/core/simulation_result/#pylattica.core.simulation_result.SimulationResult.__init__","title":"<code>__init__(starting_state)</code>","text":"<p>Initializes a SimulationResult with the specified starting_state.</p>"},{"location":"reference/core/simulation_result/#pylattica.core.simulation_result.SimulationResult.__init__--parameters","title":"Parameters","text":"SimulationState <p>The state with which the simulation started.</p> Source code in <code>pylattica/core/simulation_result.py</code> <pre><code>def __init__(self, starting_state: SimulationState):\n    \"\"\"Initializes a SimulationResult with the specified starting_state.\n\n    Parameters\n    ----------\n    starting_state : SimulationState\n        The state with which the simulation started.\n    \"\"\"\n    self.initial_state = starting_state\n    self._diffs: list[dict] = []\n    self._stored_states = {}\n</code></pre>"},{"location":"reference/core/simulation_result/#pylattica.core.simulation_result.SimulationResult.add_step","title":"<code>add_step(updates)</code>","text":"<p>Takes a set of updates as a dictionary mapping site IDs to the new values for various state parameters. For instance, if at the new step, my_state_attribute at site 23 changed to 12, updates would look like this:</p> <p>{     23: {         \"my_state_attribute\": 12     } }</p>"},{"location":"reference/core/simulation_result/#pylattica.core.simulation_result.SimulationResult.add_step--parameters","title":"Parameters","text":"dict <p>The changes associated with a new simulation step.</p> Source code in <code>pylattica/core/simulation_result.py</code> <pre><code>def add_step(self, updates: Dict[int, Dict]) -&gt; None:\n    \"\"\"Takes a set of updates as a dictionary mapping site IDs\n    to the new values for various state parameters. For instance, if at the\n    new step, my_state_attribute at site 23 changed to 12, updates would look\n    like this:\n\n    {\n        23: {\n            \"my_state_attribute\": 12\n        }\n    }\n\n    Parameters\n    ----------\n    updates : dict\n        The changes associated with a new simulation step.\n    \"\"\"\n    self._diffs.append(updates)\n</code></pre>"},{"location":"reference/core/simulation_result/#pylattica.core.simulation_result.SimulationResult.get_step","title":"<code>get_step(step_no)</code>","text":"<p>Retrieves the step at the provided number.</p>"},{"location":"reference/core/simulation_result/#pylattica.core.simulation_result.SimulationResult.get_step--parameters","title":"Parameters","text":"int <p>The number of the step to return.</p>"},{"location":"reference/core/simulation_result/#pylattica.core.simulation_result.SimulationResult.get_step--returns","title":"Returns","text":"<p>SimulationState     The simulation state at the requested step.</p> Source code in <code>pylattica/core/simulation_result.py</code> <pre><code>def get_step(self, step_no) -&gt; SimulationState:\n    \"\"\"Retrieves the step at the provided number.\n\n    Parameters\n    ----------\n    step_no : int\n        The number of the step to return.\n\n    Returns\n    -------\n    SimulationState\n        The simulation state at the requested step.\n    \"\"\"\n\n    stored = self._stored_states.get(step_no)\n    if stored is not None:\n        return stored\n    else:\n        state = self.initial_state.copy()\n        for ud_idx in range(0, step_no):\n            state.batch_update(self._diffs[ud_idx])\n        return state\n</code></pre>"},{"location":"reference/core/simulation_result/#pylattica.core.simulation_result.SimulationResult.last_step","title":"<code>last_step()</code>  <code>property</code>","text":"<p>The last step of the simulation.</p>"},{"location":"reference/core/simulation_result/#pylattica.core.simulation_result.SimulationResult.last_step--returns","title":"Returns","text":"<p>SimulationState     The last step of the simulation</p> Source code in <code>pylattica/core/simulation_result.py</code> <pre><code>@property\ndef last_step(self) -&gt; SimulationState:\n    \"\"\"The last step of the simulation.\n\n    Returns\n    -------\n    SimulationState\n        The last step of the simulation\n    \"\"\"\n    return self.get_step(len(self) - 1)\n</code></pre>"},{"location":"reference/core/simulation_result/#pylattica.core.simulation_result.SimulationResult.steps","title":"<code>steps()</code>","text":"<p>Returns a list of all the steps from this simulation.</p>"},{"location":"reference/core/simulation_result/#pylattica.core.simulation_result.SimulationResult.steps--returns","title":"Returns","text":"<p>List[SimulationState]     The list of steps</p> Source code in <code>pylattica/core/simulation_result.py</code> <pre><code>def steps(self) -&gt; List[SimulationState]:\n    \"\"\"Returns a list of all the steps from this simulation.\n\n    Returns\n    -------\n    List[SimulationState]\n        The list of steps\n    \"\"\"\n    live_state = self.initial_state.copy()\n    for diff in self._diffs:\n        yield live_state\n        live_state.batch_update(diff)\n</code></pre>"},{"location":"reference/core/simulation_result/#pylattica.core.simulation_result.SimulationResult.to_file","title":"<code>to_file(fpath=None)</code>","text":"<p>Serializes this result to the specified filepath.</p>"},{"location":"reference/core/simulation_result/#pylattica.core.simulation_result.SimulationResult.to_file--parameters","title":"Parameters","text":"str <p>The filepath at which to save the serialized simulation result.</p> Source code in <code>pylattica/core/simulation_result.py</code> <pre><code>def to_file(self, fpath: str = None) -&gt; None:\n    \"\"\"Serializes this result to the specified filepath.\n\n    Parameters\n    ----------\n    fpath : str\n        The filepath at which to save the serialized simulation result.\n    \"\"\"\n    if fpath is None:\n        now = datetime.datetime.now()\n        date_string = now.strftime(\"%m-%d-%Y-%H-%M\")\n        fpath = f\"{date_string}.json\"\n\n    dumpfn(self, fpath)\n    return fpath\n</code></pre>"},{"location":"reference/core/simulation_state/","title":"SimulationState","text":""},{"location":"reference/core/simulation_state/#pylattica.core.simulation_state.SimulationState","title":"<code>SimulationState</code>","text":"<p>Representation of the state during a single step of the simulation. This is essentially a dictionary that maps the IDs of sites in the simulation structure to dictionaries with arbitrary keys and values that can store whatever state is relevant for the simulation.</p> <p>Additionally, there is a concept of general simulation state that is separate from the state of any specific site in the simulation.</p> Source code in <code>pylattica/core/simulation_state.py</code> <pre><code>class SimulationState:\n    \"\"\"Representation of the state during a single step of the simulation. This is essentially\n    a dictionary that maps the IDs of sites in the simulation structure to dictionaries with\n    arbitrary keys and values that can store whatever state is relevant for the simulation.\n\n    Additionally, there is a concept of general simulation state that is separate from the state\n    of any specific site in the simulation.\n    \"\"\"\n\n    def as_dict(self):\n        return {\n            \"state\": self._state,\n            \"@module\": self.__class__.__module__,\n            \"@class\": self.__class__.__name__,\n        }\n\n    @classmethod\n    def from_dict(cls, state_dict):\n        state = state_dict[\"state\"]\n        state[SITES] = {int(k): v for k, v in state[SITES].items()}\n        return cls(state)\n\n    @classmethod\n    def from_struct(cls, struct: PeriodicStructure):\n        state = cls()\n\n        for sid in struct.site_ids:\n            state.set_site_state(sid, {})\n\n        return state\n\n    def __init__(self, state: Dict = None):\n        \"\"\"Initializes the SimulationState.\n\n        Parameters\n        ----------\n        state : dict, optional\n            A state to store. should be a map with keys \"GENERAL\" and \"SITES\", by default None\n        \"\"\"\n        if state is None:\n            self._state = {\n                SITES: {},\n                GENERAL: {},\n            }\n        else:\n            self._state = copy.deepcopy(state)\n\n    @property\n    def size(self) -&gt; int:\n        \"\"\"Gives the number of sites for which state information is stored.\n\n        Returns\n        -------\n        int\n            The number of sites for which state information is stored.\n        \"\"\"\n        return len(self.site_ids())\n\n    def site_ids(self) -&gt; List[int]:\n        \"\"\"A list of site IDs for which some state is stored.\n\n        Returns\n        -------\n        List[int]\n        \"\"\"\n        return list(self._state[SITES].keys())\n\n    def all_site_states(self) -&gt; List[Dict]:\n        \"\"\"Returns a list of dictionaries representing the site\n        state values.\n\n        Returns\n        -------\n        List[Dict]\n            The state dictionaries for every site in this state.\n        \"\"\"\n        return list(self._state[SITES].values())\n\n    def get_site_state(self, site_id: int) -&gt; Dict:\n        \"\"\"Returns the state stored for the specified site ID, if any.\n\n        Parameters\n        ----------\n        site_id : int\n            The ID of the site for which state information should be retrieved.\n\n        Returns\n        -------\n        Dict\n            The state of that site. Returns None if no state is stored under that site ID.\n        \"\"\"\n        return self._state[SITES].get(site_id)\n\n    def get_general_state(self) -&gt; Dict:\n        \"\"\"Returns the general state.\n\n        Returns\n        -------\n        Dict\n            The general state.\n        \"\"\"\n        return self._state.get(GENERAL)\n\n    def set_general_state(self, updates: Dict) -&gt; None:\n        \"\"\"Updates the general state with the keys and values provided by the updates parameter.\n\n        Parameters\n        ----------\n        updates : Dict\n            The updates to apply. Note that this overwrites values in the old state, but unspecified\n            values are left unchanged.\n        \"\"\"\n        old_state = self.get_general_state()\n        self._state[GENERAL] = {**old_state, **updates}\n\n    def set_site_state(self, site_id: int, updates: dict) -&gt; None:\n        \"\"\"Updates the state stored for site with ID site_id.\n\n        Parameters\n        ----------\n        site_id : int\n            The ID of the site for which the state should be updated.\n        updates : dict\n            The updates to the state that should be performed.\n        \"\"\"\n        old_state = self._state[SITES].get(site_id)\n        if old_state is None:\n            old_state = {SITE_ID: site_id}\n\n        self._state[SITES][site_id] = {**old_state, **updates}\n\n    def batch_update(self, update_batch: Dict) -&gt; None:\n        \"\"\"Applies a batch update to many sites and the general state. Takes a dictionary\n        formatted like this:\n\n        {\n            \"GENERAL\": {...},\n            \"SITES\": {\n                1: {...}\n            }\n        }\n\n        Parameters\n        ----------\n        update_batch : Dict\n            The updates to apply as a batch.\n        \"\"\"\n\n        if GENERAL in update_batch:\n            for site_id, updates in update_batch[SITES].items():\n                self.set_site_state(site_id, updates)\n\n            self.set_general_state(update_batch[GENERAL])\n        else:\n            for site_id, updates in update_batch.items():\n                self.set_site_state(site_id, updates)\n\n    def copy(self) -&gt; SimulationState:\n        \"\"\"Creates a new simulation state identical to this one. This is a deepcopy\n        operation, so changing the copy will not change the original.\n\n        Returns\n        -------\n        SimulationState\n            The copy of this SimulationState\n        \"\"\"\n        return SimulationState(self._state)\n\n    def __eq__(self, other: SimulationState) -&gt; bool:\n        return self._state == other._state\n</code></pre>"},{"location":"reference/core/simulation_state/#pylattica.core.simulation_state.SimulationState.__init__","title":"<code>__init__(state=None)</code>","text":"<p>Initializes the SimulationState.</p>"},{"location":"reference/core/simulation_state/#pylattica.core.simulation_state.SimulationState.__init__--parameters","title":"Parameters","text":"dict, optional <p>A state to store. should be a map with keys \"GENERAL\" and \"SITES\", by default None</p> Source code in <code>pylattica/core/simulation_state.py</code> <pre><code>def __init__(self, state: Dict = None):\n    \"\"\"Initializes the SimulationState.\n\n    Parameters\n    ----------\n    state : dict, optional\n        A state to store. should be a map with keys \"GENERAL\" and \"SITES\", by default None\n    \"\"\"\n    if state is None:\n        self._state = {\n            SITES: {},\n            GENERAL: {},\n        }\n    else:\n        self._state = copy.deepcopy(state)\n</code></pre>"},{"location":"reference/core/simulation_state/#pylattica.core.simulation_state.SimulationState.all_site_states","title":"<code>all_site_states()</code>","text":"<p>Returns a list of dictionaries representing the site state values.</p>"},{"location":"reference/core/simulation_state/#pylattica.core.simulation_state.SimulationState.all_site_states--returns","title":"Returns","text":"<p>List[Dict]     The state dictionaries for every site in this state.</p> Source code in <code>pylattica/core/simulation_state.py</code> <pre><code>def all_site_states(self) -&gt; List[Dict]:\n    \"\"\"Returns a list of dictionaries representing the site\n    state values.\n\n    Returns\n    -------\n    List[Dict]\n        The state dictionaries for every site in this state.\n    \"\"\"\n    return list(self._state[SITES].values())\n</code></pre>"},{"location":"reference/core/simulation_state/#pylattica.core.simulation_state.SimulationState.batch_update","title":"<code>batch_update(update_batch)</code>","text":"<p>Applies a batch update to many sites and the general state. Takes a dictionary formatted like this:</p> <p>{     \"GENERAL\": {...},     \"SITES\": {         1: {...}     } }</p>"},{"location":"reference/core/simulation_state/#pylattica.core.simulation_state.SimulationState.batch_update--parameters","title":"Parameters","text":"Dict <p>The updates to apply as a batch.</p> Source code in <code>pylattica/core/simulation_state.py</code> <pre><code>def batch_update(self, update_batch: Dict) -&gt; None:\n    \"\"\"Applies a batch update to many sites and the general state. Takes a dictionary\n    formatted like this:\n\n    {\n        \"GENERAL\": {...},\n        \"SITES\": {\n            1: {...}\n        }\n    }\n\n    Parameters\n    ----------\n    update_batch : Dict\n        The updates to apply as a batch.\n    \"\"\"\n\n    if GENERAL in update_batch:\n        for site_id, updates in update_batch[SITES].items():\n            self.set_site_state(site_id, updates)\n\n        self.set_general_state(update_batch[GENERAL])\n    else:\n        for site_id, updates in update_batch.items():\n            self.set_site_state(site_id, updates)\n</code></pre>"},{"location":"reference/core/simulation_state/#pylattica.core.simulation_state.SimulationState.copy","title":"<code>copy()</code>","text":"<p>Creates a new simulation state identical to this one. This is a deepcopy operation, so changing the copy will not change the original.</p>"},{"location":"reference/core/simulation_state/#pylattica.core.simulation_state.SimulationState.copy--returns","title":"Returns","text":"<p>SimulationState     The copy of this SimulationState</p> Source code in <code>pylattica/core/simulation_state.py</code> <pre><code>def copy(self) -&gt; SimulationState:\n    \"\"\"Creates a new simulation state identical to this one. This is a deepcopy\n    operation, so changing the copy will not change the original.\n\n    Returns\n    -------\n    SimulationState\n        The copy of this SimulationState\n    \"\"\"\n    return SimulationState(self._state)\n</code></pre>"},{"location":"reference/core/simulation_state/#pylattica.core.simulation_state.SimulationState.get_general_state","title":"<code>get_general_state()</code>","text":"<p>Returns the general state.</p>"},{"location":"reference/core/simulation_state/#pylattica.core.simulation_state.SimulationState.get_general_state--returns","title":"Returns","text":"<p>Dict     The general state.</p> Source code in <code>pylattica/core/simulation_state.py</code> <pre><code>def get_general_state(self) -&gt; Dict:\n    \"\"\"Returns the general state.\n\n    Returns\n    -------\n    Dict\n        The general state.\n    \"\"\"\n    return self._state.get(GENERAL)\n</code></pre>"},{"location":"reference/core/simulation_state/#pylattica.core.simulation_state.SimulationState.get_site_state","title":"<code>get_site_state(site_id)</code>","text":"<p>Returns the state stored for the specified site ID, if any.</p>"},{"location":"reference/core/simulation_state/#pylattica.core.simulation_state.SimulationState.get_site_state--parameters","title":"Parameters","text":"int <p>The ID of the site for which state information should be retrieved.</p>"},{"location":"reference/core/simulation_state/#pylattica.core.simulation_state.SimulationState.get_site_state--returns","title":"Returns","text":"<p>Dict     The state of that site. Returns None if no state is stored under that site ID.</p> Source code in <code>pylattica/core/simulation_state.py</code> <pre><code>def get_site_state(self, site_id: int) -&gt; Dict:\n    \"\"\"Returns the state stored for the specified site ID, if any.\n\n    Parameters\n    ----------\n    site_id : int\n        The ID of the site for which state information should be retrieved.\n\n    Returns\n    -------\n    Dict\n        The state of that site. Returns None if no state is stored under that site ID.\n    \"\"\"\n    return self._state[SITES].get(site_id)\n</code></pre>"},{"location":"reference/core/simulation_state/#pylattica.core.simulation_state.SimulationState.set_general_state","title":"<code>set_general_state(updates)</code>","text":"<p>Updates the general state with the keys and values provided by the updates parameter.</p>"},{"location":"reference/core/simulation_state/#pylattica.core.simulation_state.SimulationState.set_general_state--parameters","title":"Parameters","text":"Dict <p>The updates to apply. Note that this overwrites values in the old state, but unspecified values are left unchanged.</p> Source code in <code>pylattica/core/simulation_state.py</code> <pre><code>def set_general_state(self, updates: Dict) -&gt; None:\n    \"\"\"Updates the general state with the keys and values provided by the updates parameter.\n\n    Parameters\n    ----------\n    updates : Dict\n        The updates to apply. Note that this overwrites values in the old state, but unspecified\n        values are left unchanged.\n    \"\"\"\n    old_state = self.get_general_state()\n    self._state[GENERAL] = {**old_state, **updates}\n</code></pre>"},{"location":"reference/core/simulation_state/#pylattica.core.simulation_state.SimulationState.set_site_state","title":"<code>set_site_state(site_id, updates)</code>","text":"<p>Updates the state stored for site with ID site_id.</p>"},{"location":"reference/core/simulation_state/#pylattica.core.simulation_state.SimulationState.set_site_state--parameters","title":"Parameters","text":"int <p>The ID of the site for which the state should be updated.</p> dict <p>The updates to the state that should be performed.</p> Source code in <code>pylattica/core/simulation_state.py</code> <pre><code>def set_site_state(self, site_id: int, updates: dict) -&gt; None:\n    \"\"\"Updates the state stored for site with ID site_id.\n\n    Parameters\n    ----------\n    site_id : int\n        The ID of the site for which the state should be updated.\n    updates : dict\n        The updates to the state that should be performed.\n    \"\"\"\n    old_state = self._state[SITES].get(site_id)\n    if old_state is None:\n        old_state = {SITE_ID: site_id}\n\n    self._state[SITES][site_id] = {**old_state, **updates}\n</code></pre>"},{"location":"reference/core/simulation_state/#pylattica.core.simulation_state.SimulationState.site_ids","title":"<code>site_ids()</code>","text":"<p>A list of site IDs for which some state is stored.</p>"},{"location":"reference/core/simulation_state/#pylattica.core.simulation_state.SimulationState.site_ids--returns","title":"Returns","text":"<p>List[int]</p> Source code in <code>pylattica/core/simulation_state.py</code> <pre><code>def site_ids(self) -&gt; List[int]:\n    \"\"\"A list of site IDs for which some state is stored.\n\n    Returns\n    -------\n    List[int]\n    \"\"\"\n    return list(self._state[SITES].keys())\n</code></pre>"},{"location":"reference/core/simulation_state/#pylattica.core.simulation_state.SimulationState.size","title":"<code>size()</code>  <code>property</code>","text":"<p>Gives the number of sites for which state information is stored.</p>"},{"location":"reference/core/simulation_state/#pylattica.core.simulation_state.SimulationState.size--returns","title":"Returns","text":"<p>int     The number of sites for which state information is stored.</p> Source code in <code>pylattica/core/simulation_state.py</code> <pre><code>@property\ndef size(self) -&gt; int:\n    \"\"\"Gives the number of sites for which state information is stored.\n\n    Returns\n    -------\n    int\n        The number of sites for which state information is stored.\n    \"\"\"\n    return len(self.site_ids())\n</code></pre>"},{"location":"reference/core/structure_builder/","title":"StructureBuilder","text":""},{"location":"reference/core/structure_builder/#pylattica.core.structure_builder.StructureBuilder","title":"<code>StructureBuilder</code>","text":"<p>         Bases: <code>ABC</code></p> <p>An abstract class for building structures out of motifs and lattices. In general. this class works by tiling space to an extent specified, and then filling that space according to the motif (mapping of site types to locations within the unit cell) provided.</p> Source code in <code>pylattica/core/structure_builder.py</code> <pre><code>class StructureBuilder(ABC):\n    \"\"\"An abstract class for building structures out of motifs and lattices. In general.\n    this class works by tiling space to an extent specified, and then filling that\n    space according to the motif (mapping of site types to locations within the unit cell)\n    provided.\n    \"\"\"\n\n    frac_coords = False\n\n    def __init__(self, lattice: Lattice, motif: Dict[str, List[Tuple]]):\n        \"\"\"Instantiates a StructureBuilder using a Lattice and a motif.\n\n        Parameters\n        ----------\n        lattice : Lattice\n            The Lattice with which space will be tiled.\n        motif : Dict[str, List[Tuple]]\n            The motif with which sites will be placed inside the structure. These motifs\n            are given by a mapping of site type (str) to list of locations inside\n            the unit cell that that site type exists.\n        \"\"\"\n        self.lattice = lattice\n        self.motif = motif\n\n    def build(self, size: Union[Tuple[int], int]) -&gt; PeriodicStructure:\n        \"\"\"Builds a structure with the provided size.\n\n        Parameters\n        ----------\n        size : Union[Tuple[int], int]\n            Either an integer or a tuple of integers specifying the extent\n            of the desired structure in each dimension.\n\n        Returns\n        -------\n        PeriodicStructure\n            The resulting structure.\n\n        Raises\n        ------\n        ValueError\n            If the size is a tuple that is not of length equal to the lattice\n            dimension, a value error is thrown. In other words, you must specify\n            size along each dimension of the lattice.\n        \"\"\"\n        if isinstance(size, tuple):\n            if not len(size) == self.lattice.dim:\n                raise ValueError(\n                    f\"Desired structure dimensions, {size}, does not match \"\n                    \"dimensionality of lattice: {self.lattice.dim}\"\n                )\n        else:\n            size = [size for _ in range(self.lattice.dim)]\n\n        return PeriodicStructure.build_from(\n            self.lattice, size, self.motif, frac_coords=self.frac_coords\n        )\n</code></pre>"},{"location":"reference/core/structure_builder/#pylattica.core.structure_builder.StructureBuilder.__init__","title":"<code>__init__(lattice, motif)</code>","text":"<p>Instantiates a StructureBuilder using a Lattice and a motif.</p>"},{"location":"reference/core/structure_builder/#pylattica.core.structure_builder.StructureBuilder.__init__--parameters","title":"Parameters","text":"Lattice <p>The Lattice with which space will be tiled.</p> Dict[str, List[Tuple]] <p>The motif with which sites will be placed inside the structure. These motifs are given by a mapping of site type (str) to list of locations inside the unit cell that that site type exists.</p> Source code in <code>pylattica/core/structure_builder.py</code> <pre><code>def __init__(self, lattice: Lattice, motif: Dict[str, List[Tuple]]):\n    \"\"\"Instantiates a StructureBuilder using a Lattice and a motif.\n\n    Parameters\n    ----------\n    lattice : Lattice\n        The Lattice with which space will be tiled.\n    motif : Dict[str, List[Tuple]]\n        The motif with which sites will be placed inside the structure. These motifs\n        are given by a mapping of site type (str) to list of locations inside\n        the unit cell that that site type exists.\n    \"\"\"\n    self.lattice = lattice\n    self.motif = motif\n</code></pre>"},{"location":"reference/core/structure_builder/#pylattica.core.structure_builder.StructureBuilder.build","title":"<code>build(size)</code>","text":"<p>Builds a structure with the provided size.</p>"},{"location":"reference/core/structure_builder/#pylattica.core.structure_builder.StructureBuilder.build--parameters","title":"Parameters","text":"Union[Tuple[int], int] <p>Either an integer or a tuple of integers specifying the extent of the desired structure in each dimension.</p>"},{"location":"reference/core/structure_builder/#pylattica.core.structure_builder.StructureBuilder.build--returns","title":"Returns","text":"<p>PeriodicStructure     The resulting structure.</p>"},{"location":"reference/core/structure_builder/#pylattica.core.structure_builder.StructureBuilder.build--raises","title":"Raises","text":"<p>ValueError     If the size is a tuple that is not of length equal to the lattice     dimension, a value error is thrown. In other words, you must specify     size along each dimension of the lattice.</p> Source code in <code>pylattica/core/structure_builder.py</code> <pre><code>def build(self, size: Union[Tuple[int], int]) -&gt; PeriodicStructure:\n    \"\"\"Builds a structure with the provided size.\n\n    Parameters\n    ----------\n    size : Union[Tuple[int], int]\n        Either an integer or a tuple of integers specifying the extent\n        of the desired structure in each dimension.\n\n    Returns\n    -------\n    PeriodicStructure\n        The resulting structure.\n\n    Raises\n    ------\n    ValueError\n        If the size is a tuple that is not of length equal to the lattice\n        dimension, a value error is thrown. In other words, you must specify\n        size along each dimension of the lattice.\n    \"\"\"\n    if isinstance(size, tuple):\n        if not len(size) == self.lattice.dim:\n            raise ValueError(\n                f\"Desired structure dimensions, {size}, does not match \"\n                \"dimensionality of lattice: {self.lattice.dim}\"\n            )\n    else:\n        size = [size for _ in range(self.lattice.dim)]\n\n    return PeriodicStructure.build_from(\n        self.lattice, size, self.motif, frac_coords=self.frac_coords\n    )\n</code></pre>"},{"location":"reference/core/runner/asynchronous_runner/","title":"AsynchronousRunner","text":""},{"location":"reference/core/runner/asynchronous_runner/#pylattica.core.runner.asynchronous_runner.AsynchronousRunner","title":"<code>AsynchronousRunner</code>","text":"<p>         Bases: <code>Runner</code></p> <p>Class for orchestrating the running of the simulation. An automaton simulation is run by applying the update rule (as implemented by a Controller) to sites in the SimulationState repeatedly. This Runner implements the Asynchronous evolution strategy.</p> <p>If a simulation is run asynchronously, one simulation step consists of a single site being chosen randomly and applying the update rule there. This is appropriate if the update rule impacts the cell it is focused on and it's neighbors.</p> <p>For instance, if the update rule \"moves\" an entity from one cell to a neighboring cell, it must be applied asynchronously because otherwise it's effects could interfere with the effects of neighboring applications. Specify that this mode should be used with the is_async initialization parameter.</p> Source code in <code>pylattica/core/runner/asynchronous_runner.py</code> <pre><code>class AsynchronousRunner(Runner):\n    \"\"\"Class for orchestrating the running of the simulation. An automaton simulation\n    is run by applying the update rule (as implemented by a Controller) to sites\n    in the SimulationState repeatedly. This Runner implements the Asynchronous evolution\n    strategy.\n\n    If a simulation is run asynchronously, one simulation step consists\n    of a single site being chosen randomly and applying the update rule there. This\n    is appropriate if the update rule impacts the cell it is focused on and it's\n    neighbors.\n\n    For instance, if the update rule \"moves\" an entity from one cell to\n    a neighboring cell, it must be applied asynchronously because otherwise it's\n    effects could interfere with the effects of neighboring applications. Specify\n    that this mode should be used with the is_async initialization parameter.\n    \"\"\"\n\n    def _run(\n        self,\n        _: SimulationState,\n        result: SimulationResult,\n        live_state: SimulationState,\n        controller: BasicController,\n        num_steps: int,\n        verbose: bool = False,\n    ) -&gt; SimulationResult:\n        \"\"\"Run the simulation for the prescribed number of steps. Recall that one\n        asynchronous simulation step involves one application of the update rule,\n        and one normal simulation step applies the update rule to every site.\n\n        Parameters\n        ----------\n        initial_state : SimulationState\n            The starting state for the simulation.\n        controller : BasicController\n            The controller (a descendent of BasicController) which implements the update rule.\n        num_steps : int\n            The number of steps for which the simulation should run.\n        verbose : bool, optional\n            If True, debug information is printed during the run, by default False\n\n        Returns\n        -------\n        BasicSimulationResult\n            The result of the simulation.\n        \"\"\"\n\n        site_queue = deque()\n\n        def _add_sites_to_queue():\n            next_site = controller.get_random_site(live_state)\n            if isinstance(next_site, int):\n                site_queue.append(next_site)\n            elif isinstance(next_site, list):\n                site_queue.extend(next_site)\n\n        _add_sites_to_queue()\n\n        if len(site_queue) == 0:\n            raise RuntimeError(\"Controller provided no sites to update, ABORTING\")\n\n        for _ in tqdm(range(num_steps), disable=(not verbose)):\n            site_id = site_queue.popleft()\n\n            controller_response = controller.get_state_update(site_id, live_state)\n            next_sites = []\n\n            # See if controller is specifying which sites to visit next\n            if isinstance(controller_response, tuple):\n                state_updates, next_sites = controller_response\n            else:\n                state_updates = controller_response\n\n            state_updates = merge_updates(state_updates, site_id=site_id)\n            live_state.batch_update(state_updates)\n            site_queue.extend(next_sites)\n            result.add_step(state_updates)\n\n            if len(site_queue) == 0:\n                _add_sites_to_queue()\n\n            if len(site_queue) == 0:\n                break\n\n        result.set_output(live_state)\n        return result\n</code></pre>"},{"location":"reference/core/runner/synchronous_runner/","title":"SynchronousRunner","text":""},{"location":"reference/core/runner/synchronous_runner/#pylattica.core.runner.synchronous_runner.SynchronousRunner","title":"<code>SynchronousRunner</code>","text":"<p>         Bases: <code>Runner</code></p> <p>Class for orchestrating the running of the simulation. An automaton simulation is run by applying the update rule (as implemented by a Controller) to sites in the SimulationState repeatedly. This class implements the synchronous update strategy.</p> <p>In the normal configuration, one simulation step involves applying the update rule to every site in the SimulationState. The user should assume these applications follow no specific order. This is appropriate if the update rule only impacts the cell it is applied to, and no neighboring cells.</p> <p>If normal mode is used, the automaton can be parallelized, meaning that the update rule can be applied to many cells simultaneously. This can lead to dramatic improvements in speed for the simulation. Specify this using <code>parallel = True</code> during initialization. You can further specify the number of workers to use during parallel processing with the <code>workers</code> parameter. If left unspecified, one worker for each CPU will be created.</p> Source code in <code>pylattica/core/runner/synchronous_runner.py</code> <pre><code>class SynchronousRunner(Runner):\n    \"\"\"Class for orchestrating the running of the simulation. An automaton simulation\n    is run by applying the update rule (as implemented by a Controller) to sites\n    in the SimulationState repeatedly. This class implements the synchronous update\n    strategy.\n\n    In the normal configuration, one simulation step involves applying\n    the update rule to every site in the SimulationState. The user should assume\n    these applications follow no specific order. This is appropriate if the\n    update rule only impacts the cell it is applied to, and no neighboring cells.\n\n    If normal mode is used, the automaton can be parallelized, meaning that the\n    update rule can be applied to many cells simultaneously. This can lead to\n    dramatic improvements in speed for the simulation. Specify this using\n    `parallel = True` during initialization. You can further specify the number\n    of workers to use during parallel processing with the `workers` parameter.\n    If left unspecified, one worker for each CPU will be created.\n    \"\"\"\n\n    def __init__(self, parallel: bool = False, workers: int = None) -&gt; None:\n        self.parallel = parallel\n        self.workers = workers\n\n    def _run(\n        self,\n        initial_state: SimulationState,\n        result: SimulationResult,\n        live_state: SimulationState,\n        controller: BasicController,\n        num_steps: int,\n        verbose: bool = False,\n    ):\n        if self.parallel:\n            global mp_globals  # pylint: disable=global-variable-not-assigned\n            mp_globals[\"controller\"] = controller\n            mp_globals[\"initial_state\"] = initial_state\n\n            if self.workers is None:\n                PROCESSES = mp.cpu_count()\n            else:\n                PROCESSES = self.workers  # pragma: no cover\n\n            printif(verbose, f\"Running in parallel using {PROCESSES} workers\")\n            num_sites = initial_state.size\n            chunk_size = math.ceil(num_sites / PROCESSES)\n            printif(\n                verbose,\n                f\"Distributing {num_sites} update tasks to {PROCESSES} workers in chunks of {chunk_size}\",\n            )\n            with mp.get_context(\"fork\").Pool(PROCESSES) as pool:\n                updates = {}\n                for _ in tqdm(range(num_steps)):\n                    updates = self._take_step_parallel(\n                        updates, pool, chunk_size=chunk_size\n                    )\n                    result.add_step(updates)\n        else:\n            printif(verbose, \"Running in series.\")\n            for _ in tqdm(range(num_steps)):\n                updates = self._take_step(live_state, controller)\n                live_state.batch_update(updates)\n                result.add_step(updates)\n\n        result.set_output(live_state)\n        return result\n\n    def _take_step_parallel(self, updates: dict, pool, chunk_size) -&gt; SimulationState:\n        params = []\n        site_ids = mp_globals[\"initial_state\"].site_ids()\n        num_sites = len(site_ids)\n        site_batches = [\n            site_ids[i : i + chunk_size] for i in range(0, num_sites, chunk_size)\n        ]\n\n        for batch in site_batches:\n            params.append([batch, updates])\n\n        results = pool.starmap(_step_batch_parallel, params)\n        all_updates = None\n        for batch_update_res in results:\n            all_updates = merge_updates(all_updates, batch_update_res)\n\n        return all_updates\n\n    def _take_step(\n        self, state: SimulationState, controller: BasicController\n    ) -&gt; SimulationState:\n        site_ids = state.site_ids()\n        updates = _step_batch(site_ids, state, controller)\n\n        return updates\n</code></pre>"},{"location":"reference/discrete/discrete_state_result_analyzer/","title":"DiscreteStateResultAnalyzer","text":""},{"location":"reference/discrete/discrete_state_result_analyzer/#pylattica.discrete.discrete_state_result_analyzer.DiscreteResultAnalyzer","title":"<code>DiscreteResultAnalyzer</code>","text":"<p>A class that stores the result of running a simulation. Keeps track of all the steps that the simulation proceeded through, and the set of reactions that was used in the simulation.</p> Source code in <code>pylattica/discrete/discrete_state_result_analyzer.py</code> <pre><code>class DiscreteResultAnalyzer:\n    \"\"\"A class that stores the result of running a simulation. Keeps track of all\n    the steps that the simulation proceeded through, and the set of reactions that\n    was used in the simulation.\n    \"\"\"\n\n    def __init__(self, result: SimulationResult):\n        \"\"\"Instantiates the DiscreteResultAnalyzer\n\n        Parameters\n        ----------\n        result : SimulationResult\n            The result to analyze.\n        \"\"\"\n        self._result = result\n\n    @lru_cache\n    def all_phases(self) -&gt; List[str]:\n        \"\"\"Returns all of the phases present across the analyzed result.\n\n        Returns\n        -------\n        List[str]\n            A list of every phase present in any step of the result.\n        \"\"\"\n        analyzer = DiscreteStepAnalyzer()\n        phases = []\n        for step in self._result.steps():\n            curr_phases = analyzer.phases_present(step)\n            phases = phases + curr_phases\n\n        return frozenset(phases)\n\n    def plot_phase_fractions(self, min_prevalence=0.01) -&gt; None:\n        \"\"\"In a Jupyter Notebook environment, plots the phase prevalence traces for the simulation.\n\n        Returns:\n            None:\n        \"\"\"\n\n        fig = go.Figure()\n        fig.update_layout(width=800, height=800)\n        fig.update_yaxes(range=[-0.05, 1.05], title=\"Volume Fraction\")\n\n        analyzer = DiscreteStepAnalyzer()\n        traces = []\n\n        step_idxs, steps = self._get_steps_to_plot()\n        fig.update_xaxes(range=[0, step_idxs[-1]], title=\"Simulation Step\")\n\n        for phase in self.all_phases():\n            ys = [analyzer.cell_fraction(step, phase) for step in steps]\n            traces.append((step_idxs, ys, phase))\n\n        filtered_traces = [t for t in traces if max(t[1]) &gt; min_prevalence]\n\n        for t in filtered_traces:\n            fig.add_trace(go.Scatter(name=t[2], x=t[0], y=t[1], mode=\"lines\"))\n\n        return fig\n\n    def final_phase_fractions(self) -&gt; Dict[str, float]:\n        \"\"\"Returns the fractions of each phase in the last frame of the simulation.\n\n        Returns\n        -------\n        Dict[str, float]\n        \"\"\"\n        analyzer = DiscreteStepAnalyzer()\n        fracs = {}\n        for phase in self.all_phases():\n            fracs[phase] = analyzer.cell_fraction(self._result.last_step, phase)\n\n        return fracs\n\n    def phase_fraction_at(self, step: int, phase: str) -&gt; float:\n        \"\"\"Returns the fraction of the specified phase at the specified simulation frame.\n\n        Parameters\n        ----------\n        step : int\n            The simulation frame for which this analysis should be done.\n        phase : str\n            The phase for which the phase fraction should be calculated\n\n        Returns\n        -------\n        float\n            The phase fraction of the specified phase at the specified frame.\n        \"\"\"\n        analyzer = DiscreteStepAnalyzer()\n        return analyzer.cell_fraction(self._result.get_step(step), phase)\n\n    def plot_phase_counts(self) -&gt; None:  # pragma: no cover\n        \"\"\"In a jupyter notebook environment, plots the number of phases at each\n        time step.\n        \"\"\"\n        xs = np.arange(len(self.steps))\n        ys = [step.phase_count for step in self.steps]\n        plt.plot(xs, ys)\n\n    def _get_steps_to_plot(self) -&gt; Tuple[List[int], List[SimulationState]]:\n        num_points = min(100, len(self._result))\n        step_size = max(1, round(len(self._result) / num_points))\n        self._result.load_steps(step_size)\n        step_idxs = list(range(0, len(self._result), step_size))\n        return step_idxs, [self._result.get_step(step_idx) for step_idx in step_idxs]\n</code></pre>"},{"location":"reference/discrete/discrete_state_result_analyzer/#pylattica.discrete.discrete_state_result_analyzer.DiscreteResultAnalyzer.__init__","title":"<code>__init__(result)</code>","text":"<p>Instantiates the DiscreteResultAnalyzer</p>"},{"location":"reference/discrete/discrete_state_result_analyzer/#pylattica.discrete.discrete_state_result_analyzer.DiscreteResultAnalyzer.__init__--parameters","title":"Parameters","text":"SimulationResult <p>The result to analyze.</p> Source code in <code>pylattica/discrete/discrete_state_result_analyzer.py</code> <pre><code>def __init__(self, result: SimulationResult):\n    \"\"\"Instantiates the DiscreteResultAnalyzer\n\n    Parameters\n    ----------\n    result : SimulationResult\n        The result to analyze.\n    \"\"\"\n    self._result = result\n</code></pre>"},{"location":"reference/discrete/discrete_state_result_analyzer/#pylattica.discrete.discrete_state_result_analyzer.DiscreteResultAnalyzer.all_phases","title":"<code>all_phases()</code>  <code>cached</code>","text":"<p>Returns all of the phases present across the analyzed result.</p>"},{"location":"reference/discrete/discrete_state_result_analyzer/#pylattica.discrete.discrete_state_result_analyzer.DiscreteResultAnalyzer.all_phases--returns","title":"Returns","text":"<p>List[str]     A list of every phase present in any step of the result.</p> Source code in <code>pylattica/discrete/discrete_state_result_analyzer.py</code> <pre><code>@lru_cache\ndef all_phases(self) -&gt; List[str]:\n    \"\"\"Returns all of the phases present across the analyzed result.\n\n    Returns\n    -------\n    List[str]\n        A list of every phase present in any step of the result.\n    \"\"\"\n    analyzer = DiscreteStepAnalyzer()\n    phases = []\n    for step in self._result.steps():\n        curr_phases = analyzer.phases_present(step)\n        phases = phases + curr_phases\n\n    return frozenset(phases)\n</code></pre>"},{"location":"reference/discrete/discrete_state_result_analyzer/#pylattica.discrete.discrete_state_result_analyzer.DiscreteResultAnalyzer.final_phase_fractions","title":"<code>final_phase_fractions()</code>","text":"<p>Returns the fractions of each phase in the last frame of the simulation.</p>"},{"location":"reference/discrete/discrete_state_result_analyzer/#pylattica.discrete.discrete_state_result_analyzer.DiscreteResultAnalyzer.final_phase_fractions--returns","title":"Returns","text":"<p>Dict[str, float]</p> Source code in <code>pylattica/discrete/discrete_state_result_analyzer.py</code> <pre><code>def final_phase_fractions(self) -&gt; Dict[str, float]:\n    \"\"\"Returns the fractions of each phase in the last frame of the simulation.\n\n    Returns\n    -------\n    Dict[str, float]\n    \"\"\"\n    analyzer = DiscreteStepAnalyzer()\n    fracs = {}\n    for phase in self.all_phases():\n        fracs[phase] = analyzer.cell_fraction(self._result.last_step, phase)\n\n    return fracs\n</code></pre>"},{"location":"reference/discrete/discrete_state_result_analyzer/#pylattica.discrete.discrete_state_result_analyzer.DiscreteResultAnalyzer.phase_fraction_at","title":"<code>phase_fraction_at(step, phase)</code>","text":"<p>Returns the fraction of the specified phase at the specified simulation frame.</p>"},{"location":"reference/discrete/discrete_state_result_analyzer/#pylattica.discrete.discrete_state_result_analyzer.DiscreteResultAnalyzer.phase_fraction_at--parameters","title":"Parameters","text":"int <p>The simulation frame for which this analysis should be done.</p> str <p>The phase for which the phase fraction should be calculated</p>"},{"location":"reference/discrete/discrete_state_result_analyzer/#pylattica.discrete.discrete_state_result_analyzer.DiscreteResultAnalyzer.phase_fraction_at--returns","title":"Returns","text":"<p>float     The phase fraction of the specified phase at the specified frame.</p> Source code in <code>pylattica/discrete/discrete_state_result_analyzer.py</code> <pre><code>def phase_fraction_at(self, step: int, phase: str) -&gt; float:\n    \"\"\"Returns the fraction of the specified phase at the specified simulation frame.\n\n    Parameters\n    ----------\n    step : int\n        The simulation frame for which this analysis should be done.\n    phase : str\n        The phase for which the phase fraction should be calculated\n\n    Returns\n    -------\n    float\n        The phase fraction of the specified phase at the specified frame.\n    \"\"\"\n    analyzer = DiscreteStepAnalyzer()\n    return analyzer.cell_fraction(self._result.get_step(step), phase)\n</code></pre>"},{"location":"reference/discrete/discrete_state_result_analyzer/#pylattica.discrete.discrete_state_result_analyzer.DiscreteResultAnalyzer.plot_phase_counts","title":"<code>plot_phase_counts()</code>","text":"<p>In a jupyter notebook environment, plots the number of phases at each time step.</p> Source code in <code>pylattica/discrete/discrete_state_result_analyzer.py</code> <pre><code>def plot_phase_counts(self) -&gt; None:  # pragma: no cover\n    \"\"\"In a jupyter notebook environment, plots the number of phases at each\n    time step.\n    \"\"\"\n    xs = np.arange(len(self.steps))\n    ys = [step.phase_count for step in self.steps]\n    plt.plot(xs, ys)\n</code></pre>"},{"location":"reference/discrete/discrete_state_result_analyzer/#pylattica.discrete.discrete_state_result_analyzer.DiscreteResultAnalyzer.plot_phase_fractions","title":"<code>plot_phase_fractions(min_prevalence=0.01)</code>","text":"<p>In a Jupyter Notebook environment, plots the phase prevalence traces for the simulation.</p> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> Source code in <code>pylattica/discrete/discrete_state_result_analyzer.py</code> <pre><code>def plot_phase_fractions(self, min_prevalence=0.01) -&gt; None:\n    \"\"\"In a Jupyter Notebook environment, plots the phase prevalence traces for the simulation.\n\n    Returns:\n        None:\n    \"\"\"\n\n    fig = go.Figure()\n    fig.update_layout(width=800, height=800)\n    fig.update_yaxes(range=[-0.05, 1.05], title=\"Volume Fraction\")\n\n    analyzer = DiscreteStepAnalyzer()\n    traces = []\n\n    step_idxs, steps = self._get_steps_to_plot()\n    fig.update_xaxes(range=[0, step_idxs[-1]], title=\"Simulation Step\")\n\n    for phase in self.all_phases():\n        ys = [analyzer.cell_fraction(step, phase) for step in steps]\n        traces.append((step_idxs, ys, phase))\n\n    filtered_traces = [t for t in traces if max(t[1]) &gt; min_prevalence]\n\n    for t in filtered_traces:\n        fig.add_trace(go.Scatter(name=t[2], x=t[0], y=t[1], mode=\"lines\"))\n\n    return fig\n</code></pre>"},{"location":"reference/discrete/discrete_step_analyzer/","title":"DiscreteStepAnalyzer","text":""},{"location":"reference/discrete/discrete_step_analyzer/#pylattica.discrete.discrete_step_analyzer.DiscreteStepAnalyzer","title":"<code>DiscreteStepAnalyzer</code>","text":"<p>         Bases: <code>StateAnalyzer</code></p> <p>Implements simple utilities for analyzing simulation states which are specified by categorical occupancies for each site in the simulation</p> Source code in <code>pylattica/discrete/discrete_step_analyzer.py</code> <pre><code>class DiscreteStepAnalyzer(StateAnalyzer):\n    \"\"\"Implements simple utilities for analyzing simulation states which are\n    specified by categorical occupancies for each site in the simulation\n    \"\"\"\n\n    def cell_fraction(self, state: SimulationState, phase_name: str) -&gt; float:\n        \"\"\"Returns the fraction of sites in the provided state which are occupied\n        by the specified phase.\n\n        Parameters\n        ----------\n        state : SimulationState\n            The state to analyze.\n        phase_name : str\n            The name of the phase for which a fraction of sites should be calculated\n\n        Returns\n        -------\n        float\n            The fraction of sites occupied by the specified phase.\n        \"\"\"\n        phase_count = self.cell_count(state, phase_name)\n        total_occupied_cells = state.size\n        return phase_count / total_occupied_cells\n\n    def cell_count(self, state: SimulationState, phase_name: str) -&gt; int:\n        \"\"\"Retrieves the number of cells in the given simulation state occupied by\n        the specified phase.\n\n        Parameters\n        ----------\n        state : SimulationState\n            The state to analyze.\n        phase_name : str\n            The name of the phase to count.\n\n        Returns\n        -------\n        int\n            The number of sites occupied by the specified phase.\n        \"\"\"\n        return self.get_site_count_where_equal(state, {DISCRETE_OCCUPANCY: phase_name})\n\n    def cell_ratio(self, step: SimulationState, p1: str, p2: str) -&gt; float:\n        \"\"\"Returns the occupancy ratio between two phases in the provided simulation state.\n\n        Parameters\n        ----------\n        step : SimulationState\n            The state to analyze.\n        p1 : str\n            The name of the first phase.\n        p2 : str\n            The name of the second phase\n\n        Returns\n        -------\n        float\n            The ratio of the occupancies of the two phases.\n        \"\"\"\n        return self.cell_count(step, p1) / self.cell_count(step, p2)\n\n    def phase_count(self, step: SimulationState) -&gt; int:\n        \"\"\"The number of phases present in the specified simulation state.\n\n        Parameters\n        ----------\n        step : SimulationState\n            The state to analyze.\n\n        Returns\n        -------\n        int\n            The number of phases identified.\n        \"\"\"\n        return len(self.phases_present(step))\n\n    def phases_present(self, state: SimulationState) -&gt; List[str]:\n        \"\"\"Returns a list of the phases present in the specified state.\n\n        Parameters\n        ----------\n        state : SimulationState\n            The state to analyze.\n\n        Returns\n        -------\n        List[str]\n            A list of the phases identified.\n        \"\"\"\n        return list(\n            set(\n                site_state[DISCRETE_OCCUPANCY] for site_state in state.all_site_states()\n            )\n        )\n</code></pre>"},{"location":"reference/discrete/discrete_step_analyzer/#pylattica.discrete.discrete_step_analyzer.DiscreteStepAnalyzer.cell_count","title":"<code>cell_count(state, phase_name)</code>","text":"<p>Retrieves the number of cells in the given simulation state occupied by the specified phase.</p>"},{"location":"reference/discrete/discrete_step_analyzer/#pylattica.discrete.discrete_step_analyzer.DiscreteStepAnalyzer.cell_count--parameters","title":"Parameters","text":"SimulationState <p>The state to analyze.</p> str <p>The name of the phase to count.</p>"},{"location":"reference/discrete/discrete_step_analyzer/#pylattica.discrete.discrete_step_analyzer.DiscreteStepAnalyzer.cell_count--returns","title":"Returns","text":"<p>int     The number of sites occupied by the specified phase.</p> Source code in <code>pylattica/discrete/discrete_step_analyzer.py</code> <pre><code>def cell_count(self, state: SimulationState, phase_name: str) -&gt; int:\n    \"\"\"Retrieves the number of cells in the given simulation state occupied by\n    the specified phase.\n\n    Parameters\n    ----------\n    state : SimulationState\n        The state to analyze.\n    phase_name : str\n        The name of the phase to count.\n\n    Returns\n    -------\n    int\n        The number of sites occupied by the specified phase.\n    \"\"\"\n    return self.get_site_count_where_equal(state, {DISCRETE_OCCUPANCY: phase_name})\n</code></pre>"},{"location":"reference/discrete/discrete_step_analyzer/#pylattica.discrete.discrete_step_analyzer.DiscreteStepAnalyzer.cell_fraction","title":"<code>cell_fraction(state, phase_name)</code>","text":"<p>Returns the fraction of sites in the provided state which are occupied by the specified phase.</p>"},{"location":"reference/discrete/discrete_step_analyzer/#pylattica.discrete.discrete_step_analyzer.DiscreteStepAnalyzer.cell_fraction--parameters","title":"Parameters","text":"SimulationState <p>The state to analyze.</p> str <p>The name of the phase for which a fraction of sites should be calculated</p>"},{"location":"reference/discrete/discrete_step_analyzer/#pylattica.discrete.discrete_step_analyzer.DiscreteStepAnalyzer.cell_fraction--returns","title":"Returns","text":"<p>float     The fraction of sites occupied by the specified phase.</p> Source code in <code>pylattica/discrete/discrete_step_analyzer.py</code> <pre><code>def cell_fraction(self, state: SimulationState, phase_name: str) -&gt; float:\n    \"\"\"Returns the fraction of sites in the provided state which are occupied\n    by the specified phase.\n\n    Parameters\n    ----------\n    state : SimulationState\n        The state to analyze.\n    phase_name : str\n        The name of the phase for which a fraction of sites should be calculated\n\n    Returns\n    -------\n    float\n        The fraction of sites occupied by the specified phase.\n    \"\"\"\n    phase_count = self.cell_count(state, phase_name)\n    total_occupied_cells = state.size\n    return phase_count / total_occupied_cells\n</code></pre>"},{"location":"reference/discrete/discrete_step_analyzer/#pylattica.discrete.discrete_step_analyzer.DiscreteStepAnalyzer.cell_ratio","title":"<code>cell_ratio(step, p1, p2)</code>","text":"<p>Returns the occupancy ratio between two phases in the provided simulation state.</p>"},{"location":"reference/discrete/discrete_step_analyzer/#pylattica.discrete.discrete_step_analyzer.DiscreteStepAnalyzer.cell_ratio--parameters","title":"Parameters","text":"SimulationState <p>The state to analyze.</p> str <p>The name of the first phase.</p> str <p>The name of the second phase</p>"},{"location":"reference/discrete/discrete_step_analyzer/#pylattica.discrete.discrete_step_analyzer.DiscreteStepAnalyzer.cell_ratio--returns","title":"Returns","text":"<p>float     The ratio of the occupancies of the two phases.</p> Source code in <code>pylattica/discrete/discrete_step_analyzer.py</code> <pre><code>def cell_ratio(self, step: SimulationState, p1: str, p2: str) -&gt; float:\n    \"\"\"Returns the occupancy ratio between two phases in the provided simulation state.\n\n    Parameters\n    ----------\n    step : SimulationState\n        The state to analyze.\n    p1 : str\n        The name of the first phase.\n    p2 : str\n        The name of the second phase\n\n    Returns\n    -------\n    float\n        The ratio of the occupancies of the two phases.\n    \"\"\"\n    return self.cell_count(step, p1) / self.cell_count(step, p2)\n</code></pre>"},{"location":"reference/discrete/discrete_step_analyzer/#pylattica.discrete.discrete_step_analyzer.DiscreteStepAnalyzer.phase_count","title":"<code>phase_count(step)</code>","text":"<p>The number of phases present in the specified simulation state.</p>"},{"location":"reference/discrete/discrete_step_analyzer/#pylattica.discrete.discrete_step_analyzer.DiscreteStepAnalyzer.phase_count--parameters","title":"Parameters","text":"SimulationState <p>The state to analyze.</p>"},{"location":"reference/discrete/discrete_step_analyzer/#pylattica.discrete.discrete_step_analyzer.DiscreteStepAnalyzer.phase_count--returns","title":"Returns","text":"<p>int     The number of phases identified.</p> Source code in <code>pylattica/discrete/discrete_step_analyzer.py</code> <pre><code>def phase_count(self, step: SimulationState) -&gt; int:\n    \"\"\"The number of phases present in the specified simulation state.\n\n    Parameters\n    ----------\n    step : SimulationState\n        The state to analyze.\n\n    Returns\n    -------\n    int\n        The number of phases identified.\n    \"\"\"\n    return len(self.phases_present(step))\n</code></pre>"},{"location":"reference/discrete/discrete_step_analyzer/#pylattica.discrete.discrete_step_analyzer.DiscreteStepAnalyzer.phases_present","title":"<code>phases_present(state)</code>","text":"<p>Returns a list of the phases present in the specified state.</p>"},{"location":"reference/discrete/discrete_step_analyzer/#pylattica.discrete.discrete_step_analyzer.DiscreteStepAnalyzer.phases_present--parameters","title":"Parameters","text":"SimulationState <p>The state to analyze.</p>"},{"location":"reference/discrete/discrete_step_analyzer/#pylattica.discrete.discrete_step_analyzer.DiscreteStepAnalyzer.phases_present--returns","title":"Returns","text":"<p>List[str]     A list of the phases identified.</p> Source code in <code>pylattica/discrete/discrete_step_analyzer.py</code> <pre><code>def phases_present(self, state: SimulationState) -&gt; List[str]:\n    \"\"\"Returns a list of the phases present in the specified state.\n\n    Parameters\n    ----------\n    state : SimulationState\n        The state to analyze.\n\n    Returns\n    -------\n    List[str]\n        A list of the phases identified.\n    \"\"\"\n    return list(\n        set(\n            site_state[DISCRETE_OCCUPANCY] for site_state in state.all_site_states()\n        )\n    )\n</code></pre>"},{"location":"reference/discrete/phase_set/","title":"PhaseSet","text":""},{"location":"reference/discrete/phase_set/#pylattica.discrete.phase_set.PhaseSet","title":"<code>PhaseSet</code>","text":"<p>A lightweight class for representing the set of phases possible in a simulation with discrete state occupancies.</p> Source code in <code>pylattica/discrete/phase_set.py</code> <pre><code>class PhaseSet:\n    \"\"\"A lightweight class for representing the set of phases possible in\n    a simulation with discrete state occupancies.\n    \"\"\"\n\n    def __init__(self, phases: List[str]):\n        \"\"\"Instantiates the PhaseSet.\n\n        Parameters\n        ----------\n        phases : List[str]\n            The phases that exist in this simulation.\n        \"\"\"\n        self.phases = list(set(phases))\n</code></pre>"},{"location":"reference/discrete/phase_set/#pylattica.discrete.phase_set.PhaseSet.__init__","title":"<code>__init__(phases)</code>","text":"<p>Instantiates the PhaseSet.</p>"},{"location":"reference/discrete/phase_set/#pylattica.discrete.phase_set.PhaseSet.__init__--parameters","title":"Parameters","text":"List[str] <p>The phases that exist in this simulation.</p> Source code in <code>pylattica/discrete/phase_set.py</code> <pre><code>def __init__(self, phases: List[str]):\n    \"\"\"Instantiates the PhaseSet.\n\n    Parameters\n    ----------\n    phases : List[str]\n        The phases that exist in this simulation.\n    \"\"\"\n    self.phases = list(set(phases))\n</code></pre>"},{"location":"reference/structures/honeycomb/lattice/","title":"Lattice","text":""},{"location":"reference/structures/honeycomb/lattice/#pylattica.structures.honeycomb.lattice.RhombohedralLattice","title":"<code>RhombohedralLattice</code>","text":"<p>         Bases: <code>Lattice</code></p> <p>A helper class for generating rhombohedral lattices.</p> Source code in <code>pylattica/structures/honeycomb/lattice.py</code> <pre><code>class RhombohedralLattice(Lattice):\n    \"\"\"A helper class for generating rhombohedral lattices.\"\"\"\n\n    def __init__(self):\n        lattice_vecs = [\n            (HONEYCOMB_SIDE_LENGTH, 0),\n            (HONEYCOMB_SIDE_LENGTH / 2, ROOT_3 * HONEYCOMB_SIDE_LENGTH / 2),\n        ]\n        super().__init__(lattice_vecs)\n</code></pre>"},{"location":"reference/structures/honeycomb/neighborhoods/","title":"Neighorboods","text":""},{"location":"reference/structures/honeycomb/neighborhoods/#pylattica.structures.honeycomb.neighborhoods.HoneycombNeighborhoodBuilder","title":"<code>HoneycombNeighborhoodBuilder</code>","text":"<p>         Bases: <code>DistanceNeighborhoodBuilder</code></p> <p>A neighborhood for Honeycomb Lattices</p> Source code in <code>pylattica/structures/honeycomb/neighborhoods.py</code> <pre><code>class HoneycombNeighborhoodBuilder(DistanceNeighborhoodBuilder):\n    \"\"\"A neighborhood for Honeycomb Lattices\"\"\"\n\n    def __init__(self):\n        self.cutoff = HONEYCOMB_SIDE_LENGTH + 0.01\n</code></pre>"},{"location":"reference/structures/honeycomb/structure_builders/","title":"StructureBuilders","text":""},{"location":"reference/structures/honeycomb/structure_builders/#pylattica.structures.honeycomb.structure_builders.HoneycombTilingBuilder","title":"<code>HoneycombTilingBuilder</code>","text":"<p>         Bases: <code>StructureBuilder</code></p> <p>A helper class for generating honeycomb tiling structures.</p> Source code in <code>pylattica/structures/honeycomb/structure_builders.py</code> <pre><code>class HoneycombTilingBuilder(StructureBuilder):\n    \"\"\"A helper class for generating honeycomb tiling structures.\"\"\"\n\n    SITE_CLASS = \"A\"\n\n    def __init__(self):\n        self.lattice = RhombohedralLattice()\n        self.frac_coords = True\n        self.motif = {HoneycombTilingBuilder.SITE_CLASS: [(1 / 2, 1 / 2)]}\n</code></pre>"},{"location":"reference/structures/square_grid/grid_setup/","title":"GridSetup","text":""},{"location":"reference/structures/square_grid/grid_setup/#pylattica.structures.square_grid.grid_setup.DiscreteGridSetup","title":"<code>DiscreteGridSetup</code>","text":"<p>A class for setting up states. Provides helper methods for creating starting states in specific shapes</p> Source code in <code>pylattica/structures/square_grid/grid_setup.py</code> <pre><code>class DiscreteGridSetup:\n    \"\"\"A class for setting up states. Provides helper methods for creating starting\n    states in specific shapes\n    \"\"\"\n\n    def __init__(self, phase_set: PhaseSet, dim: int = 2):\n        \"\"\"Initializes a DiscreteGridSetup object by providing a set of phases that is used to\n        specify cell states\n\n        Parameters\n        ----------\n        phase_set : PhaseSet\n            A PhaseSet instance containing the possible phases that might be assigned to cells.\n        dim : int, optional\n            The dimension of the simulations to setup, by default 2\n        \"\"\"\n        if dim == 2:\n            self._builder = SimpleSquare2DStructureBuilder()\n        elif dim == 3:\n            self._builder = SimpleSquare3DStructureBuilder()\n        self.phase_set: PhaseSet = phase_set\n\n    def _build_blank_state(\n        self, structure: PeriodicStructure, fill=None\n    ) -&gt; SimulationState:\n        state = SimulationState()\n        for site in structure.sites():\n            state.set_site_state(site[SITE_ID], {DISCRETE_OCCUPANCY: fill})\n        return state\n\n    def setup_solid_phase(\n        self, structure: PeriodicStructure, phase_name: str\n    ) -&gt; SimulationState:\n        \"\"\"Generates a simulation filled with the specified phase.\n\n        Parameters\n        ----------\n        structure : PeriodicStructure\n            The structure to\n        phase_name : str\n            The name of the phase to fill the structure with.\n\n        Returns\n        -------\n        SimulationState\n            The resulting homogeneous simulation state.\n        \"\"\"\n        state = self._build_blank_state(structure, phase_name)\n        return state\n\n    def setup_interface(self, size: int, p1: str, p2: str) -&gt; Simulation:\n        \"\"\"Generates a starting state that is divided into two phases. One phase\n        occupies the left half of the state, and one phase occupies the right half of the state\n\n        Parameters\n        ----------\n        size : int\n            The side length of the state\n        p1 : str\n            The name of the left phase\n        p2 : str\n            The name of the right phase\n\n        Returns\n        -------\n        Simulation\n            The resulting Simulation.\n        \"\"\"\n        structure = self._builder.build(size=size)\n        state: SimulationState = self._build_blank_state(structure)\n        half: int = int(structure.lattice.vec_lengths[0] / 2)\n        for site in structure.sites():\n            if site[LOCATION][0] &lt; half:\n                state.set_site_state(site[SITE_ID], {DISCRETE_OCCUPANCY: p1})\n            else:\n                state.set_site_state(site[SITE_ID], {DISCRETE_OCCUPANCY: p2})\n        return Simulation(state, structure)\n\n    def setup_particle(\n        self, size: int, radius: int, bulk_phase: str, particle_phase: str\n    ) -&gt; Simulation:\n        \"\"\"Generates a starting state with a bulk phase surrounding a particle in the\n        center of the state.\n\n        Parameters\n        ----------\n        size : int\n            The side length of the state\n        radius : int\n            The radius of the particle\n        bulk_phase : str\n            The name of the bulk\n        particle_phase : str\n            The name of the particle phase\n\n        Returns\n        -------\n        Simulation\n            The resulting Simulation\n        \"\"\"\n        structure = self._builder.build(size=size)\n        state: SimulationState = self.setup_solid_phase(structure, bulk_phase)\n        center: typing.Tuple[int, int] = tuple(\n            structure.lattice.vec_lengths[0] / 2 for _ in range(structure.dim)\n        )\n        state: SimulationState = self.add_particle_to_state(\n            structure, state, center, radius, particle_phase\n        )\n        return Simulation(state, structure)\n\n    def setup_random_particles(\n        self,\n        size: int,\n        radius: int,\n        num_particles: int,\n        bulk_phase: str,\n        particle_phases: str,\n    ) -&gt; Simulation:\n        \"\"\"Generates a starting state with a one phase in the background and num_particles particles distributed\n        onto it randomly\n\n        Parameters\n        ----------\n        size : int\n            The size of the simulation\n        radius : int\n            The radius of the particles to drop\n        num_particles : int\n            The number of particles\n        bulk_phase : str\n            The name of the containing phase\n        particle_phases : str\n            The name of the particulate phase\n\n        Returns\n        -------\n        Simulation\n            The resulting Simulation.\n        \"\"\"\n        structure = self._builder.build(size)\n        state: SimulationState = self.setup_solid_phase(structure, bulk_phase)\n        for _ in range(num_particles):\n            rand_coords = tuple(\n                np.random.choice(int(structure.lattice.vec_lengths[0]))\n                for _ in range(structure.dim)\n            )\n            phase: str = random.choice(particle_phases)\n            state: np.array = self.add_particle_to_state(\n                structure, state, rand_coords, radius, phase\n            )\n\n        return Simulation(state, structure)\n\n    def add_particle_to_state(\n        self,\n        structure: PeriodicStructure,\n        state: SimulationState,\n        center: tuple,\n        radius: int,\n        particle_phase: str,\n    ) -&gt; SimulationState:\n        \"\"\"Adds a region filled with the specified phase to the point specified in the provided structure.\n\n        Parameters\n        ----------\n        structure : PeriodicStructure\n            The structure in which the particle region should be added.\n        state : SimulationState\n            The state in which this change should be reflected\n        center : tuple\n            The coordinates of the center of the desired particle\n        radius : int\n            The radius of the desired particle\n        particle_phase : str\n            The phase of the desired particle\n\n        Returns\n        -------\n        SimulationState\n            The adjusted SimulationState\n        \"\"\"\n        for site in structure.sites():\n            if distance(np.array(site[LOCATION]), np.array(center)) &lt; radius:\n                state.set_site_state(\n                    site[SITE_ID], {DISCRETE_OCCUPANCY: particle_phase}\n                )\n        return state\n\n    def setup_coords(\n        self, size: int, background_state: str, coordinates: dict\n    ) -&gt; Simulation:\n        \"\"\"Generates a simulation filled with a specifed background phase, and specific\n        sites filled with specific phases as defined by the coordinates parameter.\n\n        Parameters\n        ----------\n        size : int\n            The size of the simulation to generate\n        background_state : str\n            The phase with which the background should be filled.\n        coordinates : dict\n            A map of phase name to list of tuples specifying the coordinates to be filled\n            with that phase.\n\n        Returns\n        -------\n        Simulation\n            The resulting Simulation.\n        \"\"\"\n        structure = self._builder.build(size)\n        state: np.array = self.setup_solid_phase(structure, background_state)\n        for phase, coord_list in coordinates.items():\n            for coords in coord_list:\n                site_id = structure.site_at(coords)[SITE_ID]\n                state.set_site_state(site_id, {DISCRETE_OCCUPANCY: phase})\n        return Simulation(state, structure)\n\n    def setup_noise(self, size: int, phases: typing.List[str]) -&gt; Simulation:\n        \"\"\"Generates an initial simulation state with sites randomly assigned one\n        of the provided list of phases\n\n        Parameters\n        ----------\n        size : int\n            The size of the simulation to generate.\n        phases : typing.List[str]\n            The phases to be randomly assigned\n\n        Returns\n        -------\n        Simulation\n            The resulting simulation.\n        \"\"\"\n        structure = self._builder.build(size)\n        state: SimulationState = self._build_blank_state(structure)\n        for site in structure.sites():\n            state.set_site_state(\n                site[SITE_ID], {DISCRETE_OCCUPANCY: random.choice(phases)}\n            )\n        return Simulation(state, structure)\n\n    def setup_random_sites(\n        self,\n        size: int,\n        num_sites_desired: int,\n        background_spec: str,\n        nuc_amts: typing.Dict[str, float],\n        buffer: int = 2,\n    ) -&gt; Simulation:\n        \"\"\"Generates an initial simulation state with a background phase filling space and\n        random sites filled in with other phases as specified by the provided ratios.\n\n        Parameters\n        ----------\n        size : int\n            The size of the simulation to generate.\n        num_sites_desired : int\n            The number of non-background sites to select\n        background_spec : str\n            The phase of the background\n        nuc_amts : typing.Dict[str, float]\n            The ratios of the phases to assign to the selected sites\n        buffer : int, optional\n            The minimum distance between selected sites, by default 2\n\n        Returns\n        -------\n        Simulation\n            The resulting Simulation\n\n        Raises\n        ------\n        RuntimeError\n            If the buffer between sites is too large, and the num_sites_desired cannot fit\n            in the specifed simulation size, a RuntimeError is thrown\n        \"\"\"\n        structure = self._builder.build(size)\n        num_sites_desired = round(num_sites_desired)\n        state = self.setup_solid_phase(structure, background_spec)\n        if buffer is not None:\n            nb_spec: MooreNbHoodBuilder = MooreNbHoodBuilder(buffer, dim=structure.dim)\n            nb_graph: Neighborhood = nb_spec.get(structure)\n        all_sites = structure.sites()\n\n        nuc_species = []\n        nuc_ratios = []\n\n        for spec, amt in nuc_amts.items():\n            nuc_species.append(spec)\n            nuc_ratios.append(amt)\n\n        normalized_ratios = np.array(nuc_ratios) / np.sum(nuc_ratios)\n\n        total_attempts = 0\n        num_sites_planted = 0\n\n        ideal_num_site_list = normalized_ratios * num_sites_desired\n        ideal_num_sites = dict(zip(nuc_species, ideal_num_site_list))\n\n        nuc_identities = []\n\n        real_num_sites = {p: 0 for p in nuc_species}\n\n        spec_provider = cycle(nuc_species)\n        while len(nuc_identities) &lt; num_sites_desired:\n            phase = next(spec_provider)\n\n            if real_num_sites.get(phase) &lt; ideal_num_sites.get(phase):\n                nuc_identities.append(phase)\n                real_num_sites[phase] += 1\n\n        while num_sites_planted &lt; num_sites_desired:\n            if total_attempts &gt; 1000 * num_sites_desired:\n                raise RuntimeError(\n                    f\"Too many nucleation sites at the specified buffer: {total_attempts} made at placing nuclei\"\n                )\n\n            rand_site = random.choice(all_sites)\n            rand_site_id = rand_site[SITE_ID]\n            if (\n                state.get_site_state(rand_site_id)[DISCRETE_OCCUPANCY]\n                != background_spec\n            ):\n                total_attempts += 1\n                continue\n\n            found_existing_nucleus_in_nb = False\n\n            if buffer is not None:\n                for nb_site_id in nb_graph.neighbors_of(rand_site_id):\n                    if (\n                        state.get_site_state(nb_site_id)[DISCRETE_OCCUPANCY]\n                        != background_spec\n                    ):\n                        found_existing_nucleus_in_nb = True\n\n            if not found_existing_nucleus_in_nb:\n                chosen_spec = nuc_identities[num_sites_planted]\n                state.set_site_state(rand_site_id, {DISCRETE_OCCUPANCY: chosen_spec})\n\n                num_sites_planted += 1\n\n            total_attempts += 1\n\n        return Simulation(state, structure)\n</code></pre>"},{"location":"reference/structures/square_grid/grid_setup/#pylattica.structures.square_grid.grid_setup.DiscreteGridSetup.__init__","title":"<code>__init__(phase_set, dim=2)</code>","text":"<p>Initializes a DiscreteGridSetup object by providing a set of phases that is used to specify cell states</p>"},{"location":"reference/structures/square_grid/grid_setup/#pylattica.structures.square_grid.grid_setup.DiscreteGridSetup.__init__--parameters","title":"Parameters","text":"PhaseSet <p>A PhaseSet instance containing the possible phases that might be assigned to cells.</p> int, optional <p>The dimension of the simulations to setup, by default 2</p> Source code in <code>pylattica/structures/square_grid/grid_setup.py</code> <pre><code>def __init__(self, phase_set: PhaseSet, dim: int = 2):\n    \"\"\"Initializes a DiscreteGridSetup object by providing a set of phases that is used to\n    specify cell states\n\n    Parameters\n    ----------\n    phase_set : PhaseSet\n        A PhaseSet instance containing the possible phases that might be assigned to cells.\n    dim : int, optional\n        The dimension of the simulations to setup, by default 2\n    \"\"\"\n    if dim == 2:\n        self._builder = SimpleSquare2DStructureBuilder()\n    elif dim == 3:\n        self._builder = SimpleSquare3DStructureBuilder()\n    self.phase_set: PhaseSet = phase_set\n</code></pre>"},{"location":"reference/structures/square_grid/grid_setup/#pylattica.structures.square_grid.grid_setup.DiscreteGridSetup.add_particle_to_state","title":"<code>add_particle_to_state(structure, state, center, radius, particle_phase)</code>","text":"<p>Adds a region filled with the specified phase to the point specified in the provided structure.</p>"},{"location":"reference/structures/square_grid/grid_setup/#pylattica.structures.square_grid.grid_setup.DiscreteGridSetup.add_particle_to_state--parameters","title":"Parameters","text":"PeriodicStructure <p>The structure in which the particle region should be added.</p> SimulationState <p>The state in which this change should be reflected</p> tuple <p>The coordinates of the center of the desired particle</p> int <p>The radius of the desired particle</p> str <p>The phase of the desired particle</p>"},{"location":"reference/structures/square_grid/grid_setup/#pylattica.structures.square_grid.grid_setup.DiscreteGridSetup.add_particle_to_state--returns","title":"Returns","text":"<p>SimulationState     The adjusted SimulationState</p> Source code in <code>pylattica/structures/square_grid/grid_setup.py</code> <pre><code>def add_particle_to_state(\n    self,\n    structure: PeriodicStructure,\n    state: SimulationState,\n    center: tuple,\n    radius: int,\n    particle_phase: str,\n) -&gt; SimulationState:\n    \"\"\"Adds a region filled with the specified phase to the point specified in the provided structure.\n\n    Parameters\n    ----------\n    structure : PeriodicStructure\n        The structure in which the particle region should be added.\n    state : SimulationState\n        The state in which this change should be reflected\n    center : tuple\n        The coordinates of the center of the desired particle\n    radius : int\n        The radius of the desired particle\n    particle_phase : str\n        The phase of the desired particle\n\n    Returns\n    -------\n    SimulationState\n        The adjusted SimulationState\n    \"\"\"\n    for site in structure.sites():\n        if distance(np.array(site[LOCATION]), np.array(center)) &lt; radius:\n            state.set_site_state(\n                site[SITE_ID], {DISCRETE_OCCUPANCY: particle_phase}\n            )\n    return state\n</code></pre>"},{"location":"reference/structures/square_grid/grid_setup/#pylattica.structures.square_grid.grid_setup.DiscreteGridSetup.setup_coords","title":"<code>setup_coords(size, background_state, coordinates)</code>","text":"<p>Generates a simulation filled with a specifed background phase, and specific sites filled with specific phases as defined by the coordinates parameter.</p>"},{"location":"reference/structures/square_grid/grid_setup/#pylattica.structures.square_grid.grid_setup.DiscreteGridSetup.setup_coords--parameters","title":"Parameters","text":"int <p>The size of the simulation to generate</p> str <p>The phase with which the background should be filled.</p> dict <p>A map of phase name to list of tuples specifying the coordinates to be filled with that phase.</p>"},{"location":"reference/structures/square_grid/grid_setup/#pylattica.structures.square_grid.grid_setup.DiscreteGridSetup.setup_coords--returns","title":"Returns","text":"<p>Simulation     The resulting Simulation.</p> Source code in <code>pylattica/structures/square_grid/grid_setup.py</code> <pre><code>def setup_coords(\n    self, size: int, background_state: str, coordinates: dict\n) -&gt; Simulation:\n    \"\"\"Generates a simulation filled with a specifed background phase, and specific\n    sites filled with specific phases as defined by the coordinates parameter.\n\n    Parameters\n    ----------\n    size : int\n        The size of the simulation to generate\n    background_state : str\n        The phase with which the background should be filled.\n    coordinates : dict\n        A map of phase name to list of tuples specifying the coordinates to be filled\n        with that phase.\n\n    Returns\n    -------\n    Simulation\n        The resulting Simulation.\n    \"\"\"\n    structure = self._builder.build(size)\n    state: np.array = self.setup_solid_phase(structure, background_state)\n    for phase, coord_list in coordinates.items():\n        for coords in coord_list:\n            site_id = structure.site_at(coords)[SITE_ID]\n            state.set_site_state(site_id, {DISCRETE_OCCUPANCY: phase})\n    return Simulation(state, structure)\n</code></pre>"},{"location":"reference/structures/square_grid/grid_setup/#pylattica.structures.square_grid.grid_setup.DiscreteGridSetup.setup_interface","title":"<code>setup_interface(size, p1, p2)</code>","text":"<p>Generates a starting state that is divided into two phases. One phase occupies the left half of the state, and one phase occupies the right half of the state</p>"},{"location":"reference/structures/square_grid/grid_setup/#pylattica.structures.square_grid.grid_setup.DiscreteGridSetup.setup_interface--parameters","title":"Parameters","text":"int <p>The side length of the state</p> str <p>The name of the left phase</p> str <p>The name of the right phase</p>"},{"location":"reference/structures/square_grid/grid_setup/#pylattica.structures.square_grid.grid_setup.DiscreteGridSetup.setup_interface--returns","title":"Returns","text":"<p>Simulation     The resulting Simulation.</p> Source code in <code>pylattica/structures/square_grid/grid_setup.py</code> <pre><code>def setup_interface(self, size: int, p1: str, p2: str) -&gt; Simulation:\n    \"\"\"Generates a starting state that is divided into two phases. One phase\n    occupies the left half of the state, and one phase occupies the right half of the state\n\n    Parameters\n    ----------\n    size : int\n        The side length of the state\n    p1 : str\n        The name of the left phase\n    p2 : str\n        The name of the right phase\n\n    Returns\n    -------\n    Simulation\n        The resulting Simulation.\n    \"\"\"\n    structure = self._builder.build(size=size)\n    state: SimulationState = self._build_blank_state(structure)\n    half: int = int(structure.lattice.vec_lengths[0] / 2)\n    for site in structure.sites():\n        if site[LOCATION][0] &lt; half:\n            state.set_site_state(site[SITE_ID], {DISCRETE_OCCUPANCY: p1})\n        else:\n            state.set_site_state(site[SITE_ID], {DISCRETE_OCCUPANCY: p2})\n    return Simulation(state, structure)\n</code></pre>"},{"location":"reference/structures/square_grid/grid_setup/#pylattica.structures.square_grid.grid_setup.DiscreteGridSetup.setup_noise","title":"<code>setup_noise(size, phases)</code>","text":"<p>Generates an initial simulation state with sites randomly assigned one of the provided list of phases</p>"},{"location":"reference/structures/square_grid/grid_setup/#pylattica.structures.square_grid.grid_setup.DiscreteGridSetup.setup_noise--parameters","title":"Parameters","text":"int <p>The size of the simulation to generate.</p> typing.List[str] <p>The phases to be randomly assigned</p>"},{"location":"reference/structures/square_grid/grid_setup/#pylattica.structures.square_grid.grid_setup.DiscreteGridSetup.setup_noise--returns","title":"Returns","text":"<p>Simulation     The resulting simulation.</p> Source code in <code>pylattica/structures/square_grid/grid_setup.py</code> <pre><code>def setup_noise(self, size: int, phases: typing.List[str]) -&gt; Simulation:\n    \"\"\"Generates an initial simulation state with sites randomly assigned one\n    of the provided list of phases\n\n    Parameters\n    ----------\n    size : int\n        The size of the simulation to generate.\n    phases : typing.List[str]\n        The phases to be randomly assigned\n\n    Returns\n    -------\n    Simulation\n        The resulting simulation.\n    \"\"\"\n    structure = self._builder.build(size)\n    state: SimulationState = self._build_blank_state(structure)\n    for site in structure.sites():\n        state.set_site_state(\n            site[SITE_ID], {DISCRETE_OCCUPANCY: random.choice(phases)}\n        )\n    return Simulation(state, structure)\n</code></pre>"},{"location":"reference/structures/square_grid/grid_setup/#pylattica.structures.square_grid.grid_setup.DiscreteGridSetup.setup_particle","title":"<code>setup_particle(size, radius, bulk_phase, particle_phase)</code>","text":"<p>Generates a starting state with a bulk phase surrounding a particle in the center of the state.</p>"},{"location":"reference/structures/square_grid/grid_setup/#pylattica.structures.square_grid.grid_setup.DiscreteGridSetup.setup_particle--parameters","title":"Parameters","text":"int <p>The side length of the state</p> int <p>The radius of the particle</p> str <p>The name of the bulk</p> str <p>The name of the particle phase</p>"},{"location":"reference/structures/square_grid/grid_setup/#pylattica.structures.square_grid.grid_setup.DiscreteGridSetup.setup_particle--returns","title":"Returns","text":"<p>Simulation     The resulting Simulation</p> Source code in <code>pylattica/structures/square_grid/grid_setup.py</code> <pre><code>def setup_particle(\n    self, size: int, radius: int, bulk_phase: str, particle_phase: str\n) -&gt; Simulation:\n    \"\"\"Generates a starting state with a bulk phase surrounding a particle in the\n    center of the state.\n\n    Parameters\n    ----------\n    size : int\n        The side length of the state\n    radius : int\n        The radius of the particle\n    bulk_phase : str\n        The name of the bulk\n    particle_phase : str\n        The name of the particle phase\n\n    Returns\n    -------\n    Simulation\n        The resulting Simulation\n    \"\"\"\n    structure = self._builder.build(size=size)\n    state: SimulationState = self.setup_solid_phase(structure, bulk_phase)\n    center: typing.Tuple[int, int] = tuple(\n        structure.lattice.vec_lengths[0] / 2 for _ in range(structure.dim)\n    )\n    state: SimulationState = self.add_particle_to_state(\n        structure, state, center, radius, particle_phase\n    )\n    return Simulation(state, structure)\n</code></pre>"},{"location":"reference/structures/square_grid/grid_setup/#pylattica.structures.square_grid.grid_setup.DiscreteGridSetup.setup_random_particles","title":"<code>setup_random_particles(size, radius, num_particles, bulk_phase, particle_phases)</code>","text":"<p>Generates a starting state with a one phase in the background and num_particles particles distributed onto it randomly</p>"},{"location":"reference/structures/square_grid/grid_setup/#pylattica.structures.square_grid.grid_setup.DiscreteGridSetup.setup_random_particles--parameters","title":"Parameters","text":"int <p>The size of the simulation</p> int <p>The radius of the particles to drop</p> int <p>The number of particles</p> str <p>The name of the containing phase</p> str <p>The name of the particulate phase</p>"},{"location":"reference/structures/square_grid/grid_setup/#pylattica.structures.square_grid.grid_setup.DiscreteGridSetup.setup_random_particles--returns","title":"Returns","text":"<p>Simulation     The resulting Simulation.</p> Source code in <code>pylattica/structures/square_grid/grid_setup.py</code> <pre><code>def setup_random_particles(\n    self,\n    size: int,\n    radius: int,\n    num_particles: int,\n    bulk_phase: str,\n    particle_phases: str,\n) -&gt; Simulation:\n    \"\"\"Generates a starting state with a one phase in the background and num_particles particles distributed\n    onto it randomly\n\n    Parameters\n    ----------\n    size : int\n        The size of the simulation\n    radius : int\n        The radius of the particles to drop\n    num_particles : int\n        The number of particles\n    bulk_phase : str\n        The name of the containing phase\n    particle_phases : str\n        The name of the particulate phase\n\n    Returns\n    -------\n    Simulation\n        The resulting Simulation.\n    \"\"\"\n    structure = self._builder.build(size)\n    state: SimulationState = self.setup_solid_phase(structure, bulk_phase)\n    for _ in range(num_particles):\n        rand_coords = tuple(\n            np.random.choice(int(structure.lattice.vec_lengths[0]))\n            for _ in range(structure.dim)\n        )\n        phase: str = random.choice(particle_phases)\n        state: np.array = self.add_particle_to_state(\n            structure, state, rand_coords, radius, phase\n        )\n\n    return Simulation(state, structure)\n</code></pre>"},{"location":"reference/structures/square_grid/grid_setup/#pylattica.structures.square_grid.grid_setup.DiscreteGridSetup.setup_random_sites","title":"<code>setup_random_sites(size, num_sites_desired, background_spec, nuc_amts, buffer=2)</code>","text":"<p>Generates an initial simulation state with a background phase filling space and random sites filled in with other phases as specified by the provided ratios.</p>"},{"location":"reference/structures/square_grid/grid_setup/#pylattica.structures.square_grid.grid_setup.DiscreteGridSetup.setup_random_sites--parameters","title":"Parameters","text":"int <p>The size of the simulation to generate.</p> int <p>The number of non-background sites to select</p> str <p>The phase of the background</p> typing.Dict[str, float] <p>The ratios of the phases to assign to the selected sites</p> int, optional <p>The minimum distance between selected sites, by default 2</p>"},{"location":"reference/structures/square_grid/grid_setup/#pylattica.structures.square_grid.grid_setup.DiscreteGridSetup.setup_random_sites--returns","title":"Returns","text":"<p>Simulation     The resulting Simulation</p>"},{"location":"reference/structures/square_grid/grid_setup/#pylattica.structures.square_grid.grid_setup.DiscreteGridSetup.setup_random_sites--raises","title":"Raises","text":"<p>RuntimeError     If the buffer between sites is too large, and the num_sites_desired cannot fit     in the specifed simulation size, a RuntimeError is thrown</p> Source code in <code>pylattica/structures/square_grid/grid_setup.py</code> <pre><code>def setup_random_sites(\n    self,\n    size: int,\n    num_sites_desired: int,\n    background_spec: str,\n    nuc_amts: typing.Dict[str, float],\n    buffer: int = 2,\n) -&gt; Simulation:\n    \"\"\"Generates an initial simulation state with a background phase filling space and\n    random sites filled in with other phases as specified by the provided ratios.\n\n    Parameters\n    ----------\n    size : int\n        The size of the simulation to generate.\n    num_sites_desired : int\n        The number of non-background sites to select\n    background_spec : str\n        The phase of the background\n    nuc_amts : typing.Dict[str, float]\n        The ratios of the phases to assign to the selected sites\n    buffer : int, optional\n        The minimum distance between selected sites, by default 2\n\n    Returns\n    -------\n    Simulation\n        The resulting Simulation\n\n    Raises\n    ------\n    RuntimeError\n        If the buffer between sites is too large, and the num_sites_desired cannot fit\n        in the specifed simulation size, a RuntimeError is thrown\n    \"\"\"\n    structure = self._builder.build(size)\n    num_sites_desired = round(num_sites_desired)\n    state = self.setup_solid_phase(structure, background_spec)\n    if buffer is not None:\n        nb_spec: MooreNbHoodBuilder = MooreNbHoodBuilder(buffer, dim=structure.dim)\n        nb_graph: Neighborhood = nb_spec.get(structure)\n    all_sites = structure.sites()\n\n    nuc_species = []\n    nuc_ratios = []\n\n    for spec, amt in nuc_amts.items():\n        nuc_species.append(spec)\n        nuc_ratios.append(amt)\n\n    normalized_ratios = np.array(nuc_ratios) / np.sum(nuc_ratios)\n\n    total_attempts = 0\n    num_sites_planted = 0\n\n    ideal_num_site_list = normalized_ratios * num_sites_desired\n    ideal_num_sites = dict(zip(nuc_species, ideal_num_site_list))\n\n    nuc_identities = []\n\n    real_num_sites = {p: 0 for p in nuc_species}\n\n    spec_provider = cycle(nuc_species)\n    while len(nuc_identities) &lt; num_sites_desired:\n        phase = next(spec_provider)\n\n        if real_num_sites.get(phase) &lt; ideal_num_sites.get(phase):\n            nuc_identities.append(phase)\n            real_num_sites[phase] += 1\n\n    while num_sites_planted &lt; num_sites_desired:\n        if total_attempts &gt; 1000 * num_sites_desired:\n            raise RuntimeError(\n                f\"Too many nucleation sites at the specified buffer: {total_attempts} made at placing nuclei\"\n            )\n\n        rand_site = random.choice(all_sites)\n        rand_site_id = rand_site[SITE_ID]\n        if (\n            state.get_site_state(rand_site_id)[DISCRETE_OCCUPANCY]\n            != background_spec\n        ):\n            total_attempts += 1\n            continue\n\n        found_existing_nucleus_in_nb = False\n\n        if buffer is not None:\n            for nb_site_id in nb_graph.neighbors_of(rand_site_id):\n                if (\n                    state.get_site_state(nb_site_id)[DISCRETE_OCCUPANCY]\n                    != background_spec\n                ):\n                    found_existing_nucleus_in_nb = True\n\n        if not found_existing_nucleus_in_nb:\n            chosen_spec = nuc_identities[num_sites_planted]\n            state.set_site_state(rand_site_id, {DISCRETE_OCCUPANCY: chosen_spec})\n\n            num_sites_planted += 1\n\n        total_attempts += 1\n\n    return Simulation(state, structure)\n</code></pre>"},{"location":"reference/structures/square_grid/grid_setup/#pylattica.structures.square_grid.grid_setup.DiscreteGridSetup.setup_solid_phase","title":"<code>setup_solid_phase(structure, phase_name)</code>","text":"<p>Generates a simulation filled with the specified phase.</p>"},{"location":"reference/structures/square_grid/grid_setup/#pylattica.structures.square_grid.grid_setup.DiscreteGridSetup.setup_solid_phase--parameters","title":"Parameters","text":"PeriodicStructure <p>The structure to</p> str <p>The name of the phase to fill the structure with.</p>"},{"location":"reference/structures/square_grid/grid_setup/#pylattica.structures.square_grid.grid_setup.DiscreteGridSetup.setup_solid_phase--returns","title":"Returns","text":"<p>SimulationState     The resulting homogeneous simulation state.</p> Source code in <code>pylattica/structures/square_grid/grid_setup.py</code> <pre><code>def setup_solid_phase(\n    self, structure: PeriodicStructure, phase_name: str\n) -&gt; SimulationState:\n    \"\"\"Generates a simulation filled with the specified phase.\n\n    Parameters\n    ----------\n    structure : PeriodicStructure\n        The structure to\n    phase_name : str\n        The name of the phase to fill the structure with.\n\n    Returns\n    -------\n    SimulationState\n        The resulting homogeneous simulation state.\n    \"\"\"\n    state = self._build_blank_state(structure, phase_name)\n    return state\n</code></pre>"},{"location":"reference/structures/square_grid/growth_setup/","title":"GrowthSetup","text":""},{"location":"reference/structures/square_grid/growth_setup/#pylattica.structures.square_grid.growth_setup.GrowthSetup","title":"<code>GrowthSetup</code>","text":"<p>A class for generating simulation starting states by a growth + impingement algorithm. This algorithm can be summarized as follows:</p> <ol> <li>Random sites are selected in the strucure and assigned phases in the ratios specified.</li> <li>A simulation is run in which unassigned cells adopt the phase of their occupied neighbors, allowing particles to \"grow\" outward into unoccupied space until they impinge on one another.</li> </ol> Source code in <code>pylattica/structures/square_grid/growth_setup.py</code> <pre><code>class GrowthSetup:\n    \"\"\"A class for generating simulation starting states by a growth + impingement algorithm.\n    This algorithm can be summarized as follows:\n\n    1. Random sites are selected in the strucure and assigned phases in the ratios\n    specified.\n    2. A simulation is run in which unassigned cells adopt the phase of their occupied\n    neighbors, allowing particles to \"grow\" outward into unoccupied space until they\n    impinge on one another.\n    \"\"\"\n\n    def __init__(self, phase_set: PhaseSet, dim=2):\n        \"\"\"Instantiates the GrowthSetup object.\n\n        Parameters\n        ----------\n        phase_set : PhaseSet\n            The phases to be used in the growth process.\n        dim : int, optional\n            The dimension of the desired simulation., by default 2\n        \"\"\"\n        self._phases = phase_set\n        self.dim = dim\n\n    def grow(\n        self,\n        size: int,\n        num_sites_desired: int,\n        background_spec: str,\n        nuc_amts: Dict[str, float],\n        nb_builder: NeighborhoodBuilder,\n        buffer: int = 2,\n    ) -&gt; Simulation:\n        \"\"\"Runs the growth simulation and produces a starting state.\n\n        Parameters\n        ----------\n        size : int\n            The size of the desired simulation.\n        num_sites_desired : int\n            The number of nucleation sites for growing particles.\n        background_spec : str\n            The background species.\n        nuc_amts : Dict[str, float]\n            A mapping of phase names to their relative desired amounts.\n        nb_builder : NeighborhoodBuilder\n            The NeighborhoodBuilder to use to identify the growth environment for\n            each particle.\n        buffer : int, optional\n            The minimum distance between seed sites, by default 2\n\n        Returns\n        -------\n        Simulation\n            The resulting Simulation.\n        \"\"\"\n        setup = DiscreteGridSetup(self._phases, dim=self.dim)\n\n        simulation = setup.setup_random_sites(\n            size,\n            num_sites_desired=num_sites_desired,\n            background_spec=background_spec,\n            nuc_amts=nuc_amts,\n            buffer=buffer,\n        )\n\n        controller = GrowthController(\n            self._phases,\n            simulation.structure,\n            nb_builder=nb_builder,\n            background_phase=background_spec,\n        )\n\n        runner = SynchronousRunner(parallel=True)\n        res = runner.run(simulation.state, controller, num_steps=size)\n        return Simulation(res.last_step, simulation.structure)\n</code></pre>"},{"location":"reference/structures/square_grid/growth_setup/#pylattica.structures.square_grid.growth_setup.GrowthSetup.__init__","title":"<code>__init__(phase_set, dim=2)</code>","text":"<p>Instantiates the GrowthSetup object.</p>"},{"location":"reference/structures/square_grid/growth_setup/#pylattica.structures.square_grid.growth_setup.GrowthSetup.__init__--parameters","title":"Parameters","text":"PhaseSet <p>The phases to be used in the growth process.</p> int, optional <p>The dimension of the desired simulation., by default 2</p> Source code in <code>pylattica/structures/square_grid/growth_setup.py</code> <pre><code>def __init__(self, phase_set: PhaseSet, dim=2):\n    \"\"\"Instantiates the GrowthSetup object.\n\n    Parameters\n    ----------\n    phase_set : PhaseSet\n        The phases to be used in the growth process.\n    dim : int, optional\n        The dimension of the desired simulation., by default 2\n    \"\"\"\n    self._phases = phase_set\n    self.dim = dim\n</code></pre>"},{"location":"reference/structures/square_grid/growth_setup/#pylattica.structures.square_grid.growth_setup.GrowthSetup.grow","title":"<code>grow(size, num_sites_desired, background_spec, nuc_amts, nb_builder, buffer=2)</code>","text":"<p>Runs the growth simulation and produces a starting state.</p>"},{"location":"reference/structures/square_grid/growth_setup/#pylattica.structures.square_grid.growth_setup.GrowthSetup.grow--parameters","title":"Parameters","text":"int <p>The size of the desired simulation.</p> int <p>The number of nucleation sites for growing particles.</p> str <p>The background species.</p> Dict[str, float] <p>A mapping of phase names to their relative desired amounts.</p> NeighborhoodBuilder <p>The NeighborhoodBuilder to use to identify the growth environment for each particle.</p> int, optional <p>The minimum distance between seed sites, by default 2</p>"},{"location":"reference/structures/square_grid/growth_setup/#pylattica.structures.square_grid.growth_setup.GrowthSetup.grow--returns","title":"Returns","text":"<p>Simulation     The resulting Simulation.</p> Source code in <code>pylattica/structures/square_grid/growth_setup.py</code> <pre><code>def grow(\n    self,\n    size: int,\n    num_sites_desired: int,\n    background_spec: str,\n    nuc_amts: Dict[str, float],\n    nb_builder: NeighborhoodBuilder,\n    buffer: int = 2,\n) -&gt; Simulation:\n    \"\"\"Runs the growth simulation and produces a starting state.\n\n    Parameters\n    ----------\n    size : int\n        The size of the desired simulation.\n    num_sites_desired : int\n        The number of nucleation sites for growing particles.\n    background_spec : str\n        The background species.\n    nuc_amts : Dict[str, float]\n        A mapping of phase names to their relative desired amounts.\n    nb_builder : NeighborhoodBuilder\n        The NeighborhoodBuilder to use to identify the growth environment for\n        each particle.\n    buffer : int, optional\n        The minimum distance between seed sites, by default 2\n\n    Returns\n    -------\n    Simulation\n        The resulting Simulation.\n    \"\"\"\n    setup = DiscreteGridSetup(self._phases, dim=self.dim)\n\n    simulation = setup.setup_random_sites(\n        size,\n        num_sites_desired=num_sites_desired,\n        background_spec=background_spec,\n        nuc_amts=nuc_amts,\n        buffer=buffer,\n    )\n\n    controller = GrowthController(\n        self._phases,\n        simulation.structure,\n        nb_builder=nb_builder,\n        background_phase=background_spec,\n    )\n\n    runner = SynchronousRunner(parallel=True)\n    res = runner.run(simulation.state, controller, num_steps=size)\n    return Simulation(res.last_step, simulation.structure)\n</code></pre>"},{"location":"reference/structures/square_grid/lattice/","title":"Lattice","text":""},{"location":"reference/structures/square_grid/lattice/#pylattica.structures.square_grid.lattice.SquareGridLattice2D","title":"<code>SquareGridLattice2D</code>","text":"<p>         Bases: <code>Lattice</code></p> <p>A helper class for generating square 2D grid lattices.</p> Source code in <code>pylattica/structures/square_grid/lattice.py</code> <pre><code>class SquareGridLattice2D(Lattice):\n    \"\"\"A helper class for generating square 2D grid lattices.\"\"\"\n\n    def __init__(self):\n        lattice_vecs = [(0, 1), (1, 0)]\n        super().__init__(lattice_vecs)\n</code></pre>"},{"location":"reference/structures/square_grid/lattice/#pylattica.structures.square_grid.lattice.SquareGridLattice3D","title":"<code>SquareGridLattice3D</code>","text":"<p>         Bases: <code>Lattice</code></p> <p>A helper class for generating square 3D grid lattices.</p> Source code in <code>pylattica/structures/square_grid/lattice.py</code> <pre><code>class SquareGridLattice3D(Lattice):\n    \"\"\"A helper class for generating square 3D grid lattices.\"\"\"\n\n    def __init__(self):\n        lattice_vecs = [(0, 1, 0), (1, 0, 0), (0, 0, 1)]\n        super().__init__(lattice_vecs)\n</code></pre>"},{"location":"reference/structures/square_grid/neighborhoods/","title":"Neighorboods","text":""},{"location":"reference/structures/square_grid/neighborhoods/#pylattica.structures.square_grid.neighborhoods.CircularNeighborhoodBuilder","title":"<code>CircularNeighborhoodBuilder</code>","text":"<p>         Bases: <code>DistanceNeighborhoodBuilder</code></p> <p>A semantic class for generating Circular neighborhoods in any structure.</p> Source code in <code>pylattica/structures/square_grid/neighborhoods.py</code> <pre><code>class CircularNeighborhoodBuilder(DistanceNeighborhoodBuilder):\n    \"\"\"A semantic class for generating Circular neighborhoods in any structure.\"\"\"\n</code></pre>"},{"location":"reference/structures/square_grid/neighborhoods/#pylattica.structures.square_grid.neighborhoods.MooreNbHoodBuilder","title":"<code>MooreNbHoodBuilder</code>","text":"<p>         Bases: <code>MotifNeighborhoodBuilder</code></p> <p>A helper class for generating Moore type neighborhoods in square structures.</p> Source code in <code>pylattica/structures/square_grid/neighborhoods.py</code> <pre><code>class MooreNbHoodBuilder(MotifNeighborhoodBuilder):\n    \"\"\"A helper class for generating Moore type neighborhoods in square structures.\"\"\"\n\n    def __init__(self, size=1, dim=2):\n        \"\"\"Constructs the MooreNbHoodBuilder\n\n        Parameters\n        ----------\n        size : int, optional\n            The size of the neighborhood, by default 1\n        dim : int, optional\n            The dimension of the structures to which this builder will apply, by default 2\n        \"\"\"\n        points = get_points_in_cube(-size, size + 1, dim)\n        super().__init__(points)\n</code></pre>"},{"location":"reference/structures/square_grid/neighborhoods/#pylattica.structures.square_grid.neighborhoods.MooreNbHoodBuilder.__init__","title":"<code>__init__(size=1, dim=2)</code>","text":"<p>Constructs the MooreNbHoodBuilder</p>"},{"location":"reference/structures/square_grid/neighborhoods/#pylattica.structures.square_grid.neighborhoods.MooreNbHoodBuilder.__init__--parameters","title":"Parameters","text":"int, optional <p>The size of the neighborhood, by default 1</p> int, optional <p>The dimension of the structures to which this builder will apply, by default 2</p> Source code in <code>pylattica/structures/square_grid/neighborhoods.py</code> <pre><code>def __init__(self, size=1, dim=2):\n    \"\"\"Constructs the MooreNbHoodBuilder\n\n    Parameters\n    ----------\n    size : int, optional\n        The size of the neighborhood, by default 1\n    dim : int, optional\n        The dimension of the structures to which this builder will apply, by default 2\n    \"\"\"\n    points = get_points_in_cube(-size, size + 1, dim)\n    super().__init__(points)\n</code></pre>"},{"location":"reference/structures/square_grid/neighborhoods/#pylattica.structures.square_grid.neighborhoods.PseudoHexagonalNeighborhoodBuilder3D","title":"<code>PseudoHexagonalNeighborhoodBuilder3D</code>","text":"<p>         Bases: <code>StochasticNeighborhoodBuilder</code></p> <p>A helper class for generating Pseudohexagonal neighborhoods in 3D.</p> Source code in <code>pylattica/structures/square_grid/neighborhoods.py</code> <pre><code>class PseudoHexagonalNeighborhoodBuilder3D(StochasticNeighborhoodBuilder):\n    \"\"\"A helper class for generating Pseudohexagonal neighborhoods in 3D.\"\"\"\n\n    def __init__(self):\n        common_neighbors = [\n            (1, 0, 0),\n            (-1, 0, 0),\n            (0, 1, 0),\n            (0, -1, 0),\n            (0, 0, 1),\n            (0, 0, -1),\n        ]\n        motifs = [\n            [\n                *common_neighbors,\n                (-1, -1, 1),\n                (1, 1, -1),\n            ],\n            [\n                *common_neighbors,\n                (-1, 1, 1),\n                (1, -1, -1),\n            ],\n            [\n                *common_neighbors,\n                (1, 1, 1),\n                (-1, -1, -1),\n            ],\n            [\n                *common_neighbors,\n                (1, -1, 1),\n                (-1, 1, -1),\n            ],\n        ]\n        super().__init__([MotifNeighborhoodBuilder(m) for m in motifs])\n</code></pre>"},{"location":"reference/structures/square_grid/neighborhoods/#pylattica.structures.square_grid.neighborhoods.PseudoPentagonalNeighborhoodBuilder","title":"<code>PseudoPentagonalNeighborhoodBuilder</code>","text":"<p>         Bases: <code>StochasticNeighborhoodBuilder</code></p> <p>A helper class for generating Pseudopentagonal neighborhoods in 2D.</p> Source code in <code>pylattica/structures/square_grid/neighborhoods.py</code> <pre><code>class PseudoPentagonalNeighborhoodBuilder(StochasticNeighborhoodBuilder):\n    \"\"\"A helper class for generating Pseudopentagonal neighborhoods in 2D.\"\"\"\n\n    def __init__(self):\n        motifs = [\n            [\n                (-1, 0),\n                (1, 0),\n                (-1, -1),\n                (0, -1),\n                (1, -1),\n            ],\n            [\n                (-1, 1),\n                (0, 1),\n                (1, 1),\n                (-1, 0),\n                (1, 0),\n            ],\n            [\n                (0, 1),\n                (1, 1),\n                (1, 0),\n                (0, -1),\n                (1, -1),\n            ],\n            [\n                (-1, 1),\n                (0, 1),\n                (-1, 0),\n                (-1, -1),\n                (0, -1),\n            ],\n        ]\n        self.builders = [MotifNeighborhoodBuilder(m) for m in motifs]\n</code></pre>"},{"location":"reference/structures/square_grid/neighborhoods/#pylattica.structures.square_grid.neighborhoods.VonNeumannNbHood2DBuilder","title":"<code>VonNeumannNbHood2DBuilder</code>","text":"<p>         Bases: <code>MotifNeighborhoodBuilder</code></p> <p>A helper class for generating von Neumann type neighborhoods in square 2D structures.</p> Source code in <code>pylattica/structures/square_grid/neighborhoods.py</code> <pre><code>class VonNeumannNbHood2DBuilder(MotifNeighborhoodBuilder):\n    \"\"\"A helper class for generating von Neumann type neighborhoods in square 2D structures.\"\"\"\n\n    def __init__(self, size=1):\n        \"\"\"Constructs the VonNeumannNbHood2DBuilder.\n\n        Parameters\n        ----------\n        size : int, optional\n            The size of the neighborhood, the traditional von Neumann neighborhood would have a size of 1\n        \"\"\"\n        points = get_points_in_cube(-size, size + 1, 2)\n\n        filtered_points = []\n        for point in points:\n            if sum(np.abs(p) for p in point) &lt;= size:\n                filtered_points.append(point)\n\n        super().__init__(filtered_points)\n</code></pre>"},{"location":"reference/structures/square_grid/neighborhoods/#pylattica.structures.square_grid.neighborhoods.VonNeumannNbHood2DBuilder.__init__","title":"<code>__init__(size=1)</code>","text":"<p>Constructs the VonNeumannNbHood2DBuilder.</p>"},{"location":"reference/structures/square_grid/neighborhoods/#pylattica.structures.square_grid.neighborhoods.VonNeumannNbHood2DBuilder.__init__--parameters","title":"Parameters","text":"int, optional <p>The size of the neighborhood, the traditional von Neumann neighborhood would have a size of 1</p> Source code in <code>pylattica/structures/square_grid/neighborhoods.py</code> <pre><code>def __init__(self, size=1):\n    \"\"\"Constructs the VonNeumannNbHood2DBuilder.\n\n    Parameters\n    ----------\n    size : int, optional\n        The size of the neighborhood, the traditional von Neumann neighborhood would have a size of 1\n    \"\"\"\n    points = get_points_in_cube(-size, size + 1, 2)\n\n    filtered_points = []\n    for point in points:\n        if sum(np.abs(p) for p in point) &lt;= size:\n            filtered_points.append(point)\n\n    super().__init__(filtered_points)\n</code></pre>"},{"location":"reference/structures/square_grid/neighborhoods/#pylattica.structures.square_grid.neighborhoods.VonNeumannNbHood3DBuilder","title":"<code>VonNeumannNbHood3DBuilder</code>","text":"<p>         Bases: <code>MotifNeighborhoodBuilder</code></p> <p>A helper class for generating von Neumann type neighborhoods in square 3D structures.</p> Source code in <code>pylattica/structures/square_grid/neighborhoods.py</code> <pre><code>class VonNeumannNbHood3DBuilder(MotifNeighborhoodBuilder):\n    \"\"\"A helper class for generating von Neumann type neighborhoods in square 3D structures.\"\"\"\n\n    def __init__(self, size: int):\n        \"\"\"Constructs the VonNeumannNbHood3D Builder\n\n        Parameters\n        ----------\n        size : int\n            The size of the neighborhood.\n        \"\"\"\n        points = get_points_in_cube(-size, size + 1, 3)\n\n        filtered_points = []\n        for point in points:\n            if sum(np.abs(p) for p in point) &lt;= size:\n                filtered_points.append(point)\n\n        super().__init__(filtered_points)\n</code></pre>"},{"location":"reference/structures/square_grid/neighborhoods/#pylattica.structures.square_grid.neighborhoods.VonNeumannNbHood3DBuilder.__init__","title":"<code>__init__(size)</code>","text":"<p>Constructs the VonNeumannNbHood3D Builder</p>"},{"location":"reference/structures/square_grid/neighborhoods/#pylattica.structures.square_grid.neighborhoods.VonNeumannNbHood3DBuilder.__init__--parameters","title":"Parameters","text":"int <p>The size of the neighborhood.</p> Source code in <code>pylattica/structures/square_grid/neighborhoods.py</code> <pre><code>def __init__(self, size: int):\n    \"\"\"Constructs the VonNeumannNbHood3D Builder\n\n    Parameters\n    ----------\n    size : int\n        The size of the neighborhood.\n    \"\"\"\n    points = get_points_in_cube(-size, size + 1, 3)\n\n    filtered_points = []\n    for point in points:\n        if sum(np.abs(p) for p in point) &lt;= size:\n            filtered_points.append(point)\n\n    super().__init__(filtered_points)\n</code></pre>"},{"location":"reference/structures/square_grid/structure_builders/","title":"StructureBuilders","text":""},{"location":"reference/structures/square_grid/structure_builders/#pylattica.structures.square_grid.structure_builders.SimpleSquare2DStructureBuilder","title":"<code>SimpleSquare2DStructureBuilder</code>","text":"<p>         Bases: <code>StructureBuilder</code></p> <p>A helper class for generating square 2D grid structures.</p> Source code in <code>pylattica/structures/square_grid/structure_builders.py</code> <pre><code>class SimpleSquare2DStructureBuilder(StructureBuilder):\n    \"\"\"A helper class for generating square 2D grid structures.\"\"\"\n\n    SITE_CLASS = \"_A\"\n\n    def __init__(self):\n        self.lattice = SquareGridLattice2D()\n\n        self.motif = {\n            SimpleSquare2DStructureBuilder.SITE_CLASS: [(SITE_POSITION, SITE_POSITION)],\n        }\n</code></pre>"},{"location":"reference/structures/square_grid/structure_builders/#pylattica.structures.square_grid.structure_builders.SimpleSquare3DStructureBuilder","title":"<code>SimpleSquare3DStructureBuilder</code>","text":"<p>         Bases: <code>StructureBuilder</code></p> <p>A helper class for generating square 3D grid structures.</p> Source code in <code>pylattica/structures/square_grid/structure_builders.py</code> <pre><code>class SimpleSquare3DStructureBuilder(StructureBuilder):\n    \"\"\"A helper class for generating square 3D grid structures.\"\"\"\n\n    SITE_CLASS = \"_A\"\n\n    def __init__(self):\n        self.lattice = SquareGridLattice3D()\n        self.motif = {\n            SimpleSquare3DStructureBuilder.SITE_CLASS: [\n                (SITE_POSITION, SITE_POSITION, SITE_POSITION)\n            ],\n        }\n</code></pre>"},{"location":"reference/visualization/result_artist/","title":"ResultArtist","text":""},{"location":"reference/visualization/result_artist/#pylattica.visualization.result_artist.ResultArtist","title":"<code>ResultArtist</code>","text":"<p>A class for rendering simulation results as animated GIFs.</p> Source code in <code>pylattica/visualization/result_artist.py</code> <pre><code>class ResultArtist:\n    \"\"\"A class for rendering simulation results as animated GIFs.\"\"\"\n\n    def __init__(self, step_artist: StructureArtist, result: SimulationResult):\n        \"\"\"Instantiates the ResultArtist class.\n\n        Parameters\n        ----------\n        step_artist : StructureArtist\n            The artist that should be used to render each step of the simulation.\n        result : SimulationResult\n            The result to render.\n        \"\"\"\n        self._step_artist = step_artist\n        self.result = result\n\n    def _get_images(self, **kwargs):\n        draw_freq = kwargs.get(\"draw_freq\", 1)\n        indices = list(range(0, len(self.result), draw_freq))\n        imgs = []\n\n        if sys.platform.startswith(\"win\"):\n            for idx in indices:\n                label = f\"Step {idx}\"\n                step_kwargs = {**kwargs, \"label\": label}\n                step = self.result.get_step(idx)\n                img = self._step_artist.get_img(step, **step_kwargs)\n                imgs.append(img)\n        else:\n            PROCESSES = mp.cpu_count()\n            global _dsr_globals  # pylint: disable=global-variable-not-assigned\n            _dsr_globals[\"artist\"] = self._step_artist\n\n            with mp.get_context(\"fork\").Pool(PROCESSES) as pool:\n                params = []\n                for idx in indices:\n                    label = f\"Step {idx}\"\n                    step_kwargs = {**kwargs, \"label\": label}\n                    step = self.result.get_step(idx)\n                    params.append([step, step_kwargs])\n\n                for img in pool.starmap(_get_img_parallel, params):\n                    imgs.append(img)\n\n        return imgs\n\n    def jupyter_show_step(\n        self,\n        step_no: int,\n        cell_size=20,\n    ) -&gt; None:\n        \"\"\"In a jupyter notebook environment, visualizes the step as a color coded phase grid.\n\n        Parameters\n        ----------\n        step_no : int\n            The step of the simulation to visualize\n        cell_size : int, optional\n            The size of each simulation cell, in pixels, by default 20\n        \"\"\"\n        label = f\"Step {step_no}\"  # pragma: no cover\n        step = self.result.get_step(step_no)  # pragma: no cover\n        self._step_artist.jupyter_show(\n            step, label=label, cell_size=cell_size\n        )  # pragma: no cover\n\n    def jupyter_play(\n        self,\n        cell_size: int = 20,\n        wait: int = 1,\n    ):\n        \"\"\"In a jupyter notebook environment, plays the simulation visualization back by showing a\n        series of images with {wait} seconds between each one.\n\n        Parameters\n        ----------\n        cell_size : int, optional\n            The sidelength of a grid cell in pixels. Defaults to 20., by default 20\n        wait : int, optional\n            The time duration between frames in the animation. Defaults to 1., by default 1\n        \"\"\"\n        from IPython.display import clear_output, display  # pragma: no cover\n\n        imgs = self._get_images(cell_size=cell_size)  # pragma: no cover\n        for img in imgs:  # pragma: no cover\n            clear_output()  # pragma: no cover\n            display(img)  # pragma: no cover\n            time.sleep(wait)  # pragma: no cover\n\n    def to_gif(self, filename: str, **kwargs) -&gt; None:\n        \"\"\"Saves the simulation result result as an animated GIF.\n\n        Parameters\n        ----------\n        filename : str\n            The filename for the resulting file.\n        \"\"\"\n        wait = kwargs.get(\"wait\", 0.8)\n        imgs = self._get_images(**kwargs)\n        img_names = []\n        for idx, img in enumerate(imgs):\n            fname = f\"tmp_pylat_step_{idx}.png\"\n            img.save(fname)\n            img_names.append(fname)\n\n        reloaded_imgs = []\n        for fname in img_names:\n            reloaded_imgs.append(Image.open(fname))\n\n        reloaded_imgs[0].save(\n            filename,\n            save_all=True,\n            append_images=reloaded_imgs[1:],\n            duration=wait * 1000,\n            loop=0,\n        )\n\n        for fname in img_names:\n            os.remove(fname)\n</code></pre>"},{"location":"reference/visualization/result_artist/#pylattica.visualization.result_artist.ResultArtist.__init__","title":"<code>__init__(step_artist, result)</code>","text":"<p>Instantiates the ResultArtist class.</p>"},{"location":"reference/visualization/result_artist/#pylattica.visualization.result_artist.ResultArtist.__init__--parameters","title":"Parameters","text":"StructureArtist <p>The artist that should be used to render each step of the simulation.</p> SimulationResult <p>The result to render.</p> Source code in <code>pylattica/visualization/result_artist.py</code> <pre><code>def __init__(self, step_artist: StructureArtist, result: SimulationResult):\n    \"\"\"Instantiates the ResultArtist class.\n\n    Parameters\n    ----------\n    step_artist : StructureArtist\n        The artist that should be used to render each step of the simulation.\n    result : SimulationResult\n        The result to render.\n    \"\"\"\n    self._step_artist = step_artist\n    self.result = result\n</code></pre>"},{"location":"reference/visualization/result_artist/#pylattica.visualization.result_artist.ResultArtist.jupyter_play","title":"<code>jupyter_play(cell_size=20, wait=1)</code>","text":"<p>In a jupyter notebook environment, plays the simulation visualization back by showing a series of images with {wait} seconds between each one.</p>"},{"location":"reference/visualization/result_artist/#pylattica.visualization.result_artist.ResultArtist.jupyter_play--parameters","title":"Parameters","text":"int, optional <p>The sidelength of a grid cell in pixels. Defaults to 20., by default 20</p> int, optional <p>The time duration between frames in the animation. Defaults to 1., by default 1</p> Source code in <code>pylattica/visualization/result_artist.py</code> <pre><code>def jupyter_play(\n    self,\n    cell_size: int = 20,\n    wait: int = 1,\n):\n    \"\"\"In a jupyter notebook environment, plays the simulation visualization back by showing a\n    series of images with {wait} seconds between each one.\n\n    Parameters\n    ----------\n    cell_size : int, optional\n        The sidelength of a grid cell in pixels. Defaults to 20., by default 20\n    wait : int, optional\n        The time duration between frames in the animation. Defaults to 1., by default 1\n    \"\"\"\n    from IPython.display import clear_output, display  # pragma: no cover\n\n    imgs = self._get_images(cell_size=cell_size)  # pragma: no cover\n    for img in imgs:  # pragma: no cover\n        clear_output()  # pragma: no cover\n        display(img)  # pragma: no cover\n        time.sleep(wait)  # pragma: no cover\n</code></pre>"},{"location":"reference/visualization/result_artist/#pylattica.visualization.result_artist.ResultArtist.jupyter_show_step","title":"<code>jupyter_show_step(step_no, cell_size=20)</code>","text":"<p>In a jupyter notebook environment, visualizes the step as a color coded phase grid.</p>"},{"location":"reference/visualization/result_artist/#pylattica.visualization.result_artist.ResultArtist.jupyter_show_step--parameters","title":"Parameters","text":"int <p>The step of the simulation to visualize</p> int, optional <p>The size of each simulation cell, in pixels, by default 20</p> Source code in <code>pylattica/visualization/result_artist.py</code> <pre><code>def jupyter_show_step(\n    self,\n    step_no: int,\n    cell_size=20,\n) -&gt; None:\n    \"\"\"In a jupyter notebook environment, visualizes the step as a color coded phase grid.\n\n    Parameters\n    ----------\n    step_no : int\n        The step of the simulation to visualize\n    cell_size : int, optional\n        The size of each simulation cell, in pixels, by default 20\n    \"\"\"\n    label = f\"Step {step_no}\"  # pragma: no cover\n    step = self.result.get_step(step_no)  # pragma: no cover\n    self._step_artist.jupyter_show(\n        step, label=label, cell_size=cell_size\n    )  # pragma: no cover\n</code></pre>"},{"location":"reference/visualization/result_artist/#pylattica.visualization.result_artist.ResultArtist.to_gif","title":"<code>to_gif(filename, **kwargs)</code>","text":"<p>Saves the simulation result result as an animated GIF.</p>"},{"location":"reference/visualization/result_artist/#pylattica.visualization.result_artist.ResultArtist.to_gif--parameters","title":"Parameters","text":"str <p>The filename for the resulting file.</p> Source code in <code>pylattica/visualization/result_artist.py</code> <pre><code>def to_gif(self, filename: str, **kwargs) -&gt; None:\n    \"\"\"Saves the simulation result result as an animated GIF.\n\n    Parameters\n    ----------\n    filename : str\n        The filename for the resulting file.\n    \"\"\"\n    wait = kwargs.get(\"wait\", 0.8)\n    imgs = self._get_images(**kwargs)\n    img_names = []\n    for idx, img in enumerate(imgs):\n        fname = f\"tmp_pylat_step_{idx}.png\"\n        img.save(fname)\n        img_names.append(fname)\n\n    reloaded_imgs = []\n    for fname in img_names:\n        reloaded_imgs.append(Image.open(fname))\n\n    reloaded_imgs[0].save(\n        filename,\n        save_all=True,\n        append_images=reloaded_imgs[1:],\n        duration=wait * 1000,\n        loop=0,\n    )\n\n    for fname in img_names:\n        os.remove(fname)\n</code></pre>"},{"location":"reference/visualization/square_grid_artist_2D/","title":"SquareGridArtist2D","text":""},{"location":"reference/visualization/square_grid_artist_2D/#pylattica.visualization.square_grid_artist_2D.SquareGridArtist2D","title":"<code>SquareGridArtist2D</code>","text":"<p>         Bases: <code>StructureArtist</code></p> <p>A helper StructureArtist class for rendering 2D square grids.</p> Source code in <code>pylattica/visualization/square_grid_artist_2D.py</code> <pre><code>class SquareGridArtist2D(StructureArtist):\n    \"\"\"A helper StructureArtist class for rendering 2D square grids.\"\"\"\n\n    def _draw_image(self, state: SimulationState, **kwargs):\n        label = kwargs.get(\"label\", None)\n        cell_size = kwargs.get(\"cell_size\", 20)\n\n        legend = self.cell_artist.get_legend(state)\n        legend_order = sorted(legend.keys())\n        state_size = int(self.structure.lattice.vec_lengths[0])\n        width = state_size + 6\n\n        legend_border_width = 5\n        height = max(state_size, len(legend) + 1)\n        img = Image.new(\n            \"RGB\",\n            (width * cell_size + legend_border_width, height * cell_size),\n            \"black\",\n        )  # Create a new black image\n\n        pixels = img.load()\n        draw = ImageDraw.Draw(img)\n\n        for site in self.structure.sites():\n            loc = site[LOCATION]\n            cell_state = state.get_site_state(site[SITE_ID])\n            cell_color = self.cell_artist.get_color_from_cell_state(cell_state)\n            p_x_start = int((loc[0]) * cell_size)\n            p_y_start = int((state_size - 1 - loc[1]) * cell_size)\n            for p_x in range(p_x_start, p_x_start + cell_size):\n                for p_y in range(p_y_start, p_y_start + cell_size):\n                    pixels[p_x, p_y] = cell_color\n\n        count = 0\n        legend_hoffset = int(cell_size / 4)\n        legend_voffset = int(cell_size / 4)\n\n        for p_y in range(height * cell_size):\n            for p_x in range(0, legend_border_width):\n                x = state_size * cell_size + p_x\n                pixels[x, p_y] = (255, 255, 255)\n\n        for phase in legend_order:\n            color = legend.get(phase)\n            p_col_start = state_size * cell_size + legend_border_width + legend_hoffset\n            p_row_start = count * cell_size + legend_voffset\n            for p_x in range(p_col_start, p_col_start + cell_size):\n                for p_y in range(p_row_start, p_row_start + cell_size):\n                    pixels[p_x, p_y] = color\n\n            legend_label_loc = (\n                int(p_col_start + cell_size + cell_size / 4),\n                int(p_row_start + cell_size / 4),\n            )\n            draw.text(legend_label_loc, phase, (255, 255, 255))\n            count += 1\n\n        if label is not None:\n            draw.text((5, 5), label, (255, 255, 255))\n\n        return img\n</code></pre>"},{"location":"reference/visualization/square_grid_artist_3D/","title":"SquareGridArtist3D","text":""},{"location":"reference/visualization/square_grid_artist_3D/#pylattica.visualization.square_grid_artist_3D.SquareGridArtist3D","title":"<code>SquareGridArtist3D</code>","text":"<p>         Bases: <code>StructureArtist</code></p> <p>A helper StructureArtist class for rendering 3D square grids.</p> Source code in <code>pylattica/visualization/square_grid_artist_3D.py</code> <pre><code>class SquareGridArtist3D(StructureArtist):\n    \"\"\"A helper StructureArtist class for rendering 3D square grids.\"\"\"\n\n    def _draw_image(self, state: SimulationState, **kwargs):\n        shell_only = kwargs.get(\"shell_only\", False)\n\n        size = round(state.size ** (1 / 3))\n\n        shape = [size for _ in range(self.structure.dim)]\n        dataset = {}\n\n        dataset[\"empty\"] = np.ones(shape)\n        color_cache = {}\n\n        for site in self.structure.sites():\n            loc = site[LOCATION]\n            if not shell_only or (loc[1] == 0 or loc[0] == size or loc[2] == size):\n                site_id = site[SITE_ID]\n                site_state = state.get_site_state(site_id)\n                color = self.cell_artist.get_color_from_cell_state(site_state)\n                color_str = str(color)\n                if color_str not in color_cache:\n                    color_cache[color_str] = color\n\n                if color_str not in dataset:\n                    dataset[color_str] = np.zeros(shape)\n\n                shifted_loc = tuple(int(i) for i in loc)\n                dataset[color_str][shifted_loc] = 1\n                dataset[\"empty\"][shifted_loc] = 0\n\n        ax = plt.figure(figsize=(12, 12)).add_subplot(projection=\"3d\")\n\n        for color, data in dataset.items():\n            if color == \"empty\":\n                colors = [0.8, 0.8, 0.8, 0.2]\n                ax.voxels(data, facecolors=colors, edgecolor=\"k\", linewidth=0)\n            else:\n                colors = np.array(color_cache[color]) / 255\n                ax.voxels(data, facecolors=colors, edgecolor=\"k\", linewidth=0.25)\n\n        ax.legend()\n        plt.axis(\"off\")\n        fig = ax.get_figure()\n        buf = io.BytesIO()\n        fig.savefig(buf)\n        plt.close()\n        buf.seek(0)\n        img = Image.open(buf)\n        return img\n</code></pre>"}]}